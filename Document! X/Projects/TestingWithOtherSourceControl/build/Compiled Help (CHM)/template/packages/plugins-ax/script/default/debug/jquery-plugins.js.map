{"version":3,"sources":["js.cookie.js","jquery.qtip.js","clipboard.js","slimbox2.js","jquery.fitvids.js","modernizr.custom.js","yepnope.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACr6GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACz7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA;AACA;AACA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"innovasys.jqueryplugins.js","sourcesContent":["/*!\n * JavaScript Cookie v2.2.1\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader;\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n}(function () {\n\tfunction extend () {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[ i ];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction decode (s) {\n\t\treturn s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);\n\t}\n\n\tfunction init (converter) {\n\t\tfunction api() {}\n\n\t\tfunction set (key, value, attributes) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tattributes = extend({\n\t\t\t\tpath: '/'\n\t\t\t}, api.defaults, attributes);\n\n\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\tattributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);\n\t\t\t}\n\n\t\t\t// We're using \"expires\" because \"max-age\" is not supported by IE\n\t\t\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n\t\t\ttry {\n\t\t\t\tvar result = JSON.stringify(value);\n\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\tvalue = result;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\n\t\t\tvalue = converter.write ?\n\t\t\t\tconverter.write(value, key) :\n\t\t\t\tencodeURIComponent(String(value))\n\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\n\t\t\tkey = encodeURIComponent(String(key))\n\t\t\t\t.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)\n\t\t\t\t.replace(/[\\(\\)]/g, escape);\n\n\t\t\tvar stringifiedAttributes = '';\n\t\t\tfor (var attributeName in attributes) {\n\t\t\t\tif (!attributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstringifiedAttributes += '; ' + attributeName;\n\t\t\t\tif (attributes[attributeName] === true) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Considers RFC 6265 section 5.2:\n\t\t\t\t// ...\n\t\t\t\t// 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n\t\t\t\t//     character:\n\t\t\t\t// Consume the characters of the unparsed-attributes up to,\n\t\t\t\t// not including, the first %x3B (\";\") character.\n\t\t\t\t// ...\n\t\t\t\tstringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n\t\t\t}\n\n\t\t\treturn (document.cookie = key + '=' + value + stringifiedAttributes);\n\t\t}\n\n\t\tfunction get (key, json) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar jar = {};\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all.\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (!json && cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = decode(parts[0]);\n\t\t\t\t\tcookie = (converter.read || converter)(cookie, name) ||\n\t\t\t\t\t\tdecode(cookie);\n\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tjar[name] = cookie;\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn key ? jar[key] : jar;\n\t\t}\n\n\t\tapi.set = set;\n\t\tapi.get = function (key) {\n\t\t\treturn get(key, false /* read as raw */);\n\t\t};\n\t\tapi.getJSON = function (key) {\n\t\t\treturn get(key, true /* read as json */);\n\t\t};\n\t\tapi.remove = function (key, attributes) {\n\t\t\tset(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.defaults = {};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n}));\n","/*\r\n * qTip2 - Pretty powerful tooltips - v3.0.3\r\n * http://qtip2.com\r\n *\r\n * Copyright (c) 2016 \r\n * Released under the MIT licenses\r\n * http://jquery.org/license\r\n *\r\n * Date: Wed May 11 2016 10:31 GMT+0100+0100\r\n * Plugins: tips modal viewport svg imagemap ie6\r\n * Styles: core basic css3\r\n */\r\n/*global window: false, jQuery: false, console: false, define: false */\r\n\r\n/*! Innovasys Modifications\r\n*\r\n*  Applied jQuery 3 fix from https://github.com/qTip2/qTip2/pull/818\r\n*\r\n*/\r\n\r\n/* Cache window, document, undefined */\r\n(function( window, document, undefined ) {\r\n\r\n// Uses AMD or browser globals to create a jQuery plugin.\r\n(function( factory ) {\r\n\t\"use strict\";\r\n\tif(typeof define === 'function' && define.amd) {\r\n\t\tdefine(['jquery'], factory);\r\n\t}\r\n\telse if(jQuery && !jQuery.fn.qtip) {\r\n\t\tfactory(jQuery);\r\n\t}\r\n}\r\n(function($) {\r\n\t\"use strict\"; // Enable ECMAScript \"strict\" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/\r\n;// Munge the primitives - Paul Irish tip\r\nvar TRUE = true,\r\nFALSE = false,\r\nNULL = null,\r\n\r\n// Common variables\r\nX = 'x', Y = 'y',\r\nWIDTH = 'width',\r\nHEIGHT = 'height',\r\n\r\n// Positioning sides\r\nTOP = 'top',\r\nLEFT = 'left',\r\nBOTTOM = 'bottom',\r\nRIGHT = 'right',\r\nCENTER = 'center',\r\n\r\n// Position adjustment types\r\nFLIP = 'flip',\r\nFLIPINVERT = 'flipinvert',\r\nSHIFT = 'shift',\r\n\r\n// Shortcut vars\r\nQTIP, PROTOTYPE, CORNER, CHECKS,\r\nPLUGINS = {},\r\nNAMESPACE = 'qtip',\r\nATTR_HAS = 'data-hasqtip',\r\nATTR_ID = 'data-qtip-id',\r\nWIDGET = ['ui-widget', 'ui-tooltip'],\r\nSELECTOR = '.'+NAMESPACE,\r\nINACTIVE_EVENTS = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' '),\r\n\r\nCLASS_FIXED = NAMESPACE+'-fixed',\r\nCLASS_DEFAULT = NAMESPACE + '-default',\r\nCLASS_FOCUS = NAMESPACE + '-focus',\r\nCLASS_HOVER = NAMESPACE + '-hover',\r\nCLASS_DISABLED = NAMESPACE+'-disabled',\r\n\r\nreplaceSuffix = '_replacedByqTip',\r\noldtitle = 'oldtitle',\r\ntrackingBound,\r\n\r\n// Browser detection\r\nBROWSER = {\r\n\t/*\r\n\t * IE version detection\r\n\t *\r\n\t * Adapted from: http://ajaxian.com/archives/attack-of-the-ie-conditional-comment\r\n\t * Credit to James Padolsey for the original implemntation!\r\n\t */\r\n\tie: (function() {\r\n\t\t/* eslint-disable no-empty */\r\n\t\tvar v, i;\r\n\t\tfor (\r\n\t\t\tv = 4, i = document.createElement('div');\r\n\t\t\t(i.innerHTML = '<!--[if gt IE ' + v + ']><i></i><![endif]-->') && i.getElementsByTagName('i')[0];\r\n\t\t\tv+=1\r\n\t\t) {}\r\n\t\treturn v > 4 ? v : NaN;\r\n\t\t/* eslint-enable no-empty */\r\n\t})(),\r\n\r\n\t/*\r\n\t * iOS version detection\r\n\t */\r\n\tiOS: parseFloat(\r\n\t\t('' + (/CPU.*OS ([0-9_]{1,5})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])\r\n\t\t.replace('undefined', '3_2').replace('_', '.').replace('_', '')\r\n\t) || FALSE\r\n};\r\n;function QTip(target, options, id, attr) {\r\n\t// Elements and ID\r\n\tthis.id = id;\r\n\tthis.target = target;\r\n\tthis.tooltip = NULL;\r\n\tthis.elements = { target: target };\r\n\r\n\t// Internal constructs\r\n\tthis._id = NAMESPACE + '-' + id;\r\n\tthis.timers = { img: {} };\r\n\tthis.options = options;\r\n\tthis.plugins = {};\r\n\r\n\t// Cache object\r\n\tthis.cache = {\r\n\t\tevent: {},\r\n\t\ttarget: $(),\r\n\t\tdisabled: FALSE,\r\n\t\tattr: attr,\r\n\t\tonTooltip: FALSE,\r\n\t\tlastClass: ''\r\n\t};\r\n\r\n\t// Set the initial flags\r\n\tthis.rendered = this.destroyed = this.disabled = this.waiting =\r\n\t\tthis.hiddenDuringWait = this.positioning = this.triggering = FALSE;\r\n}\r\nPROTOTYPE = QTip.prototype;\r\n\r\nPROTOTYPE._when = function(deferreds) {\r\n\treturn $.when.apply($, deferreds);\r\n};\r\n\r\nPROTOTYPE.render = function(show) {\r\n\tif(this.rendered || this.destroyed) { return this; } // If tooltip has already been rendered, exit\r\n\r\n\tvar self = this,\r\n\t\toptions = this.options,\r\n\t\tcache = this.cache,\r\n\t\telements = this.elements,\r\n\t\ttext = options.content.text,\r\n\t\ttitle = options.content.title,\r\n\t\tbutton = options.content.button,\r\n\t\tposOptions = options.position,\r\n\t\tdeferreds = [];\r\n\r\n\t// Add ARIA attributes to target\r\n\t$.attr(this.target[0], 'aria-describedby', this._id);\r\n\r\n\t// Create public position object that tracks current position corners\r\n\tcache.posClass = this._createPosClass(\r\n\t\t(this.position = { my: posOptions.my, at: posOptions.at }).my\r\n\t);\r\n\r\n\t// Create tooltip element\r\n\tthis.tooltip = elements.tooltip = $('<div/>', {\r\n\t\t'id': this._id,\r\n\t\t'class': [ NAMESPACE, CLASS_DEFAULT, options.style.classes, cache.posClass ].join(' '),\r\n\t\t'width': options.style.width || '',\r\n\t\t'height': options.style.height || '',\r\n\t\t'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,\r\n\r\n\t\t/* ARIA specific attributes */\r\n\t\t'role': 'alert',\r\n\t\t'aria-live': 'polite',\r\n\t\t'aria-atomic': FALSE,\r\n\t\t'aria-describedby': this._id + '-content',\r\n\t\t'aria-hidden': TRUE\r\n\t})\r\n\t.toggleClass(CLASS_DISABLED, this.disabled)\r\n\t.attr(ATTR_ID, this.id)\r\n\t.data(NAMESPACE, this)\r\n\t.appendTo(posOptions.container)\r\n\t.append(\r\n\t\t// Create content element\r\n\t\telements.content = $('<div />', {\r\n\t\t\t'class': NAMESPACE + '-content',\r\n\t\t\t'id': this._id + '-content',\r\n\t\t\t'aria-atomic': TRUE\r\n\t\t})\r\n\t);\r\n\r\n\t// Set rendered flag and prevent redundant reposition calls for now\r\n\tthis.rendered = -1;\r\n\tthis.positioning = TRUE;\r\n\r\n\t// Create title...\r\n\tif(title) {\r\n\t\tthis._createTitle();\r\n\r\n\t\t// Update title only if its not a callback (called in toggle if so)\r\n\t\tif(!$.isFunction(title)) {\r\n\t\t\tdeferreds.push( this._updateTitle(title, FALSE) );\r\n\t\t}\r\n\t}\r\n\r\n\t// Create button\r\n\tif(button) { this._createButton(); }\r\n\r\n\t// Set proper rendered flag and update content if not a callback function (called in toggle)\r\n\tif(!$.isFunction(text)) {\r\n\t\tdeferreds.push( this._updateContent(text, FALSE) );\r\n\t}\r\n\tthis.rendered = TRUE;\r\n\r\n\t// Setup widget classes\r\n\tthis._setWidget();\r\n\r\n\t// Initialize 'render' plugins\r\n\t$.each(PLUGINS, function(name) {\r\n\t\tvar instance;\r\n\t\tif(this.initialize === 'render' && (instance = this(self))) {\r\n\t\t\tself.plugins[name] = instance;\r\n\t\t}\r\n\t});\r\n\r\n\t// Unassign initial events and assign proper events\r\n\tthis._unassignEvents();\r\n\tthis._assignEvents();\r\n\r\n\t// When deferreds have completed\r\n\tthis._when(deferreds).then(function() {\r\n\t\t// tooltiprender event\r\n\t\tself._trigger('render');\r\n\r\n\t\t// Reset flags\r\n\t\tself.positioning = FALSE;\r\n\r\n\t\t// Show tooltip if not hidden during wait period\r\n\t\tif(!self.hiddenDuringWait && (options.show.ready || show)) {\r\n\t\t\tself.toggle(TRUE, cache.event, FALSE);\r\n\t\t}\r\n\t\tself.hiddenDuringWait = FALSE;\r\n\t});\r\n\r\n\t// Expose API\r\n\tQTIP.api[this.id] = this;\r\n\r\n\treturn this;\r\n};\r\n\r\nPROTOTYPE.destroy = function(immediate) {\r\n\t// Set flag the signify destroy is taking place to plugins\r\n\t// and ensure it only gets destroyed once!\r\n\tif(this.destroyed) { return this.target; }\r\n\r\n\tfunction process() {\r\n\t\tif(this.destroyed) { return; }\r\n\t\tthis.destroyed = TRUE;\r\n\r\n\t\tvar target = this.target,\r\n\t\t\ttitle = target.attr(oldtitle),\r\n\t\t\ttimer;\r\n\r\n\t\t// Destroy tooltip if rendered\r\n\t\tif(this.rendered) {\r\n\t\t\tthis.tooltip.stop(1,0).find('*').remove().end().remove();\r\n\t\t}\r\n\r\n\t\t// Destroy all plugins\r\n\t\t$.each(this.plugins, function() {\r\n\t\t\tthis.destroy && this.destroy();\r\n\t\t});\r\n\r\n\t\t// Clear timers\r\n\t\tfor (timer in this.timers) {\r\n\t\t\tif (this.timers.hasOwnProperty(timer)) {\r\n\t\t\t\tclearTimeout(this.timers[timer]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Remove api object and ARIA attributes\r\n\t\ttarget.removeData(NAMESPACE)\r\n\t\t\t.removeAttr(ATTR_ID)\r\n\t\t\t.removeAttr(ATTR_HAS)\r\n\t\t\t.removeAttr('aria-describedby');\r\n\r\n\t\t// Reset old title attribute if removed\r\n\t\tif(this.options.suppress && title) {\r\n\t\t\ttarget.attr('title', title).removeAttr(oldtitle);\r\n\t\t}\r\n\r\n\t\t// Remove qTip events associated with this API\r\n\t\tthis._unassignEvents();\r\n\r\n\t\t// Remove ID from used id objects, and delete object references\r\n\t\t// for better garbage collection and leak protection\r\n\t\tthis.options = this.elements = this.cache = this.timers =\r\n\t\t\tthis.plugins = this.mouse = NULL;\r\n\r\n\t\t// Delete epoxsed API object\r\n\t\tdelete QTIP.api[this.id];\r\n\t}\r\n\r\n\t// If an immediate destroy is needed\r\n\tif((immediate !== TRUE || this.triggering === 'hide') && this.rendered) {\r\n\t\tthis.tooltip.one('tooltiphidden', $.proxy(process, this));\r\n\t\t!this.triggering && this.hide();\r\n\t}\r\n\r\n\t// If we're not in the process of hiding... process\r\n\telse { process.call(this); }\r\n\r\n\treturn this.target;\r\n};\r\n;function invalidOpt(a) {\r\n\treturn a === NULL || $.type(a) !== 'object';\r\n}\r\n\r\nfunction invalidContent(c) {\r\n\treturn !($.isFunction(c) || \r\n            c && c.attr || \r\n            c.length || \r\n            $.type(c) === 'object' && (c.jquery || c.then));\r\n}\r\n\r\n// Option object sanitizer\r\nfunction sanitizeOptions(opts) {\r\n\tvar content, text, ajax, once;\r\n\r\n\tif(invalidOpt(opts)) { return FALSE; }\r\n\r\n\tif(invalidOpt(opts.metadata)) {\r\n\t\topts.metadata = { type: opts.metadata };\r\n\t}\r\n\r\n\tif('content' in opts) {\r\n\t\tcontent = opts.content;\r\n\r\n\t\tif(invalidOpt(content) || content.jquery || content.done) {\r\n\t\t\ttext = invalidContent(content) ? FALSE : content;\r\n\t\t\tcontent = opts.content = {\r\n\t\t\t\ttext: text\r\n\t\t\t};\r\n\t\t}\r\n\t\telse { text = content.text; }\r\n\r\n\t\t// DEPRECATED - Old content.ajax plugin functionality\r\n\t\t// Converts it into the proper Deferred syntax\r\n\t\tif('ajax' in content) {\r\n\t\t\tajax = content.ajax;\r\n\t\t\tonce = ajax && ajax.once !== FALSE;\r\n\t\t\tdelete content.ajax;\r\n\r\n\t\t\tcontent.text = function(event, api) {\r\n\t\t\t\tvar loading = text || $(this).attr(api.options.content.attr) || 'Loading...',\r\n\r\n\t\t\t\tdeferred = $.ajax(\r\n\t\t\t\t\t$.extend({}, ajax, { context: api })\r\n\t\t\t\t)\r\n\t\t\t\t.then(ajax.success, NULL, ajax.error)\r\n\t\t\t\t.then(function(newContent) {\r\n\t\t\t\t\tif(newContent && once) { api.set('content.text', newContent); }\r\n\t\t\t\t\treturn newContent;\r\n\t\t\t\t},\r\n\t\t\t\tfunction(xhr, status, error) {\r\n\t\t\t\t\tif(api.destroyed || xhr.status === 0) { return; }\r\n\t\t\t\t\tapi.set('content.text', status + ': ' + error);\r\n\t\t\t\t});\r\n\r\n\t\t\t\treturn !once ? (api.set('content.text', loading), deferred) : loading;\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tif('title' in content) {\r\n\t\t\tif($.isPlainObject(content.title)) {\r\n\t\t\t\tcontent.button = content.title.button;\r\n\t\t\t\tcontent.title = content.title.text;\r\n\t\t\t}\r\n\r\n\t\t\tif(invalidContent(content.title || FALSE)) {\r\n\t\t\t\tcontent.title = FALSE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif('position' in opts && invalidOpt(opts.position)) {\r\n\t\topts.position = { my: opts.position, at: opts.position };\r\n\t}\r\n\r\n\tif('show' in opts && invalidOpt(opts.show)) {\r\n\t\topts.show = opts.show.jquery ? { target: opts.show } :\r\n\t\t\topts.show === TRUE ? { ready: TRUE } : { event: opts.show };\r\n\t}\r\n\r\n\tif('hide' in opts && invalidOpt(opts.hide)) {\r\n\t\topts.hide = opts.hide.jquery ? { target: opts.hide } : { event: opts.hide };\r\n\t}\r\n\r\n\tif('style' in opts && invalidOpt(opts.style)) {\r\n\t\topts.style = { classes: opts.style };\r\n\t}\r\n\r\n\t// Sanitize plugin options\r\n\t$.each(PLUGINS, function() {\r\n\t\tthis.sanitize && this.sanitize(opts);\r\n\t});\r\n\r\n\treturn opts;\r\n}\r\n\r\n// Setup builtin .set() option checks\r\nCHECKS = PROTOTYPE.checks = {\r\n\tbuiltin: {\r\n\t\t// Core checks\r\n\t\t'^id$': function(obj, o, v, prev) {\r\n\t\t\tvar id = v === TRUE ? QTIP.nextid : v,\r\n\t\t\t\tnewId = NAMESPACE + '-' + id;\r\n\r\n\t\t\tif(id !== FALSE && id.length > 0 && !$('#'+newId).length) {\r\n\t\t\t\tthis._id = newId;\r\n\r\n\t\t\t\tif(this.rendered) {\r\n\t\t\t\t\tthis.tooltip[0].id = this._id;\r\n\t\t\t\t\tthis.elements.content[0].id = this._id + '-content';\r\n\t\t\t\t\tthis.elements.title[0].id = this._id + '-title';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { obj[o] = prev; }\r\n\t\t},\r\n\t\t'^prerender': function(obj, o, v) {\r\n\t\t\tv && !this.rendered && this.render(this.options.show.ready);\r\n\t\t},\r\n\r\n\t\t// Content checks\r\n\t\t'^content.text$': function(obj, o, v) {\r\n\t\t\tthis._updateContent(v);\r\n\t\t},\r\n\t\t'^content.attr$': function(obj, o, v, prev) {\r\n\t\t\tif(this.options.content.text === this.target.attr(prev)) {\r\n\t\t\t\tthis._updateContent( this.target.attr(v) );\r\n\t\t\t}\r\n\t\t},\r\n\t\t'^content.title$': function(obj, o, v) {\r\n\t\t\t// Remove title if content is null\r\n\t\t\tif(!v) { return this._removeTitle(); }\r\n\r\n\t\t\t// If title isn't already created, create it now and update\r\n\t\t\tv && !this.elements.title && this._createTitle();\r\n\t\t\tthis._updateTitle(v);\r\n\t\t},\r\n\t\t'^content.button$': function(obj, o, v) {\r\n\t\t\tthis._updateButton(v);\r\n\t\t},\r\n\t\t'^content.title.(text|button)$': function(obj, o, v) {\r\n\t\t\tthis.set('content.'+o, v); // Backwards title.text/button compat\r\n\t\t},\r\n\r\n\t\t// Position checks\r\n\t\t'^position.(my|at)$': function(obj, o, v){\r\n\t\t\tif('string' === typeof v) {\r\n\t\t\t\tthis.position[o] = obj[o] = new CORNER(v, o === 'at');\r\n\t\t\t}\r\n\t\t},\r\n\t\t'^position.container$': function(obj, o, v){\r\n\t\t\tthis.rendered && this.tooltip.appendTo(v);\r\n\t\t},\r\n\r\n\t\t// Show checks\r\n\t\t'^show.ready$': function(obj, o, v) {\r\n\t\t\tv && (!this.rendered && this.render(TRUE) || this.toggle(TRUE));\r\n\t\t},\r\n\r\n\t\t// Style checks\r\n\t\t'^style.classes$': function(obj, o, v, p) {\r\n\t\t\tthis.rendered && this.tooltip.removeClass(p).addClass(v);\r\n\t\t},\r\n\t\t'^style.(width|height)': function(obj, o, v) {\r\n\t\t\tthis.rendered && this.tooltip.css(o, v);\r\n\t\t},\r\n\t\t'^style.widget|content.title': function() {\r\n\t\t\tthis.rendered && this._setWidget();\r\n\t\t},\r\n\t\t'^style.def': function(obj, o, v) {\r\n\t\t\tthis.rendered && this.tooltip.toggleClass(CLASS_DEFAULT, !!v);\r\n\t\t},\r\n\r\n\t\t// Events check\r\n\t\t'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {\r\n\t\t\tthis.rendered && this.tooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);\r\n\t\t},\r\n\r\n\t\t// Properties which require event reassignment\r\n\t\t'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {\r\n\t\t\tif(!this.rendered) { return; }\r\n\r\n\t\t\t// Set tracking flag\r\n\t\t\tvar posOptions = this.options.position;\r\n\t\t\tthis.tooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);\r\n\r\n\t\t\t// Reassign events\r\n\t\t\tthis._unassignEvents();\r\n\t\t\tthis._assignEvents();\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Dot notation converter\r\nfunction convertNotation(options, notation) {\r\n\tvar i = 0, obj, option = options,\r\n\r\n\t// Split notation into array\r\n\tlevels = notation.split('.');\r\n\r\n\t// Loop through\r\n\twhile(option = option[ levels[i++] ]) {\r\n\t\tif(i < levels.length) { obj = option; }\r\n\t}\r\n\r\n\treturn [obj || options, levels.pop()];\r\n}\r\n\r\nPROTOTYPE.get = function(notation) {\r\n\tif(this.destroyed) { return this; }\r\n\r\n\tvar o = convertNotation(this.options, notation.toLowerCase()),\r\n\t\tresult = o[0][ o[1] ];\r\n\r\n\treturn result.precedance ? result.string() : result;\r\n};\r\n\r\nfunction setCallback(notation, args) {\r\n\tvar category, rule, match;\r\n\r\n\tfor(category in this.checks) {\r\n\t\tif (!this.checks.hasOwnProperty(category)) { continue; }\r\n\r\n\t\tfor(rule in this.checks[category]) {\r\n\t\t\tif (!this.checks[category].hasOwnProperty(rule)) { continue; }\r\n\r\n\t\t\tif(match = (new RegExp(rule, 'i')).exec(notation)) {\r\n\t\t\t\targs.push(match);\r\n\r\n\t\t\t\tif(category === 'builtin' || this.plugins[category]) {\r\n\t\t\t\t\tthis.checks[category][rule].apply(\r\n\t\t\t\t\t\tthis.plugins[category] || this, args\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvar rmove = /^position\\.(my|at|adjust|target|container|viewport)|style|content|show\\.ready/i,\r\n\trrender = /^prerender|show\\.ready/i;\r\n\r\nPROTOTYPE.set = function(option, value) {\r\n\tif(this.destroyed) { return this; }\r\n\r\n\tvar rendered = this.rendered,\r\n\t\treposition = FALSE,\r\n\t\toptions = this.options,\r\n\t\tname;\r\n\r\n\t// Convert singular option/value pair into object form\r\n\tif('string' === typeof option) {\r\n\t\tname = option; option = {}; option[name] = value;\r\n\t}\r\n\telse { option = $.extend({}, option); }\r\n\r\n\t// Set all of the defined options to their new values\r\n\t$.each(option, function(notation, val) {\r\n\t\tif(rendered && rrender.test(notation)) {\r\n\t\t\tdelete option[notation]; return;\r\n\t\t}\r\n\r\n\t\t// Set new obj value\r\n\t\tvar obj = convertNotation(options, notation.toLowerCase()), previous;\r\n\t\tprevious = obj[0][ obj[1] ];\r\n\t\tobj[0][ obj[1] ] = val && val.nodeType ? $(val) : val;\r\n\r\n\t\t// Also check if we need to reposition\r\n\t\treposition = rmove.test(notation) || reposition;\r\n\r\n\t\t// Set the new params for the callback\r\n\t\toption[notation] = [obj[0], obj[1], val, previous];\r\n\t});\r\n\r\n\t// Re-sanitize options\r\n\tsanitizeOptions(options);\r\n\r\n\t/*\r\n\t * Execute any valid callbacks for the set options\r\n\t * Also set positioning flag so we don't get loads of redundant repositioning calls.\r\n\t */\r\n\tthis.positioning = TRUE;\r\n\t$.each(option, $.proxy(setCallback, this));\r\n\tthis.positioning = FALSE;\r\n\r\n\t// Update position if needed\r\n\tif(this.rendered && this.tooltip[0].offsetWidth > 0 && reposition) {\r\n\t\tthis.reposition( options.position.target === 'mouse' ? NULL : this.cache.event );\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n;PROTOTYPE._update = function(content, element) {\r\n\tvar self = this,\r\n\t\tcache = this.cache;\r\n\r\n\t// Make sure tooltip is rendered and content is defined. If not return\r\n\tif(!this.rendered || !content) { return FALSE; }\r\n\r\n\t// Use function to parse content\r\n\tif($.isFunction(content)) {\r\n\t\tcontent = content.call(this.elements.target, cache.event, this) || '';\r\n\t}\r\n\r\n\t// Handle deferred content\r\n\tif($.isFunction(content.then)) {\r\n\t\tcache.waiting = TRUE;\r\n\t\treturn content.then(function(c) {\r\n\t\t\tcache.waiting = FALSE;\r\n\t\t\treturn self._update(c, element);\r\n\t\t}, NULL, function(e) {\r\n\t\t\treturn self._update(e, element);\r\n\t\t});\r\n\t}\r\n\r\n\t// If content is null... return false\r\n\tif(content === FALSE || !content && content !== '') { return FALSE; }\r\n\r\n\t// Append new content if its a DOM array and show it if hidden\r\n\tif(content.jquery && content.length > 0) {\r\n\t\telement.empty().append(\r\n\t\t\tcontent.css({ display: 'block', visibility: 'visible' })\r\n\t\t);\r\n\t}\r\n\r\n\t// Content is a regular string, insert the new content\r\n\telse { element.html(content); }\r\n\r\n\t// Wait for content to be loaded, and reposition\r\n\treturn this._waitForContent(element).then(function(images) {\r\n\t\tif(self.rendered && self.tooltip[0].offsetWidth > 0) {\r\n\t\t\tself.reposition(cache.event, !images.length);\r\n\t\t}\r\n\t});\r\n};\r\n\r\nPROTOTYPE._waitForContent = function(element) {\r\n\tvar cache = this.cache;\r\n\r\n\t// Set flag\r\n\tcache.waiting = TRUE;\r\n\r\n\t// If imagesLoaded is included, ensure images have loaded and return promise\r\n\treturn ( $.fn.imagesLoaded ? element.imagesLoaded() : new $.Deferred().resolve([]) )\r\n\t\t.done(function() { cache.waiting = FALSE; })\r\n\t\t.promise();\r\n};\r\n\r\nPROTOTYPE._updateContent = function(content, reposition) {\r\n\tthis._update(content, this.elements.content, reposition);\r\n};\r\n\r\nPROTOTYPE._updateTitle = function(content, reposition) {\r\n\tif(this._update(content, this.elements.title, reposition) === FALSE) {\r\n\t\tthis._removeTitle(FALSE);\r\n\t}\r\n};\r\n\r\nPROTOTYPE._createTitle = function()\r\n{\r\n\tvar elements = this.elements,\r\n\t\tid = this._id+'-title';\r\n\r\n\t// Destroy previous title element, if present\r\n\tif(elements.titlebar) { this._removeTitle(); }\r\n\r\n\t// Create title bar and title elements\r\n\telements.titlebar = $('<div />', {\r\n\t\t'class': NAMESPACE + '-titlebar ' + (this.options.style.widget ? createWidgetClass('header') : '')\r\n\t})\r\n\t.append(\r\n\t\telements.title = $('<div />', {\r\n\t\t\t'id': id,\r\n\t\t\t'class': NAMESPACE + '-title',\r\n\t\t\t'aria-atomic': TRUE\r\n\t\t})\r\n\t)\r\n\t.insertBefore(elements.content)\r\n\r\n\t// Button-specific events\r\n\t.delegate('.qtip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {\r\n\t\t$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');\r\n\t})\r\n\t.delegate('.qtip-close', 'mouseover mouseout', function(event){\r\n\t\t$(this).toggleClass('ui-state-hover', event.type === 'mouseover');\r\n\t});\r\n\r\n\t// Create button if enabled\r\n\tif(this.options.content.button) { this._createButton(); }\r\n};\r\n\r\nPROTOTYPE._removeTitle = function(reposition)\r\n{\r\n\tvar elements = this.elements;\r\n\r\n\tif(elements.title) {\r\n\t\telements.titlebar.remove();\r\n\t\telements.titlebar = elements.title = elements.button = NULL;\r\n\r\n\t\t// Reposition if enabled\r\n\t\tif(reposition !== FALSE) { this.reposition(); }\r\n\t}\r\n};\r\n;PROTOTYPE._createPosClass = function(my) {\r\n\treturn NAMESPACE + '-pos-' + (my || this.options.position.my).abbrev();\r\n};\r\n\r\nPROTOTYPE.reposition = function(event, effect) {\r\n\tif(!this.rendered || this.positioning || this.destroyed) { return this; }\r\n\r\n\t// Set positioning flag\r\n\tthis.positioning = TRUE;\r\n\r\n\tvar cache = this.cache,\r\n\t\ttooltip = this.tooltip,\r\n\t\tposOptions = this.options.position,\r\n\t\ttarget = posOptions.target,\r\n\t\tmy = posOptions.my,\r\n\t\tat = posOptions.at,\r\n\t\tviewport = posOptions.viewport,\r\n\t\tcontainer = posOptions.container,\r\n\t\tadjust = posOptions.adjust,\r\n\t\tmethod = adjust.method.split(' '),\r\n\t\ttooltipWidth = tooltip.outerWidth(FALSE),\r\n\t\ttooltipHeight = tooltip.outerHeight(FALSE),\r\n\t\ttargetWidth = 0,\r\n\t\ttargetHeight = 0,\r\n\t\ttype = tooltip.css('position'),\r\n\t\tposition = { left: 0, top: 0 },\r\n\t\tvisible = tooltip[0].offsetWidth > 0,\r\n\t\tisScroll = event && event.type === 'scroll',\r\n\t\twin = $(window),\r\n\t\tdoc = container[0].ownerDocument,\r\n\t\tmouse = this.mouse,\r\n\t\tpluginCalculations, offset, adjusted, newClass;\r\n\r\n\t// Check if absolute position was passed\r\n\tif($.isArray(target) && target.length === 2) {\r\n\t\t// Force left top and set position\r\n\t\tat = { x: LEFT, y: TOP };\r\n\t\tposition = { left: target[0], top: target[1] };\r\n\t}\r\n\r\n\t// Check if mouse was the target\r\n\telse if(target === 'mouse') {\r\n\t\t// Force left top to allow flipping\r\n\t\tat = { x: LEFT, y: TOP };\r\n\r\n\t\t// Use the mouse origin that caused the show event, if distance hiding is enabled\r\n\t\tif((!adjust.mouse || this.options.hide.distance) && cache.origin && cache.origin.pageX) {\r\n\t\t\tevent =  cache.origin;\r\n\t\t}\r\n\r\n\t\t// Use cached event for resize/scroll events\r\n\t\telse if(!event || event && (event.type === 'resize' || event.type === 'scroll')) {\r\n\t\t\tevent = cache.event;\r\n\t\t}\r\n\r\n\t\t// Otherwise, use the cached mouse coordinates if available\r\n\t\telse if(mouse && mouse.pageX) {\r\n\t\t\tevent = mouse;\r\n\t\t}\r\n\r\n\t\t// Calculate body and container offset and take them into account below\r\n\t\tif(type !== 'static') { position = container.offset(); }\r\n\t\tif(doc.body.offsetWidth !== (window.innerWidth || doc.documentElement.clientWidth)) {\r\n\t\t\toffset = $(document.body).offset();\r\n\t\t}\r\n\r\n\t\t// Use event coordinates for position\r\n\t\tposition = {\r\n\t\t\tleft: event.pageX - position.left + (offset && offset.left || 0),\r\n\t\t\ttop: event.pageY - position.top + (offset && offset.top || 0)\r\n\t\t};\r\n\r\n\t\t// Scroll events are a pain, some browsers\r\n\t\tif(adjust.mouse && isScroll && mouse) {\r\n\t\t\tposition.left -= (mouse.scrollX || 0) - win.scrollLeft();\r\n\t\t\tposition.top -= (mouse.scrollY || 0) - win.scrollTop();\r\n\t\t}\r\n\t}\r\n\r\n\t// Target wasn't mouse or absolute...\r\n\telse {\r\n\t\t// Check if event targetting is being used\r\n\t\tif(target === 'event') {\r\n\t\t\tif(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {\r\n\t\t\t\tcache.target = $(event.target);\r\n\t\t\t}\r\n\t\t\telse if(!event.target) {\r\n\t\t\t\tcache.target = this.elements.target;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if(target !== 'event'){\r\n\t\t\tcache.target = $(target.jquery ? target : this.elements.target);\r\n\t\t}\r\n\t\ttarget = cache.target;\r\n\r\n\t\t// Parse the target into a jQuery object and make sure there's an element present\r\n\t\ttarget = $(target).eq(0);\r\n\t\tif(target.length === 0) { return this; }\r\n\r\n\t\t// Check if window or document is the target\r\n\t\telse if(target[0] === document || target[0] === window) {\r\n\t\t\ttargetWidth = BROWSER.iOS ? window.innerWidth : target.width();\r\n\t\t\ttargetHeight = BROWSER.iOS ? window.innerHeight : target.height();\r\n\r\n\t\t\tif(target[0] === window) {\r\n\t\t\t\tposition = {\r\n\t\t\t\t\ttop: (viewport || target).scrollTop(),\r\n\t\t\t\t\tleft: (viewport || target).scrollLeft()\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Check if the target is an <AREA> element\r\n\t\telse if(PLUGINS.imagemap && target.is('area')) {\r\n\t\t\tpluginCalculations = PLUGINS.imagemap(this, target, at, PLUGINS.viewport ? method : FALSE);\r\n\t\t}\r\n\r\n\t\t// Check if the target is an SVG element\r\n\t\telse if(PLUGINS.svg && target && target[0].ownerSVGElement) {\r\n\t\t\tpluginCalculations = PLUGINS.svg(this, target, at, PLUGINS.viewport ? method : FALSE);\r\n\t\t}\r\n\r\n\t\t// Otherwise use regular jQuery methods\r\n\t\telse {\r\n\t\t\ttargetWidth = target.outerWidth(FALSE);\r\n\t\t\ttargetHeight = target.outerHeight(FALSE);\r\n\t\t\tposition = target.offset();\r\n\t\t}\r\n\r\n\t\t// Parse returned plugin values into proper variables\r\n\t\tif(pluginCalculations) {\r\n\t\t\ttargetWidth = pluginCalculations.width;\r\n\t\t\ttargetHeight = pluginCalculations.height;\r\n\t\t\toffset = pluginCalculations.offset;\r\n\t\t\tposition = pluginCalculations.position;\r\n\t\t}\r\n\r\n\t\t// Adjust position to take into account offset parents\r\n\t\tposition = this.reposition.offset(target, position, container);\r\n\r\n\t\t// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2-4.0 & v4.3-4.3.2)\r\n\t\tif(BROWSER.iOS > 3.1 && BROWSER.iOS < 4.1 ||\r\n\t\t\tBROWSER.iOS >= 4.3 && BROWSER.iOS < 4.33 ||\r\n\t\t\t!BROWSER.iOS && type === 'fixed'\r\n\t\t){\r\n\t\t\tposition.left -= win.scrollLeft();\r\n\t\t\tposition.top -= win.scrollTop();\r\n\t\t}\r\n\r\n\t\t// Adjust position relative to target\r\n\t\tif(!pluginCalculations || pluginCalculations && pluginCalculations.adjustable !== FALSE) {\r\n\t\t\tposition.left += at.x === RIGHT ? targetWidth : at.x === CENTER ? targetWidth / 2 : 0;\r\n\t\t\tposition.top += at.y === BOTTOM ? targetHeight : at.y === CENTER ? targetHeight / 2 : 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// Adjust position relative to tooltip\r\n\tposition.left += adjust.x + (my.x === RIGHT ? -tooltipWidth : my.x === CENTER ? -tooltipWidth / 2 : 0);\r\n\tposition.top += adjust.y + (my.y === BOTTOM ? -tooltipHeight : my.y === CENTER ? -tooltipHeight / 2 : 0);\r\n\r\n\t// Use viewport adjustment plugin if enabled\r\n\tif(PLUGINS.viewport) {\r\n\t\tadjusted = position.adjusted = PLUGINS.viewport(\r\n\t\t\tthis, position, posOptions, targetWidth, targetHeight, tooltipWidth, tooltipHeight\r\n\t\t);\r\n\r\n\t\t// Apply offsets supplied by positioning plugin (if used)\r\n\t\tif(offset && adjusted.left) { position.left += offset.left; }\r\n\t\tif(offset && adjusted.top) {  position.top += offset.top; }\r\n\r\n\t\t// Apply any new 'my' position\r\n\t\tif(adjusted.my) { this.position.my = adjusted.my; }\r\n\t}\r\n\r\n\t// Viewport adjustment is disabled, set values to zero\r\n\telse { position.adjusted = { left: 0, top: 0 }; }\r\n\r\n\t// Set tooltip position class if it's changed\r\n\tif(cache.posClass !== (newClass = this._createPosClass(this.position.my))) {\r\n\t\tcache.posClass = newClass;\r\n\t\ttooltip.removeClass(cache.posClass).addClass(newClass);\r\n\t}\r\n\r\n\t// tooltipmove event\r\n\tif(!this._trigger('move', [position, viewport.elem || viewport], event)) { return this; }\r\n\tdelete position.adjusted;\r\n\r\n\t// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly\r\n\tif(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {\r\n\t\ttooltip.css(position);\r\n\t}\r\n\r\n\t// Use custom function if provided\r\n\telse if($.isFunction(posOptions.effect)) {\r\n\t\tposOptions.effect.call(tooltip, this, $.extend({}, position));\r\n\t\ttooltip.queue(function(next) {\r\n\t\t\t// Reset attributes to avoid cross-browser rendering bugs\r\n\t\t\t$(this).css({ opacity: '', height: '' });\r\n\t\t\tif(BROWSER.ie) { this.style.removeAttribute('filter'); }\r\n\r\n\t\t\tnext();\r\n\t\t});\r\n\t}\r\n\r\n\t// Set positioning flag\r\n\tthis.positioning = FALSE;\r\n\r\n\treturn this;\r\n};\r\n\r\n// Custom (more correct for qTip!) offset calculator\r\nPROTOTYPE.reposition.offset = function(elem, pos, container) {\r\n\tif(!container[0]) { return pos; }\r\n\r\n\tvar ownerDocument = $(elem[0].ownerDocument),\r\n\t\tquirks = !!BROWSER.ie && document.compatMode !== 'CSS1Compat',\r\n\t\tparent = container[0],\r\n\t\tscrolled, position, parentOffset, overflow;\r\n\r\n\tfunction scroll(e, i) {\r\n\t\tpos.left += i * e.scrollLeft();\r\n\t\tpos.top += i * e.scrollTop();\r\n\t}\r\n\r\n\t// Compensate for non-static containers offset\r\n\tdo {\r\n\t\tif((position = $.css(parent, 'position')) !== 'static') {\r\n\t\t\tif(position === 'fixed') {\r\n\t\t\t\tparentOffset = parent.getBoundingClientRect();\r\n\t\t\t\tscroll(ownerDocument, -1);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tparentOffset = $(parent).position();\r\n\t\t\t\tparentOffset.left += parseFloat($.css(parent, 'borderLeftWidth')) || 0;\r\n\t\t\t\tparentOffset.top += parseFloat($.css(parent, 'borderTopWidth')) || 0;\r\n\t\t\t}\r\n\r\n\t\t\tpos.left -= parentOffset.left + (parseFloat($.css(parent, 'marginLeft')) || 0);\r\n\t\t\tpos.top -= parentOffset.top + (parseFloat($.css(parent, 'marginTop')) || 0);\r\n\r\n\t\t\t// If this is the first parent element with an overflow of \"scroll\" or \"auto\", store it\r\n\t\t\tif(!scrolled && (overflow = $.css(parent, 'overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = $(parent); }\r\n\t\t}\r\n\t}\r\n\twhile(parent = parent.offsetParent);\r\n\r\n\t// Compensate for containers scroll if it also has an offsetParent (or in IE quirks mode)\r\n\tif(scrolled && (scrolled[0] !== ownerDocument[0] || quirks)) {\r\n\t\tscroll(scrolled, 1);\r\n\t}\r\n\r\n\treturn pos;\r\n};\r\n\r\n// Corner class\r\nvar C = (CORNER = PROTOTYPE.reposition.Corner = function(corner, forceY) {\r\n\tcorner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, CENTER).toLowerCase();\r\n\tthis.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();\r\n\tthis.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();\r\n\tthis.forceY = !!forceY;\r\n\r\n\tvar f = corner.charAt(0);\r\n\tthis.precedance = f === 't' || f === 'b' ? Y : X;\r\n}).prototype;\r\n\r\nC.invert = function(z, center) {\r\n\tthis[z] = this[z] === LEFT ? RIGHT : this[z] === RIGHT ? LEFT : center || this[z];\r\n};\r\n\r\nC.string = function(join) {\r\n\tvar x = this.x, y = this.y;\r\n\r\n\tvar result = x !== y ?\r\n\t\tx === 'center' || y !== 'center' && (this.precedance === Y || this.forceY) ? \r\n\t\t\t[y,x] : \r\n\t\t\t[x,y] :\r\n\t\t[x];\r\n\r\n\treturn join !== false ? result.join(' ') : result;\r\n};\r\n\r\nC.abbrev = function() {\r\n\tvar result = this.string(false);\r\n\treturn result[0].charAt(0) + (result[1] && result[1].charAt(0) || '');\r\n};\r\n\r\nC.clone = function() {\r\n\treturn new CORNER( this.string(), this.forceY );\r\n};\r\n\r\n;\r\nPROTOTYPE.toggle = function(state, event) {\r\n\tvar cache = this.cache,\r\n\t\toptions = this.options,\r\n\t\ttooltip = this.tooltip;\r\n\r\n\t// Try to prevent flickering when tooltip overlaps show element\r\n\tif(event) {\r\n\t\tif((/over|enter/).test(event.type) && cache.event && (/out|leave/).test(cache.event.type) &&\r\n\t\t\toptions.show.target.add(event.target).length === options.show.target.length &&\r\n\t\t\ttooltip.has(event.relatedTarget).length) {\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// Cache event\r\n\t\tcache.event = $.event.fix(event);\r\n\t}\r\n\r\n\t// If we're currently waiting and we've just hidden... stop it\r\n\tthis.waiting && !state && (this.hiddenDuringWait = TRUE);\r\n\r\n\t// Render the tooltip if showing and it isn't already\r\n\tif(!this.rendered) { return state ? this.render(1) : this; }\r\n\telse if(this.destroyed || this.disabled) { return this; }\r\n\r\n\tvar type = state ? 'show' : 'hide',\r\n\t\topts = this.options[type],\r\n\t\tposOptions = this.options.position,\r\n\t\tcontentOptions = this.options.content,\r\n\t\twidth = this.tooltip.css('width'),\r\n\t\tvisible = this.tooltip.is(':visible'),\r\n\t\tanimate = state || opts.target.length === 1,\r\n\t\tsameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,\r\n\t\tidenticalState, allow, after;\r\n\r\n\t// Detect state if valid one isn't provided\r\n\tif((typeof state).search('boolean|number')) { state = !visible; }\r\n\r\n\t// Check if the tooltip is in an identical state to the new would-be state\r\n\tidenticalState = !tooltip.is(':animated') && visible === state && sameTarget;\r\n\r\n\t// Fire tooltip(show/hide) event and check if destroyed\r\n\tallow = !identicalState ? !!this._trigger(type, [90]) : NULL;\r\n\r\n\t// Check to make sure the tooltip wasn't destroyed in the callback\r\n\tif(this.destroyed) { return this; }\r\n\r\n\t// If the user didn't stop the method prematurely and we're showing the tooltip, focus it\r\n\tif(allow !== FALSE && state) { this.focus(event); }\r\n\r\n\t// If the state hasn't changed or the user stopped it, return early\r\n\tif(!allow || identicalState) { return this; }\r\n\r\n\t// Set ARIA hidden attribute\r\n\t$.attr(tooltip[0], 'aria-hidden', !!!state);\r\n\r\n\t// Execute state specific properties\r\n\tif(state) {\r\n\t\t// Store show origin coordinates\r\n\t\tthis.mouse && (cache.origin = $.event.fix(this.mouse));\r\n\r\n\t\t// Update tooltip content & title if it's a dynamic function\r\n\t\tif($.isFunction(contentOptions.text)) { this._updateContent(contentOptions.text, FALSE); }\r\n\t\tif($.isFunction(contentOptions.title)) { this._updateTitle(contentOptions.title, FALSE); }\r\n\r\n\t\t// Cache mousemove events for positioning purposes (if not already tracking)\r\n\t\tif(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {\r\n\t\t\t$(document).bind('mousemove.'+NAMESPACE, this._storeMouse);\r\n\t\t\ttrackingBound = TRUE;\r\n\t\t}\r\n\r\n\t\t// Update the tooltip position (set width first to prevent viewport/max-width issues)\r\n\t\tif(!width) { tooltip.css('width', tooltip.outerWidth(FALSE)); }\r\n\t\tthis.reposition(event, arguments[2]);\r\n\t\tif(!width) { tooltip.css('width', ''); }\r\n\r\n\t\t// Hide other tooltips if tooltip is solo\r\n\t\tif(!!opts.solo) {\r\n\t\t\t(typeof opts.solo === 'string' ? $(opts.solo) : $(SELECTOR, opts.solo))\r\n\t\t\t\t.not(tooltip).not(opts.target).qtip('hide', new $.Event('tooltipsolo'));\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\t// Clear show timer if we're hiding\r\n\t\tclearTimeout(this.timers.show);\r\n\r\n\t\t// Remove cached origin on hide\r\n\t\tdelete cache.origin;\r\n\r\n\t\t// Remove mouse tracking event if not needed (all tracking qTips are hidden)\r\n\t\tif(trackingBound && !$(SELECTOR+'[tracking=\"true\"]:visible', opts.solo).not(tooltip).length) {\r\n\t\t\t$(document).unbind('mousemove.'+NAMESPACE);\r\n\t\t\ttrackingBound = FALSE;\r\n\t\t}\r\n\r\n\t\t// Blur the tooltip\r\n\t\tthis.blur(event);\r\n\t}\r\n\r\n\t// Define post-animation, state specific properties\r\n\tafter = $.proxy(function() {\r\n\t\tif(state) {\r\n\t\t\t// Prevent antialias from disappearing in IE by removing filter\r\n\t\t\tif(BROWSER.ie) { tooltip[0].style.removeAttribute('filter'); }\r\n\r\n\t\t\t// Remove overflow setting to prevent tip bugs\r\n\t\t\ttooltip.css('overflow', '');\r\n\r\n\t\t\t// Autofocus elements if enabled\r\n\t\t\tif('string' === typeof opts.autofocus) {\r\n\t\t\t\t$(this.options.show.autofocus, tooltip).focus();\r\n\t\t\t}\r\n\r\n\t\t\t// If set, hide tooltip when inactive for delay period\r\n\t\t\tthis.options.show.target.trigger('qtip-'+this.id+'-inactive');\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Reset CSS states\r\n\t\t\ttooltip.css({\r\n\t\t\t\tdisplay: '',\r\n\t\t\t\tvisibility: '',\r\n\t\t\t\topacity: '',\r\n\t\t\t\tleft: '',\r\n\t\t\t\ttop: ''\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// tooltipvisible/tooltiphidden events\r\n\t\tthis._trigger(state ? 'visible' : 'hidden');\r\n\t}, this);\r\n\r\n\t// If no effect type is supplied, use a simple toggle\r\n\tif(opts.effect === FALSE || animate === FALSE) {\r\n\t\ttooltip[ type ]();\r\n\t\tafter();\r\n\t}\r\n\r\n\t// Use custom function if provided\r\n\telse if($.isFunction(opts.effect)) {\r\n\t\ttooltip.stop(1, 1);\r\n\t\topts.effect.call(tooltip, this);\r\n\t\ttooltip.queue('fx', function(n) {\r\n\t\t\tafter(); n();\r\n\t\t});\r\n\t}\r\n\r\n\t// Use basic fade function by default\r\n\telse { tooltip.fadeTo(90, state ? 1 : 0, after); }\r\n\r\n\t// If inactive hide method is set, active it\r\n\tif(state) { opts.target.trigger('qtip-'+this.id+'-inactive'); }\r\n\r\n\treturn this;\r\n};\r\n\r\nPROTOTYPE.show = function(event) { return this.toggle(TRUE, event); };\r\n\r\nPROTOTYPE.hide = function(event) { return this.toggle(FALSE, event); };\r\n;PROTOTYPE.focus = function(event) {\r\n\tif(!this.rendered || this.destroyed) { return this; }\r\n\r\n\tvar qtips = $(SELECTOR),\r\n\t\ttooltip = this.tooltip,\r\n\t\tcurIndex = parseInt(tooltip[0].style.zIndex, 10),\r\n\t\tnewIndex = QTIP.zindex + qtips.length;\r\n\r\n\t// Only update the z-index if it has changed and tooltip is not already focused\r\n\tif(!tooltip.hasClass(CLASS_FOCUS)) {\r\n\t\t// tooltipfocus event\r\n\t\tif(this._trigger('focus', [newIndex], event)) {\r\n\t\t\t// Only update z-index's if they've changed\r\n\t\t\tif(curIndex !== newIndex) {\r\n\t\t\t\t// Reduce our z-index's and keep them properly ordered\r\n\t\t\t\tqtips.each(function() {\r\n\t\t\t\t\tif(this.style.zIndex > curIndex) {\r\n\t\t\t\t\t\tthis.style.zIndex = this.style.zIndex - 1;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Fire blur event for focused tooltip\r\n\t\t\t\tqtips.filter('.' + CLASS_FOCUS).qtip('blur', event);\r\n\t\t\t}\r\n\r\n\t\t\t// Set the new z-index\r\n\t\t\ttooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\r\n\t\t}\r\n\t}\r\n\r\n\treturn this;\r\n};\r\n\r\nPROTOTYPE.blur = function(event) {\r\n\tif(!this.rendered || this.destroyed) { return this; }\r\n\r\n\t// Set focused status to FALSE\r\n\tthis.tooltip.removeClass(CLASS_FOCUS);\r\n\r\n\t// tooltipblur event\r\n\tthis._trigger('blur', [ this.tooltip.css('zIndex') ], event);\r\n\r\n\treturn this;\r\n};\r\n;PROTOTYPE.disable = function(state) {\r\n\tif(this.destroyed) { return this; }\r\n\r\n\t// If 'toggle' is passed, toggle the current state\r\n\tif(state === 'toggle') {\r\n\t\tstate = !(this.rendered ? this.tooltip.hasClass(CLASS_DISABLED) : this.disabled);\r\n\t}\r\n\r\n\t// Disable if no state passed\r\n\telse if('boolean' !== typeof state) {\r\n\t\tstate = TRUE;\r\n\t}\r\n\r\n\tif(this.rendered) {\r\n\t\tthis.tooltip.toggleClass(CLASS_DISABLED, state)\r\n\t\t\t.attr('aria-disabled', state);\r\n\t}\r\n\r\n\tthis.disabled = !!state;\r\n\r\n\treturn this;\r\n};\r\n\r\nPROTOTYPE.enable = function() { return this.disable(FALSE); };\r\n;PROTOTYPE._createButton = function()\r\n{\r\n\tvar self = this,\r\n\t\telements = this.elements,\r\n\t\ttooltip = elements.tooltip,\r\n\t\tbutton = this.options.content.button,\r\n\t\tisString = typeof button === 'string',\r\n\t\tclose = isString ? button : 'Close tooltip';\r\n\r\n\tif(elements.button) { elements.button.remove(); }\r\n\r\n\t// Use custom button if one was supplied by user, else use default\r\n\tif(button.jquery) {\r\n\t\telements.button = button;\r\n\t}\r\n\telse {\r\n\t\telements.button = $('<a />', {\r\n\t\t\t'class': 'qtip-close ' + (this.options.style.widget ? '' : NAMESPACE+'-icon'),\r\n\t\t\t'title': close,\r\n\t\t\t'aria-label': close\r\n\t\t})\r\n\t\t.prepend(\r\n\t\t\t$('<span />', {\r\n\t\t\t\t'class': 'ui-icon ui-icon-close',\r\n\t\t\t\t'html': '&times;'\r\n\t\t\t})\r\n\t\t);\r\n\t}\r\n\r\n\t// Create button and setup attributes\r\n\telements.button.appendTo(elements.titlebar || tooltip)\r\n\t\t.attr('role', 'button')\r\n\t\t.click(function(event) {\r\n\t\t\tif(!tooltip.hasClass(CLASS_DISABLED)) { self.hide(event); }\r\n\t\t\treturn FALSE;\r\n\t\t});\r\n};\r\n\r\nPROTOTYPE._updateButton = function(button)\r\n{\r\n\t// Make sure tooltip is rendered and if not, return\r\n\tif(!this.rendered) { return FALSE; }\r\n\r\n\tvar elem = this.elements.button;\r\n\tif(button) { this._createButton(); }\r\n\telse { elem.remove(); }\r\n};\r\n;// Widget class creator\r\nfunction createWidgetClass(cls) {\r\n\treturn WIDGET.concat('').join(cls ? '-'+cls+' ' : ' ');\r\n}\r\n\r\n// Widget class setter method\r\nPROTOTYPE._setWidget = function()\r\n{\r\n\tvar on = this.options.style.widget,\r\n\t\telements = this.elements,\r\n\t\ttooltip = elements.tooltip,\r\n\t\tdisabled = tooltip.hasClass(CLASS_DISABLED);\r\n\r\n\ttooltip.removeClass(CLASS_DISABLED);\r\n\tCLASS_DISABLED = on ? 'ui-state-disabled' : 'qtip-disabled';\r\n\ttooltip.toggleClass(CLASS_DISABLED, disabled);\r\n\r\n\ttooltip.toggleClass('ui-helper-reset '+createWidgetClass(), on).toggleClass(CLASS_DEFAULT, this.options.style.def && !on);\r\n\r\n\tif(elements.content) {\r\n\t\telements.content.toggleClass( createWidgetClass('content'), on);\r\n\t}\r\n\tif(elements.titlebar) {\r\n\t\telements.titlebar.toggleClass( createWidgetClass('header'), on);\r\n\t}\r\n\tif(elements.button) {\r\n\t\telements.button.toggleClass(NAMESPACE+'-icon', !on);\r\n\t}\r\n};\r\n;function delay(callback, duration) {\r\n\t// If tooltip has displayed, start hide timer\r\n\tif(duration > 0) {\r\n\t\treturn setTimeout(\r\n\t\t\t$.proxy(callback, this), duration\r\n\t\t);\r\n\t}\r\n\telse{ callback.call(this); }\r\n}\r\n\r\nfunction showMethod(event) {\r\n\tif(this.tooltip.hasClass(CLASS_DISABLED)) { return; }\r\n\r\n\t// Clear hide timers\r\n\tclearTimeout(this.timers.show);\r\n\tclearTimeout(this.timers.hide);\r\n\r\n\t// Start show timer\r\n\tthis.timers.show = delay.call(this,\r\n\t\tfunction() { this.toggle(TRUE, event); },\r\n\t\tthis.options.show.delay\r\n\t);\r\n}\r\n\r\nfunction hideMethod(event) {\r\n\tif(this.tooltip.hasClass(CLASS_DISABLED) || this.destroyed) { return; }\r\n\r\n\t// Check if new target was actually the tooltip element\r\n\tvar relatedTarget = $(event.relatedTarget),\r\n\t\tontoTooltip = relatedTarget.closest(SELECTOR)[0] === this.tooltip[0],\r\n\t\tontoTarget = relatedTarget[0] === this.options.show.target[0];\r\n\r\n\t// Clear timers and stop animation queue\r\n\tclearTimeout(this.timers.show);\r\n\tclearTimeout(this.timers.hide);\r\n\r\n\t// Prevent hiding if tooltip is fixed and event target is the tooltip.\r\n\t// Or if mouse positioning is enabled and cursor momentarily overlaps\r\n\tif(this !== relatedTarget[0] &&\r\n\t\t(this.options.position.target === 'mouse' && ontoTooltip) ||\r\n\t\tthis.options.hide.fixed && (\r\n\t\t\t(/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget))\r\n\t\t)\r\n\t{\r\n\t\t/* eslint-disable no-empty */\r\n\t\ttry {\r\n\t\t\tevent.preventDefault();\r\n\t\t\tevent.stopImmediatePropagation();\r\n\t\t} catch(e) {}\r\n\t\t/* eslint-enable no-empty */\r\n\r\n\t\treturn;\r\n\t}\r\n\r\n\t// If tooltip has displayed, start hide timer\r\n\tthis.timers.hide = delay.call(this,\r\n\t\tfunction() { this.toggle(FALSE, event); },\r\n\t\tthis.options.hide.delay,\r\n\t\tthis\r\n\t);\r\n}\r\n\r\nfunction inactiveMethod(event) {\r\n\tif(this.tooltip.hasClass(CLASS_DISABLED) || !this.options.hide.inactive) { return; }\r\n\r\n\t// Clear timer\r\n\tclearTimeout(this.timers.inactive);\r\n\r\n\tthis.timers.inactive = delay.call(this,\r\n\t\tfunction(){ this.hide(event); },\r\n\t\tthis.options.hide.inactive\r\n\t);\r\n}\r\n\r\nfunction repositionMethod(event) {\r\n\tif(this.rendered && this.tooltip[0].offsetWidth > 0) { this.reposition(event); }\r\n}\r\n\r\n// Store mouse coordinates\r\nPROTOTYPE._storeMouse = function(event) {\r\n\t(this.mouse = $.event.fix(event)).type = 'mousemove';\r\n\treturn this;\r\n};\r\n\r\n// Bind events\r\nPROTOTYPE._bind = function(targets, events, method, suffix, context) {\r\n\tif(!targets || !method || !events.length) { return; }\r\n\tvar ns = '.' + this._id + (suffix ? '-'+suffix : '');\r\n\t$(targets).bind(\r\n\t\t(events.split ? events : events.join(ns + ' ')) + ns,\r\n\t\t$.proxy(method, context || this)\r\n\t);\r\n\treturn this;\r\n};\r\nPROTOTYPE._unbind = function(targets, suffix) {\r\n\ttargets && $(targets).unbind('.' + this._id + (suffix ? '-'+suffix : ''));\r\n\treturn this;\r\n};\r\n\r\n// Global delegation helper\r\nfunction delegate(selector, events, method) {\r\n\t$(document.body).delegate(selector,\r\n\t\t(events.split ? events : events.join('.'+NAMESPACE + ' ')) + '.'+NAMESPACE,\r\n\t\tfunction() {\r\n\t\t\tvar api = QTIP.api[ $.attr(this, ATTR_ID) ];\r\n\t\t\tapi && !api.disabled && method.apply(api, arguments);\r\n\t\t}\r\n\t);\r\n}\r\n// Event trigger\r\nPROTOTYPE._trigger = function(type, args, event) {\r\n\tvar callback = new $.Event('tooltip'+type);\r\n\tcallback.originalEvent = event && $.extend({}, event) || this.cache.event || NULL;\r\n\r\n\tthis.triggering = type;\r\n\tthis.tooltip.trigger(callback, [this].concat(args || []));\r\n\tthis.triggering = FALSE;\r\n\r\n\treturn !callback.isDefaultPrevented();\r\n};\r\n\r\nPROTOTYPE._bindEvents = function(showEvents, hideEvents, showTargets, hideTargets, showCallback, hideCallback) {\r\n\t// Get tasrgets that lye within both\r\n\tvar similarTargets = showTargets.filter( hideTargets ).add( hideTargets.filter(showTargets) ),\r\n\t\ttoggleEvents = [];\r\n\r\n\t// If hide and show targets are the same...\r\n\tif(similarTargets.length) {\r\n\r\n\t\t// Filter identical show/hide events\r\n\t\t$.each(hideEvents, function(i, type) {\r\n\t\t\tvar showIndex = $.inArray(type, showEvents);\r\n\r\n\t\t\t// Both events are identical, remove from both hide and show events\r\n\t\t\t// and append to toggleEvents\r\n\t\t\tshowIndex > -1 && toggleEvents.push( showEvents.splice( showIndex, 1 )[0] );\r\n\t\t});\r\n\r\n\t\t// Toggle events are special case of identical show/hide events, which happen in sequence\r\n\t\tif(toggleEvents.length) {\r\n\t\t\t// Bind toggle events to the similar targets\r\n\t\t\tthis._bind(similarTargets, toggleEvents, function(event) {\r\n\t\t\t\tvar state = this.rendered ? this.tooltip[0].offsetWidth > 0 : false;\r\n\t\t\t\t(state ? hideCallback : showCallback).call(this, event);\r\n\t\t\t});\r\n\r\n\t\t\t// Remove the similar targets from the regular show/hide bindings\r\n\t\t\tshowTargets = showTargets.not(similarTargets);\r\n\t\t\thideTargets = hideTargets.not(similarTargets);\r\n\t\t}\r\n\t}\r\n\r\n\t// Apply show/hide/toggle events\r\n\tthis._bind(showTargets, showEvents, showCallback);\r\n\tthis._bind(hideTargets, hideEvents, hideCallback);\r\n};\r\n\r\nPROTOTYPE._assignInitialEvents = function(event) {\r\n\tvar options = this.options,\r\n\t\tshowTarget = options.show.target,\r\n\t\thideTarget = options.hide.target,\r\n\t\tshowEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\r\n\t\thideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];\r\n\r\n\t// Catch remove/removeqtip events on target element to destroy redundant tooltips\r\n\tthis._bind(this.elements.target, ['remove', 'removeqtip'], function() {\r\n\t\tthis.destroy(true);\r\n\t}, 'destroy');\r\n\r\n\t/*\r\n\t * Make sure hoverIntent functions properly by using mouseleave as a hide event if\r\n\t * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\r\n\t */\r\n\tif(/mouse(over|enter)/i.test(options.show.event) && !/mouse(out|leave)/i.test(options.hide.event)) {\r\n\t\thideEvents.push('mouseleave');\r\n\t}\r\n\r\n\t/*\r\n\t * Also make sure initial mouse targetting works correctly by caching mousemove coords\r\n\t * on show targets before the tooltip has rendered. Also set onTarget when triggered to\r\n\t * keep mouse tracking working.\r\n\t */\r\n\tthis._bind(showTarget, 'mousemove', function(moveEvent) {\r\n\t\tthis._storeMouse(moveEvent);\r\n\t\tthis.cache.onTarget = TRUE;\r\n\t});\r\n\r\n\t// Define hoverIntent function\r\n\tfunction hoverIntent(hoverEvent) {\r\n\t\t// Only continue if tooltip isn't disabled\r\n\t\tif(this.disabled || this.destroyed) { return FALSE; }\r\n\r\n\t\t// Cache the event data\r\n\t\tthis.cache.event = hoverEvent && $.event.fix(hoverEvent);\r\n\t\tthis.cache.target = hoverEvent && $(hoverEvent.target);\r\n\r\n\t\t// Start the event sequence\r\n\t\tclearTimeout(this.timers.show);\r\n\t\tthis.timers.show = delay.call(this,\r\n\t\t\tfunction() { this.render(typeof hoverEvent === 'object' || options.show.ready); },\r\n\t\t\toptions.prerender ? 0 : options.show.delay\r\n\t\t);\r\n\t}\r\n\r\n\t// Filter and bind events\r\n\tthis._bindEvents(showEvents, hideEvents, showTarget, hideTarget, hoverIntent, function() {\r\n\t\tif(!this.timers) { return FALSE; }\r\n\t\tclearTimeout(this.timers.show);\r\n\t});\r\n\r\n\t// Prerendering is enabled, create tooltip now\r\n\tif(options.show.ready || options.prerender) { hoverIntent.call(this, event); }\r\n};\r\n\r\n// Event assignment method\r\nPROTOTYPE._assignEvents = function() {\r\n\tvar self = this,\r\n\t\toptions = this.options,\r\n\t\tposOptions = options.position,\r\n\r\n\t\ttooltip = this.tooltip,\r\n\t\tshowTarget = options.show.target,\r\n\t\thideTarget = options.hide.target,\r\n\t\tcontainerTarget = posOptions.container,\r\n\t\tviewportTarget = posOptions.viewport,\r\n\t\tdocumentTarget = $(document),\r\n\t\twindowTarget = $(window),\r\n\r\n\t\tshowEvents = options.show.event ? $.trim('' + options.show.event).split(' ') : [],\r\n\t\thideEvents = options.hide.event ? $.trim('' + options.hide.event).split(' ') : [];\r\n\r\n\r\n\t// Assign passed event callbacks\r\n\t$.each(options.events, function(name, callback) {\r\n\t\tself._bind(tooltip, name === 'toggle' ? ['tooltipshow','tooltiphide'] : ['tooltip'+name], callback, null, tooltip);\r\n\t});\r\n\r\n\t// Hide tooltips when leaving current window/frame (but not select/option elements)\r\n\tif(/mouse(out|leave)/i.test(options.hide.event) && options.hide.leave === 'window') {\r\n\t\tthis._bind(documentTarget, ['mouseout', 'blur'], function(event) {\r\n\t\t\tif(!/select|option/.test(event.target.nodeName) && !event.relatedTarget) {\r\n\t\t\t\tthis.hide(event);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Enable hide.fixed by adding appropriate class\r\n\tif(options.hide.fixed) {\r\n\t\thideTarget = hideTarget.add( tooltip.addClass(CLASS_FIXED) );\r\n\t}\r\n\r\n\t/*\r\n\t * Make sure hoverIntent functions properly by using mouseleave to clear show timer if\r\n\t * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\r\n\t */\r\n\telse if(/mouse(over|enter)/i.test(options.show.event)) {\r\n\t\tthis._bind(hideTarget, 'mouseleave', function() {\r\n\t\t\tclearTimeout(this.timers.show);\r\n\t\t});\r\n\t}\r\n\r\n\t// Hide tooltip on document mousedown if unfocus events are enabled\r\n\tif(('' + options.hide.event).indexOf('unfocus') > -1) {\r\n\t\tthis._bind(containerTarget.closest('html'), ['mousedown', 'touchstart'], function(event) {\r\n\t\t\tvar elem = $(event.target),\r\n\t\t\t\tenabled = this.rendered && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0,\r\n\t\t\t\tisAncestor = elem.parents(SELECTOR).filter(this.tooltip[0]).length > 0;\r\n\r\n\t\t\tif(elem[0] !== this.target[0] && elem[0] !== this.tooltip[0] && !isAncestor &&\r\n\t\t\t\t!this.target.has(elem[0]).length && enabled\r\n\t\t\t) {\r\n\t\t\t\tthis.hide(event);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Check if the tooltip hides when inactive\r\n\tif('number' === typeof options.hide.inactive) {\r\n\t\t// Bind inactive method to show target(s) as a custom event\r\n\t\tthis._bind(showTarget, 'qtip-'+this.id+'-inactive', inactiveMethod, 'inactive');\r\n\r\n\t\t// Define events which reset the 'inactive' event handler\r\n\t\tthis._bind(hideTarget.add(tooltip), QTIP.inactiveEvents, inactiveMethod);\r\n\t}\r\n\r\n\t// Filter and bind events\r\n\tthis._bindEvents(showEvents, hideEvents, showTarget, hideTarget, showMethod, hideMethod);\r\n\r\n\t// Mouse movement bindings\r\n\tthis._bind(showTarget.add(tooltip), 'mousemove', function(event) {\r\n\t\t// Check if the tooltip hides when mouse is moved a certain distance\r\n\t\tif('number' === typeof options.hide.distance) {\r\n\t\t\tvar origin = this.cache.origin || {},\r\n\t\t\t\tlimit = this.options.hide.distance,\r\n\t\t\t\tabs = Math.abs;\r\n\r\n\t\t\t// Check if the movement has gone beyond the limit, and hide it if so\r\n\t\t\tif(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {\r\n\t\t\t\tthis.hide(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Cache mousemove coords on show targets\r\n\t\tthis._storeMouse(event);\r\n\t});\r\n\r\n\t// Mouse positioning events\r\n\tif(posOptions.target === 'mouse') {\r\n\t\t// If mouse adjustment is on...\r\n\t\tif(posOptions.adjust.mouse) {\r\n\t\t\t// Apply a mouseleave event so we don't get problems with overlapping\r\n\t\t\tif(options.hide.event) {\r\n\t\t\t\t// Track if we're on the target or not\r\n\t\t\t\tthis._bind(showTarget, ['mouseenter', 'mouseleave'], function(event) {\r\n\t\t\t\t\tif(!this.cache) {return FALSE; }\r\n\t\t\t\t\tthis.cache.onTarget = event.type === 'mouseenter';\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Update tooltip position on mousemove\r\n\t\t\tthis._bind(documentTarget, 'mousemove', function(event) {\r\n\t\t\t\t// Update the tooltip position only if the tooltip is visible and adjustment is enabled\r\n\t\t\t\tif(this.rendered && this.cache.onTarget && !this.tooltip.hasClass(CLASS_DISABLED) && this.tooltip[0].offsetWidth > 0) {\r\n\t\t\t\t\tthis.reposition(event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// Adjust positions of the tooltip on window resize if enabled\r\n\tif(posOptions.adjust.resize || viewportTarget.length) {\r\n\t\tthis._bind( $.event.special.resize ? viewportTarget : windowTarget, 'resize', repositionMethod );\r\n\t}\r\n\r\n\t// Adjust tooltip position on scroll of the window or viewport element if present\r\n\tif(posOptions.adjust.scroll) {\r\n\t\tthis._bind( windowTarget.add(posOptions.container), 'scroll', repositionMethod );\r\n\t}\r\n};\r\n\r\n// Un-assignment method\r\nPROTOTYPE._unassignEvents = function() {\r\n\tvar options = this.options,\r\n\t\tshowTargets = options.show.target,\r\n\t\thideTargets = options.hide.target,\r\n\t\ttargets = $.grep([\r\n\t\t\tthis.elements.target[0],\r\n\t\t\tthis.rendered && this.tooltip[0],\r\n\t\t\toptions.position.container[0],\r\n\t\t\toptions.position.viewport[0],\r\n\t\t\toptions.position.container.closest('html')[0], // unfocus\r\n\t\t\twindow,\r\n\t\t\tdocument\r\n\t\t], function(i) {\r\n\t\t\treturn typeof i === 'object';\r\n\t\t});\r\n\r\n\t// Add show and hide targets if they're valid\r\n\tif(showTargets && showTargets.toArray) {\r\n\t\ttargets = targets.concat(showTargets.toArray());\r\n\t}\r\n\tif(hideTargets && hideTargets.toArray) {\r\n\t\ttargets = targets.concat(hideTargets.toArray());\r\n\t}\r\n\r\n\t// Unbind the events\r\n\tthis._unbind(targets)\r\n\t\t._unbind(targets, 'destroy')\r\n\t\t._unbind(targets, 'inactive');\r\n};\r\n\r\n// Apply common event handlers using delegate (avoids excessive .bind calls!)\r\n$(function() {\r\n\tdelegate(SELECTOR, ['mouseenter', 'mouseleave'], function(event) {\r\n\t\tvar state = event.type === 'mouseenter',\r\n\t\t\ttooltip = $(event.currentTarget),\r\n\t\t\ttarget = $(event.relatedTarget || event.target),\r\n\t\t\toptions = this.options;\r\n\r\n\t\t// On mouseenter...\r\n\t\tif(state) {\r\n\t\t\t// Focus the tooltip on mouseenter (z-index stacking)\r\n\t\t\tthis.focus(event);\r\n\r\n\t\t\t// Clear hide timer on tooltip hover to prevent it from closing\r\n\t\t\ttooltip.hasClass(CLASS_FIXED) && !tooltip.hasClass(CLASS_DISABLED) && clearTimeout(this.timers.hide);\r\n\t\t}\r\n\r\n\t\t// On mouseleave...\r\n\t\telse {\r\n\t\t\t// When mouse tracking is enabled, hide when we leave the tooltip and not onto the show target (if a hide event is set)\r\n\t\t\tif(options.position.target === 'mouse' && options.position.adjust.mouse &&\r\n\t\t\t\toptions.hide.event && options.show.target && !target.closest(options.show.target[0]).length) {\r\n\t\t\t\tthis.hide(event);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add hover class\r\n\t\ttooltip.toggleClass(CLASS_HOVER, state);\r\n\t});\r\n\r\n\t// Define events which reset the 'inactive' event handler\r\n\tdelegate('['+ATTR_ID+']', INACTIVE_EVENTS, inactiveMethod);\r\n});\r\n;// Initialization method\r\nfunction init(elem, id, opts) {\r\n\tvar obj, posOptions, attr, config, title,\r\n\r\n\t// Setup element references\r\n\tdocBody = $(document.body),\r\n\r\n\t// Use document body instead of document element if needed\r\n\tnewTarget = elem[0] === document ? docBody : elem,\r\n\r\n\t// Grab metadata from element if plugin is present\r\n\tmetadata = elem.metadata ? elem.metadata(opts.metadata) : NULL,\r\n\r\n\t// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise\r\n\tmetadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,\r\n\r\n\t// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,\r\n\thtml5 = elem.data(opts.metadata.name || 'qtipopts');\r\n\r\n\t// If we don't get an object returned attempt to parse it manualyl without parseJSON\r\n\t/* eslint-disable no-empty */\r\n\ttry { html5 = typeof html5 === 'string' ? $.parseJSON(html5) : html5; }\r\n\tcatch(e) {}\r\n\t/* eslint-enable no-empty */\r\n\r\n\t// Merge in and sanitize metadata\r\n\tconfig = $.extend(TRUE, {}, QTIP.defaults, opts,\r\n\t\ttypeof html5 === 'object' ? sanitizeOptions(html5) : NULL,\r\n\t\tsanitizeOptions(metadata5 || metadata));\r\n\r\n\t// Re-grab our positioning options now we've merged our metadata and set id to passed value\r\n\tposOptions = config.position;\r\n\tconfig.id = id;\r\n\r\n\t// Setup missing content if none is detected\r\n\tif('boolean' === typeof config.content.text) {\r\n\t\tattr = elem.attr(config.content.attr);\r\n\r\n\t\t// Grab from supplied attribute if available\r\n\t\tif(config.content.attr !== FALSE && attr) { config.content.text = attr; }\r\n\r\n\t\t// No valid content was found, abort render\r\n\t\telse { return FALSE; }\r\n\t}\r\n\r\n\t// Setup target options\r\n\tif(!posOptions.container.length) { posOptions.container = docBody; }\r\n\tif(posOptions.target === FALSE) { posOptions.target = newTarget; }\r\n\tif(config.show.target === FALSE) { config.show.target = newTarget; }\r\n\tif(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }\r\n\tif(config.hide.target === FALSE) { config.hide.target = newTarget; }\r\n\tif(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }\r\n\r\n\t// Ensure we only use a single container\r\n\tposOptions.container = posOptions.container.eq(0);\r\n\r\n\t// Convert position corner values into x and y strings\r\n\tposOptions.at = new CORNER(posOptions.at, TRUE);\r\n\tposOptions.my = new CORNER(posOptions.my);\r\n\r\n\t// Destroy previous tooltip if overwrite is enabled, or skip element if not\r\n\tif(elem.data(NAMESPACE)) {\r\n\t\tif(config.overwrite) {\r\n\t\t\telem.qtip('destroy', true);\r\n\t\t}\r\n\t\telse if(config.overwrite === FALSE) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t// Add has-qtip attribute\r\n\telem.attr(ATTR_HAS, id);\r\n\r\n\t// Remove title attribute and store it if present\r\n\tif(config.suppress && (title = elem.attr('title'))) {\r\n\t\t// Final attr call fixes event delegatiom and IE default tooltip showing problem\r\n\t\telem.removeAttr('title').attr(oldtitle, title).attr('title', '');\r\n\t}\r\n\r\n\t// Initialize the tooltip and add API reference\r\n\tobj = new QTip(elem, config, id, !!attr);\r\n\telem.data(NAMESPACE, obj);\r\n\r\n\treturn obj;\r\n}\r\n\r\n// jQuery $.fn extension method\r\nQTIP = $.fn.qtip = function(options, notation, newValue)\r\n{\r\n\tvar command = ('' + options).toLowerCase(), // Parse command\r\n\t\treturned = NULL,\r\n\t\targs = $.makeArray(arguments).slice(1),\r\n\t\tevent = args[args.length - 1],\r\n\t\topts = this[0] ? $.data(this[0], NAMESPACE) : NULL;\r\n\r\n\t// Check for API request\r\n\tif(!arguments.length && opts || command === 'api') {\r\n\t\treturn opts;\r\n\t}\r\n\r\n\t// Execute API command if present\r\n\telse if('string' === typeof options) {\r\n\t\tthis.each(function() {\r\n\t\t\tvar api = $.data(this, NAMESPACE);\r\n\t\t\tif(!api) { return TRUE; }\r\n\r\n\t\t\t// Cache the event if possible\r\n\t\t\tif(event && event.timeStamp) { api.cache.event = event; }\r\n\r\n\t\t\t// Check for specific API commands\r\n\t\t\tif(notation && (command === 'option' || command === 'options')) {\r\n\t\t\t\tif(newValue !== undefined || $.isPlainObject(notation)) {\r\n\t\t\t\t\tapi.set(notation, newValue);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturned = api.get(notation);\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Execute API command\r\n\t\t\telse if(api[command]) {\r\n\t\t\t\tapi[command].apply(api, args);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn returned !== NULL ? returned : this;\r\n\t}\r\n\r\n\t// No API commands. validate provided options and setup qTips\r\n\telse if('object' === typeof options || !arguments.length) {\r\n\t\t// Sanitize options first\r\n\t\topts = sanitizeOptions($.extend(TRUE, {}, options));\r\n\r\n\t\treturn this.each(function(i) {\r\n\t\t\tvar api, id;\r\n\r\n\t\t\t// Find next available ID, or use custom ID if provided\r\n\t\t\tid = $.isArray(opts.id) ? opts.id[i] : opts.id;\r\n\t\t\tid = !id || id === FALSE || id.length < 1 || QTIP.api[id] ? QTIP.nextid++ : id;\r\n\r\n\t\t\t// Initialize the qTip and re-grab newly sanitized options\r\n\t\t\tapi = init($(this), id, opts);\r\n\t\t\tif(api === FALSE) { return TRUE; }\r\n\t\t\telse { QTIP.api[id] = api; }\r\n\r\n\t\t\t// Initialize plugins\r\n\t\t\t$.each(PLUGINS, function() {\r\n\t\t\t\tif(this.initialize === 'initialize') { this(api); }\r\n\t\t\t});\r\n\r\n\t\t\t// Assign initial pre-render events\r\n\t\t\tapi._assignInitialEvents(event);\r\n\t\t});\r\n\t}\r\n};\r\n\r\n// Expose class\r\n$.qtip = QTip;\r\n\r\n// Populated in render method\r\nQTIP.api = {};\r\n;$.each({\r\n\t/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */\r\n\tattr: function(attr, val) {\r\n\t\tif(this.length) {\r\n\t\t\tvar self = this[0],\r\n\t\t\t\ttitle = 'title',\r\n\t\t\t\tapi = $.data(self, 'qtip');\r\n\r\n\t\t\tif(attr === title && api && api.options && 'object' === typeof api && 'object' === typeof api.options && api.options.suppress) {\r\n\t\t\t\tif(arguments.length < 2) {\r\n\t\t\t\t\treturn $.attr(self, oldtitle);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If qTip is rendered and title was originally used as content, update it\r\n\t\t\t\tif(api && api.options.content.attr === title && api.cache.attr) {\r\n\t\t\t\t\tapi.set('content.text', val);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Use the regular attr method to set, then cache the result\r\n\t\t\t\treturn this.attr(oldtitle, val);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn $.fn['attr'+replaceSuffix].apply(this, arguments);\r\n\t},\r\n\r\n\t/* Allow clone to correctly retrieve cached title attributes */\r\n\tclone: function(keepData) {\r\n\t\t// Clone our element using the real clone method\r\n\t\tvar elems = $.fn['clone'+replaceSuffix].apply(this, arguments);\r\n\r\n\t\t// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false\r\n\t\tif(!keepData) {\r\n\t\t\telems.filter('['+oldtitle+']').attr('title', function() {\r\n\t\t\t\treturn $.attr(this, oldtitle);\r\n\t\t\t})\r\n\t\t\t.removeAttr(oldtitle);\r\n\t\t}\r\n\r\n\t\treturn elems;\r\n\t}\r\n}, function(name, func) {\r\n\tif(!func || $.fn[name+replaceSuffix]) { return TRUE; }\r\n\r\n\tvar old = $.fn[name+replaceSuffix] = $.fn[name];\r\n\t$.fn[name] = function() {\r\n\t\treturn func.apply(this, arguments) || old.apply(this, arguments);\r\n\t};\r\n});\r\n\r\n/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).\r\n * This snippet is taken directly from jQuery UI source code found here:\r\n *     http://code.jquery.com/ui/jquery-ui-git.js\r\n */\r\nif(!$.ui) {\r\n\t$['cleanData'+replaceSuffix] = $.cleanData;\r\n\t$.cleanData = function( elems ) {\r\n\t\tfor(var i = 0, elem; (elem = $( elems[i] )).length; i++) {\r\n\t\t\tif(elem.attr(ATTR_HAS)) {\r\n\t\t\t\t/* eslint-disable no-empty */\r\n\t\t\t\ttry { elem.triggerHandler('removeqtip'); }\r\n\t\t\t\tcatch( e ) {}\r\n\t\t\t\t/* eslint-enable no-empty */\r\n\t\t\t}\r\n\t\t}\r\n\t\t$['cleanData'+replaceSuffix].apply(this, arguments);\r\n\t};\r\n}\r\n;// qTip version\r\nQTIP.version = '3.0.3';\r\n\r\n// Base ID for all qTips\r\nQTIP.nextid = 0;\r\n\r\n// Inactive events array\r\nQTIP.inactiveEvents = INACTIVE_EVENTS;\r\n\r\n// Base z-index for all qTips\r\nQTIP.zindex = 15000;\r\n\r\n// Define configuration defaults\r\nQTIP.defaults = {\r\n\tprerender: FALSE,\r\n\tid: FALSE,\r\n\toverwrite: TRUE,\r\n\tsuppress: TRUE,\r\n\tcontent: {\r\n\t\ttext: TRUE,\r\n\t\tattr: 'title',\r\n\t\ttitle: FALSE,\r\n\t\tbutton: FALSE\r\n\t},\r\n\tposition: {\r\n\t\tmy: 'top left',\r\n\t\tat: 'bottom right',\r\n\t\ttarget: FALSE,\r\n\t\tcontainer: FALSE,\r\n\t\tviewport: FALSE,\r\n\t\tadjust: {\r\n\t\t\tx: 0, y: 0,\r\n\t\t\tmouse: TRUE,\r\n\t\t\tscroll: TRUE,\r\n\t\t\tresize: TRUE,\r\n\t\t\tmethod: 'flipinvert flipinvert'\r\n\t\t},\r\n\t\teffect: function(api, pos) {\r\n\t\t\t$(this).animate(pos, {\r\n\t\t\t\tduration: 200,\r\n\t\t\t\tqueue: FALSE\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\tshow: {\r\n\t\ttarget: FALSE,\r\n\t\tevent: 'mouseenter',\r\n\t\teffect: TRUE,\r\n\t\tdelay: 90,\r\n\t\tsolo: FALSE,\r\n\t\tready: FALSE,\r\n\t\tautofocus: FALSE\r\n\t},\r\n\thide: {\r\n\t\ttarget: FALSE,\r\n\t\tevent: 'mouseleave',\r\n\t\teffect: TRUE,\r\n\t\tdelay: 0,\r\n\t\tfixed: FALSE,\r\n\t\tinactive: FALSE,\r\n\t\tleave: 'window',\r\n\t\tdistance: FALSE\r\n\t},\r\n\tstyle: {\r\n\t\tclasses: '',\r\n\t\twidget: FALSE,\r\n\t\twidth: FALSE,\r\n\t\theight: FALSE,\r\n\t\tdef: TRUE\r\n\t},\r\n\tevents: {\r\n\t\trender: NULL,\r\n\t\tmove: NULL,\r\n\t\tshow: NULL,\r\n\t\thide: NULL,\r\n\t\ttoggle: NULL,\r\n\t\tvisible: NULL,\r\n\t\thidden: NULL,\r\n\t\tfocus: NULL,\r\n\t\tblur: NULL\r\n\t}\r\n};\r\n;var TIP,\r\ncreateVML,\r\nSCALE,\r\nPIXEL_RATIO,\r\nBACKING_STORE_RATIO,\r\n\r\n// Common CSS strings\r\nMARGIN = 'margin',\r\nBORDER = 'border',\r\nCOLOR = 'color',\r\nBG_COLOR = 'background-color',\r\nTRANSPARENT = 'transparent',\r\nIMPORTANT = ' !important',\r\n\r\n// Check if the browser supports <canvas/> elements\r\nHASCANVAS = !!document.createElement('canvas').getContext,\r\n\r\n// Invalid colour values used in parseColours()\r\nINVALID = /rgba?\\(0, 0, 0(, 0)?\\)|transparent|#123456/i;\r\n\r\n// Camel-case method, taken from jQuery source\r\n// http://code.jquery.com/jquery-1.8.0.js\r\nfunction camel(s) { return s.charAt(0).toUpperCase() + s.slice(1); }\r\n\r\n/*\r\n * Modified from Modernizr's testPropsAll()\r\n * http://modernizr.com/downloads/modernizr-latest.js\r\n */\r\nvar cssProps = {}, cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];\r\nfunction vendorCss(elem, prop) {\r\n\tvar ucProp = prop.charAt(0).toUpperCase() + prop.slice(1),\r\n\t\tprops = (prop + ' ' + cssPrefixes.join(ucProp + ' ') + ucProp).split(' '),\r\n\t\tcur, val, i = 0;\r\n\r\n\t// If the property has already been mapped...\r\n\tif(cssProps[prop]) { return elem.css(cssProps[prop]); }\r\n\r\n\twhile(cur = props[i++]) {\r\n\t\tif((val = elem.css(cur)) !== undefined) {\r\n\t\t\tcssProps[prop] = cur;\r\n\t\t\treturn val;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Parse a given elements CSS property into an int\r\nfunction intCss(elem, prop) {\r\n\treturn Math.ceil(parseFloat(vendorCss(elem, prop)));\r\n}\r\n\r\n\r\n// VML creation (for IE only)\r\nif(!HASCANVAS) {\r\n\tcreateVML = function(tag, props, style) {\r\n\t\treturn '<qtipvml:'+tag+' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"qtip-vml\" '+(props||'')+\r\n\t\t\t' style=\"behavior: url(#default#VML); '+(style||'')+ '\" />';\r\n\t};\r\n}\r\n\r\n// Canvas only definitions\r\nelse {\r\n\tPIXEL_RATIO = window.devicePixelRatio || 1;\r\n\tBACKING_STORE_RATIO = (function() {\r\n\t\tvar context = document.createElement('canvas').getContext('2d');\r\n\t\treturn context.backingStorePixelRatio || context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio ||\r\n\t\t\t\tcontext.msBackingStorePixelRatio || context.oBackingStorePixelRatio || 1;\r\n\t})();\r\n\tSCALE = PIXEL_RATIO / BACKING_STORE_RATIO;\r\n}\r\n\r\n\r\nfunction Tip(qtip, options) {\r\n\tthis._ns = 'tip';\r\n\tthis.options = options;\r\n\tthis.offset = options.offset;\r\n\tthis.size = [ options.width, options.height ];\r\n\r\n\t// Initialize\r\n\tthis.qtip = qtip;\r\n\tthis.init(qtip);\r\n}\r\n\r\n$.extend(Tip.prototype, {\r\n\tinit: function(qtip) {\r\n\t\tvar context, tip;\r\n\r\n\t\t// Create tip element and prepend to the tooltip\r\n\t\ttip = this.element = qtip.elements.tip = $('<div />', { 'class': NAMESPACE+'-tip' }).prependTo(qtip.tooltip);\r\n\r\n\t\t// Create tip drawing element(s)\r\n\t\tif(HASCANVAS) {\r\n\t\t\t// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!\r\n\t\t\tcontext = $('<canvas />').appendTo(this.element)[0].getContext('2d');\r\n\r\n\t\t\t// Setup constant parameters\r\n\t\t\tcontext.lineJoin = 'miter';\r\n\t\t\tcontext.miterLimit = 100000;\r\n\t\t\tcontext.save();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tcontext = createVML('shape', 'coordorigin=\"0,0\"', 'position:absolute;');\r\n\t\t\tthis.element.html(context + context);\r\n\r\n\t\t\t// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML\r\n\t\t\tqtip._bind( $('*', tip).add(tip), ['click', 'mousedown'], function(event) { event.stopPropagation(); }, this._ns);\r\n\t\t}\r\n\r\n\t\t// Bind update events\r\n\t\tqtip._bind(qtip.tooltip, 'tooltipmove', this.reposition, this._ns, this);\r\n\r\n\t\t// Create it\r\n\t\tthis.create();\r\n\t},\r\n\r\n\t_swapDimensions: function() {\r\n\t\tthis.size[0] = this.options.height;\r\n\t\tthis.size[1] = this.options.width;\r\n\t},\r\n\t_resetDimensions: function() {\r\n\t\tthis.size[0] = this.options.width;\r\n\t\tthis.size[1] = this.options.height;\r\n\t},\r\n\r\n\t_useTitle: function(corner) {\r\n\t\tvar titlebar = this.qtip.elements.titlebar;\r\n\t\treturn titlebar && (\r\n\t\t\tcorner.y === TOP || corner.y === CENTER && this.element.position().top + this.size[1] / 2 + this.options.offset < titlebar.outerHeight(TRUE)\r\n\t\t);\r\n\t},\r\n\r\n\t_parseCorner: function(corner) {\r\n\t\tvar my = this.qtip.options.position.my;\r\n\r\n\t\t// Detect corner and mimic properties\r\n\t\tif(corner === FALSE || my === FALSE) {\r\n\t\t\tcorner = FALSE;\r\n\t\t}\r\n\t\telse if(corner === TRUE) {\r\n\t\t\tcorner = new CORNER( my.string() );\r\n\t\t}\r\n\t\telse if(!corner.string) {\r\n\t\t\tcorner = new CORNER(corner);\r\n\t\t\tcorner.fixed = TRUE;\r\n\t\t}\r\n\r\n\t\treturn corner;\r\n\t},\r\n\r\n\t_parseWidth: function(corner, side, use) {\r\n\t\tvar elements = this.qtip.elements,\r\n\t\t\tprop = BORDER + camel(side) + 'Width';\r\n\r\n\t\treturn (use ? intCss(use, prop) : \r\n\t\t\tintCss(elements.content, prop) ||\r\n\t\t\tintCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||\r\n\t\t\tintCss(elements.tooltip, prop)\r\n\t\t) || 0;\r\n\t},\r\n\r\n\t_parseRadius: function(corner) {\r\n\t\tvar elements = this.qtip.elements,\r\n\t\t\tprop = BORDER + camel(corner.y) + camel(corner.x) + 'Radius';\r\n\r\n\t\treturn BROWSER.ie < 9 ? 0 :\r\n\t\t\tintCss(this._useTitle(corner) && elements.titlebar || elements.content, prop) ||\r\n\t\t\tintCss(elements.tooltip, prop) || 0;\r\n\t},\r\n\r\n\t_invalidColour: function(elem, prop, compare) {\r\n\t\tvar val = elem.css(prop);\r\n\t\treturn !val || compare && val === elem.css(compare) || INVALID.test(val) ? FALSE : val;\r\n\t},\r\n\r\n\t_parseColours: function(corner) {\r\n\t\tvar elements = this.qtip.elements,\r\n\t\t\ttip = this.element.css('cssText', ''),\r\n\t\t\tborderSide = BORDER + camel(corner[ corner.precedance ]) + camel(COLOR),\r\n\t\t\tcolorElem = this._useTitle(corner) && elements.titlebar || elements.content,\r\n\t\t\tcss = this._invalidColour, color = [];\r\n\r\n\t\t// Attempt to detect the background colour from various elements, left-to-right precedance\r\n\t\tcolor[0] = css(tip, BG_COLOR) || css(colorElem, BG_COLOR) || css(elements.content, BG_COLOR) ||\r\n\t\t\tcss(elements.tooltip, BG_COLOR) || tip.css(BG_COLOR);\r\n\r\n\t\t// Attempt to detect the correct border side colour from various elements, left-to-right precedance\r\n\t\tcolor[1] = css(tip, borderSide, COLOR) || css(colorElem, borderSide, COLOR) ||\r\n\t\t\tcss(elements.content, borderSide, COLOR) || css(elements.tooltip, borderSide, COLOR) || elements.tooltip.css(borderSide);\r\n\r\n\t\t// Reset background and border colours\r\n\t\t$('*', tip).add(tip).css('cssText', BG_COLOR+':'+TRANSPARENT+IMPORTANT+';'+BORDER+':0'+IMPORTANT+';');\r\n\r\n\t\treturn color;\r\n\t},\r\n\r\n\t_calculateSize: function(corner) {\r\n\t\tvar y = corner.precedance === Y,\r\n\t\t\twidth = this.options.width,\r\n\t\t\theight = this.options.height,\r\n\t\t\tisCenter = corner.abbrev() === 'c',\r\n\t\t\tbase = (y ? width: height) * (isCenter ? 0.5 : 1),\r\n\t\t\tpow = Math.pow,\r\n\t\t\tround = Math.round,\r\n\t\t\tbigHyp, ratio, result,\r\n\r\n\t\tsmallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),\r\n\t\thyp = [\r\n\t\t\tthis.border / base * smallHyp,\r\n\t\t\tthis.border / height * smallHyp\r\n\t\t];\r\n\r\n\t\thyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(this.border, 2) );\r\n\t\thyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(this.border, 2) );\r\n\r\n\t\tbigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);\r\n\t\tratio = bigHyp / smallHyp;\r\n\r\n\t\tresult = [ round(ratio * width), round(ratio * height) ];\r\n\t\treturn y ? result : result.reverse();\r\n\t},\r\n\r\n\t// Tip coordinates calculator\r\n\t_calculateTip: function(corner, size, scale) {\r\n\t\tscale = scale || 1;\r\n\t\tsize = size || this.size;\r\n\r\n\t\tvar width = size[0] * scale,\r\n\t\t\theight = size[1] * scale,\r\n\t\t\twidth2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),\r\n\r\n\t\t// Define tip coordinates in terms of height and width values\r\n\t\ttips = {\r\n\t\t\tbr:\t[0,0,\t\twidth,height,\twidth,0],\r\n\t\t\tbl:\t[0,0,\t\twidth,0,\t\t0,height],\r\n\t\t\ttr:\t[0,height,\twidth,0,\t\twidth,height],\r\n\t\t\ttl:\t[0,0,\t\t0,height,\t\twidth,height],\r\n\t\t\ttc:\t[0,height,\twidth2,0,\t\twidth,height],\r\n\t\t\tbc:\t[0,0,\t\twidth,0,\t\twidth2,height],\r\n\t\t\trc:\t[0,0,\t\twidth,height2,\t0,height],\r\n\t\t\tlc:\t[width,0,\twidth,height,\t0,height2]\r\n\t\t};\r\n\r\n\t\t// Set common side shapes\r\n\t\ttips.lt = tips.br; tips.rt = tips.bl;\r\n\t\ttips.lb = tips.tr; tips.rb = tips.tl;\r\n\r\n\t\treturn tips[ corner.abbrev() ];\r\n\t},\r\n\r\n\t// Tip coordinates drawer (canvas)\r\n\t_drawCoords: function(context, coords) {\r\n\t\tcontext.beginPath();\r\n\t\tcontext.moveTo(coords[0], coords[1]);\r\n\t\tcontext.lineTo(coords[2], coords[3]);\r\n\t\tcontext.lineTo(coords[4], coords[5]);\r\n\t\tcontext.closePath();\r\n\t},\r\n\r\n\tcreate: function() {\r\n\t\t// Determine tip corner\r\n\t\tvar c = this.corner = (HASCANVAS || BROWSER.ie) && this._parseCorner(this.options.corner);\r\n\r\n\t\t// If we have a tip corner...\r\n\t\tthis.enabled = !!this.corner && this.corner.abbrev() !== 'c';\r\n\t\tif(this.enabled) {\r\n\t\t\t// Cache it\r\n\t\t\tthis.qtip.cache.corner = c.clone();\r\n\r\n\t\t\t// Create it\r\n\t\t\tthis.update();\r\n\t\t}\r\n\r\n\t\t// Toggle tip element\r\n\t\tthis.element.toggle(this.enabled);\r\n\r\n\t\treturn this.corner;\r\n\t},\r\n\r\n\tupdate: function(corner, position) {\r\n\t\tif(!this.enabled) { return this; }\r\n\r\n\t\tvar elements = this.qtip.elements,\r\n\t\t\ttip = this.element,\r\n\t\t\tinner = tip.children(),\r\n\t\t\toptions = this.options,\r\n\t\t\tcurSize = this.size,\r\n\t\t\tmimic = options.mimic,\r\n\t\t\tround = Math.round,\r\n\t\t\tcolor, precedance, context,\r\n\t\t\tcoords, bigCoords, translate, newSize, border;\r\n\r\n\t\t// Re-determine tip if not already set\r\n\t\tif(!corner) { corner = this.qtip.cache.corner || this.corner; }\r\n\r\n\t\t// Use corner property if we detect an invalid mimic value\r\n\t\tif(mimic === FALSE) { mimic = corner; }\r\n\r\n\t\t// Otherwise inherit mimic properties from the corner object as necessary\r\n\t\telse {\r\n\t\t\tmimic = new CORNER(mimic);\r\n\t\t\tmimic.precedance = corner.precedance;\r\n\r\n\t\t\tif(mimic.x === 'inherit') { mimic.x = corner.x; }\r\n\t\t\telse if(mimic.y === 'inherit') { mimic.y = corner.y; }\r\n\t\t\telse if(mimic.x === mimic.y) {\r\n\t\t\t\tmimic[ corner.precedance ] = corner[ corner.precedance ];\r\n\t\t\t}\r\n\t\t}\r\n\t\tprecedance = mimic.precedance;\r\n\r\n\t\t// Ensure the tip width.height are relative to the tip position\r\n\t\tif(corner.precedance === X) { this._swapDimensions(); }\r\n\t\telse { this._resetDimensions(); }\r\n\r\n\t\t// Update our colours\r\n\t\tcolor = this.color = this._parseColours(corner);\r\n\r\n\t\t// Detect border width, taking into account colours\r\n\t\tif(color[1] !== TRANSPARENT) {\r\n\t\t\t// Grab border width\r\n\t\t\tborder = this.border = this._parseWidth(corner, corner[corner.precedance]);\r\n\r\n\t\t\t// If border width isn't zero, use border color as fill if it's not invalid (1.0 style tips)\r\n\t\t\tif(options.border && border < 1 && !INVALID.test(color[1])) { color[0] = color[1]; }\r\n\r\n\t\t\t// Set border width (use detected border width if options.border is true)\r\n\t\t\tthis.border = border = options.border !== TRUE ? options.border : border;\r\n\t\t}\r\n\r\n\t\t// Border colour was invalid, set border to zero\r\n\t\telse { this.border = border = 0; }\r\n\r\n\t\t// Determine tip size\r\n\t\tnewSize = this.size = this._calculateSize(corner);\r\n\t\ttip.css({\r\n\t\t\twidth: newSize[0],\r\n\t\t\theight: newSize[1],\r\n\t\t\tlineHeight: newSize[1]+'px'\r\n\t\t});\r\n\r\n\t\t// Calculate tip translation\r\n\t\tif(corner.precedance === Y) {\r\n\t\t\ttranslate = [\r\n\t\t\t\tround(mimic.x === LEFT ? border : mimic.x === RIGHT ? newSize[0] - curSize[0] - border : (newSize[0] - curSize[0]) / 2),\r\n\t\t\t\tround(mimic.y === TOP ? newSize[1] - curSize[1] : 0)\r\n\t\t\t];\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttranslate = [\r\n\t\t\t\tround(mimic.x === LEFT ? newSize[0] - curSize[0] : 0),\r\n\t\t\t\tround(mimic.y === TOP ? border : mimic.y === BOTTOM ? newSize[1] - curSize[1] - border : (newSize[1] - curSize[1]) / 2)\r\n\t\t\t];\r\n\t\t}\r\n\r\n\t\t// Canvas drawing implementation\r\n\t\tif(HASCANVAS) {\r\n\t\t\t// Grab canvas context and clear/save it\r\n\t\t\tcontext = inner[0].getContext('2d');\r\n\t\t\tcontext.restore(); context.save();\r\n\t\t\tcontext.clearRect(0,0,6000,6000);\r\n\r\n\t\t\t// Calculate coordinates\r\n\t\t\tcoords = this._calculateTip(mimic, curSize, SCALE);\r\n\t\t\tbigCoords = this._calculateTip(mimic, this.size, SCALE);\r\n\r\n\t\t\t// Set the canvas size using calculated size\r\n\t\t\tinner.attr(WIDTH, newSize[0] * SCALE).attr(HEIGHT, newSize[1] * SCALE);\r\n\t\t\tinner.css(WIDTH, newSize[0]).css(HEIGHT, newSize[1]);\r\n\r\n\t\t\t// Draw the outer-stroke tip\r\n\t\t\tthis._drawCoords(context, bigCoords);\r\n\t\t\tcontext.fillStyle = color[1];\r\n\t\t\tcontext.fill();\r\n\r\n\t\t\t// Draw the actual tip\r\n\t\t\tcontext.translate(translate[0] * SCALE, translate[1] * SCALE);\r\n\t\t\tthis._drawCoords(context, coords);\r\n\t\t\tcontext.fillStyle = color[0];\r\n\t\t\tcontext.fill();\r\n\t\t}\r\n\r\n\t\t// VML (IE Proprietary implementation)\r\n\t\telse {\r\n\t\t\t// Calculate coordinates\r\n\t\t\tcoords = this._calculateTip(mimic);\r\n\r\n\t\t\t// Setup coordinates string\r\n\t\t\tcoords = 'm' + coords[0] + ',' + coords[1] + ' l' + coords[2] +\r\n\t\t\t\t',' + coords[3] + ' ' + coords[4] + ',' + coords[5] + ' xe';\r\n\r\n\t\t\t// Setup VML-specific offset for pixel-perfection\r\n\t\t\ttranslate[2] = border && /^(r|b)/i.test(corner.string()) ?\r\n\t\t\t\tBROWSER.ie === 8 ? 2 : 1 : 0;\r\n\r\n\t\t\t// Set initial CSS\r\n\t\t\tinner.css({\r\n\t\t\t\tcoordsize: newSize[0]+border + ' ' + newSize[1]+border,\r\n\t\t\t\tantialias: ''+(mimic.string().indexOf(CENTER) > -1),\r\n\t\t\t\tleft: translate[0] - translate[2] * Number(precedance === X),\r\n\t\t\t\ttop: translate[1] - translate[2] * Number(precedance === Y),\r\n\t\t\t\twidth: newSize[0] + border,\r\n\t\t\t\theight: newSize[1] + border\r\n\t\t\t})\r\n\t\t\t.each(function(i) {\r\n\t\t\t\tvar $this = $(this);\r\n\r\n\t\t\t\t// Set shape specific attributes\r\n\t\t\t\t$this[ $this.prop ? 'prop' : 'attr' ]({\r\n\t\t\t\t\tcoordsize: newSize[0]+border + ' ' + newSize[1]+border,\r\n\t\t\t\t\tpath: coords,\r\n\t\t\t\t\tfillcolor: color[0],\r\n\t\t\t\t\tfilled: !!i,\r\n\t\t\t\t\tstroked: !i\r\n\t\t\t\t})\r\n\t\t\t\t.toggle(!!(border || i));\r\n\r\n\t\t\t\t// Check if border is enabled and add stroke element\r\n\t\t\t\t!i && $this.html( createVML(\r\n\t\t\t\t\t'stroke', 'weight=\"'+border*2+'px\" color=\"'+color[1]+'\" miterlimit=\"1000\" joinstyle=\"miter\"'\r\n\t\t\t\t) );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Opera bug #357 - Incorrect tip position\r\n\t\t// https://github.com/Craga89/qTip2/issues/367\r\n\t\twindow.opera && setTimeout(function() {\r\n\t\t\telements.tip.css({\r\n\t\t\t\tdisplay: 'inline-block',\r\n\t\t\t\tvisibility: 'visible'\r\n\t\t\t});\r\n\t\t}, 1);\r\n\r\n\t\t// Position if needed\r\n\t\tif(position !== FALSE) { this.calculate(corner, newSize); }\r\n\t},\r\n\r\n\tcalculate: function(corner, size) {\r\n\t\tif(!this.enabled) { return FALSE; }\r\n\r\n\t\tvar self = this,\r\n\t\t\telements = this.qtip.elements,\r\n\t\t\ttip = this.element,\r\n\t\t\tuserOffset = this.options.offset,\r\n\t\t\tposition = {},\r\n\t\t\tprecedance, corners;\r\n\r\n\t\t// Inherit corner if not provided\r\n\t\tcorner = corner || this.corner;\r\n\t\tprecedance = corner.precedance;\r\n\r\n\t\t// Determine which tip dimension to use for adjustment\r\n\t\tsize = size || this._calculateSize(corner);\r\n\r\n\t\t// Setup corners and offset array\r\n\t\tcorners = [ corner.x, corner.y ];\r\n\t\tif(precedance === X) { corners.reverse(); }\r\n\r\n\t\t// Calculate tip position\r\n\t\t$.each(corners, function(i, side) {\r\n\t\t\tvar b, bc, br;\r\n\r\n\t\t\tif(side === CENTER) {\r\n\t\t\t\tb = precedance === Y ? LEFT : TOP;\r\n\t\t\t\tposition[ b ] = '50%';\r\n\t\t\t\tposition[MARGIN+'-' + b] = -Math.round(size[ precedance === Y ? 0 : 1 ] / 2) + userOffset;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tb = self._parseWidth(corner, side, elements.tooltip);\r\n\t\t\t\tbc = self._parseWidth(corner, side, elements.content);\r\n\t\t\t\tbr = self._parseRadius(corner);\r\n\r\n\t\t\t\tposition[ side ] = Math.max(-self.border, i ? bc : userOffset + (br > b ? br : -b));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Adjust for tip size\r\n\t\tposition[ corner[precedance] ] -= size[ precedance === X ? 0 : 1 ];\r\n\r\n\t\t// Set and return new position\r\n\t\ttip.css({ margin: '', top: '', bottom: '', left: '', right: '' }).css(position);\r\n\t\treturn position;\r\n\t},\r\n\r\n\treposition: function(event, api, pos) {\r\n\t\tif(!this.enabled) { return; }\r\n\r\n\t\tvar cache = api.cache,\r\n\t\t\tnewCorner = this.corner.clone(),\r\n\t\t\tadjust = pos.adjusted,\r\n\t\t\tmethod = api.options.position.adjust.method.split(' '),\r\n\t\t\thorizontal = method[0],\r\n\t\t\tvertical = method[1] || method[0],\r\n\t\t\tshift = { left: FALSE, top: FALSE, x: 0, y: 0 },\r\n\t\t\toffset, css = {}, props;\r\n\r\n\t\tfunction shiftflip(direction, precedance, popposite, side, opposite) {\r\n\t\t\t// Horizontal - Shift or flip method\r\n\t\t\tif(direction === SHIFT && newCorner.precedance === precedance && adjust[side] && newCorner[popposite] !== CENTER) {\r\n\t\t\t\tnewCorner.precedance = newCorner.precedance === X ? Y : X;\r\n\t\t\t}\r\n\t\t\telse if(direction !== SHIFT && adjust[side]){\r\n\t\t\t\tnewCorner[precedance] = newCorner[precedance] === CENTER ?\r\n\t\t\t\t\tadjust[side] > 0 ? side : opposite :\r\n\t\t\t\t\tnewCorner[precedance] === side ? opposite : side;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction shiftonly(xy, side, opposite) {\r\n\t\t\tif(newCorner[xy] === CENTER) {\r\n\t\t\t\tcss[MARGIN+'-'+side] = shift[xy] = offset[MARGIN+'-'+side] - adjust[side];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprops = offset[opposite] !== undefined ?\r\n\t\t\t\t\t[ adjust[side], -offset[side] ] : [ -adjust[side], offset[side] ];\r\n\r\n\t\t\t\tif( (shift[xy] = Math.max(props[0], props[1])) > props[0] ) {\r\n\t\t\t\t\tpos[side] -= adjust[side];\r\n\t\t\t\t\tshift[side] = FALSE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcss[ offset[opposite] !== undefined ? opposite : side ] = shift[xy];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// If our tip position isn't fixed e.g. doesn't adjust with viewport...\r\n\t\tif(this.corner.fixed !== TRUE) {\r\n\t\t\t// Perform shift/flip adjustments\r\n\t\t\tshiftflip(horizontal, X, Y, LEFT, RIGHT);\r\n\t\t\tshiftflip(vertical, Y, X, TOP, BOTTOM);\r\n\r\n\t\t\t// Update and redraw the tip if needed (check cached details of last drawn tip)\r\n\t\t\tif(newCorner.string() !== cache.corner.string() || cache.cornerTop !== adjust.top || cache.cornerLeft !== adjust.left) {\r\n\t\t\t\tthis.update(newCorner, FALSE);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Setup tip offset properties\r\n\t\toffset = this.calculate(newCorner);\r\n\r\n\t\t// Readjust offset object to make it left/top\r\n\t\tif(offset.right !== undefined) { offset.left = -offset.right; }\r\n\t\tif(offset.bottom !== undefined) { offset.top = -offset.bottom; }\r\n\t\toffset.user = this.offset;\r\n\r\n\t\t// Perform shift adjustments\r\n\t\tshift.left = horizontal === SHIFT && !!adjust.left;\r\n\t\tif(shift.left) {\r\n\t\t\tshiftonly(X, LEFT, RIGHT);\r\n\t\t}\r\n\t\tshift.top = vertical === SHIFT && !!adjust.top;\r\n\t\tif(shift.top) {\r\n\t\t\tshiftonly(Y, TOP, BOTTOM);\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* If the tip is adjusted in both dimensions, or in a\r\n\t\t* direction that would cause it to be anywhere but the\r\n\t\t* outer border, hide it!\r\n\t\t*/\r\n\t\tthis.element.css(css).toggle(\r\n\t\t\t!(shift.x && shift.y || newCorner.x === CENTER && shift.y || newCorner.y === CENTER && shift.x)\r\n\t\t);\r\n\r\n\t\t// Adjust position to accomodate tip dimensions\r\n\t\tpos.left -= offset.left.charAt ? offset.user :\r\n\t\t\thorizontal !== SHIFT || shift.top || !shift.left && !shift.top ? offset.left + this.border : 0;\r\n\t\tpos.top -= offset.top.charAt ? offset.user :\r\n\t\t\tvertical !== SHIFT || shift.left || !shift.left && !shift.top ? offset.top + this.border : 0;\r\n\r\n\t\t// Cache details\r\n\t\tcache.cornerLeft = adjust.left; cache.cornerTop = adjust.top;\r\n\t\tcache.corner = newCorner.clone();\r\n\t},\r\n\r\n\tdestroy: function() {\r\n\t\t// Unbind events\r\n\t\tthis.qtip._unbind(this.qtip.tooltip, this._ns);\r\n\r\n\t\t// Remove the tip element(s)\r\n\t\tif(this.qtip.elements.tip) {\r\n\t\t\tthis.qtip.elements.tip.find('*')\r\n\t\t\t\t.remove().end().remove();\r\n\t\t}\r\n\t}\r\n});\r\n\r\nTIP = PLUGINS.tip = function(api) {\r\n\treturn new Tip(api, api.options.style.tip);\r\n};\r\n\r\n// Initialize tip on render\r\nTIP.initialize = 'render';\r\n\r\n// Setup plugin sanitization options\r\nTIP.sanitize = function(options) {\r\n\tif(options.style && 'tip' in options.style) {\r\n\t\tvar opts = options.style.tip;\r\n\t\tif(typeof opts !== 'object') { opts = options.style.tip = { corner: opts }; }\r\n\t\tif(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }\r\n\t}\r\n};\r\n\r\n// Add new option checks for the plugin\r\nCHECKS.tip = {\r\n\t'^position.my|style.tip.(corner|mimic|border)$': function() {\r\n\t\t// Make sure a tip can be drawn\r\n\t\tthis.create();\r\n\r\n\t\t// Reposition the tooltip\r\n\t\tthis.qtip.reposition();\r\n\t},\r\n\t'^style.tip.(height|width)$': function(obj) {\r\n\t\t// Re-set dimensions and redraw the tip\r\n\t\tthis.size = [ obj.width, obj.height ];\r\n\t\tthis.update();\r\n\r\n\t\t// Reposition the tooltip\r\n\t\tthis.qtip.reposition();\r\n\t},\r\n\t'^content.title|style.(classes|widget)$': function() {\r\n\t\tthis.update();\r\n\t}\r\n};\r\n\r\n// Extend original qTip defaults\r\n$.extend(TRUE, QTIP.defaults, {\r\n\tstyle: {\r\n\t\ttip: {\r\n\t\t\tcorner: TRUE,\r\n\t\t\tmimic: FALSE,\r\n\t\t\twidth: 6,\r\n\t\t\theight: 6,\r\n\t\t\tborder: TRUE,\r\n\t\t\toffset: 0\r\n\t\t}\r\n\t}\r\n});\r\n;var MODAL, OVERLAY,\r\n\tMODALCLASS = 'qtip-modal',\r\n\tMODALSELECTOR = '.'+MODALCLASS;\r\n\r\nOVERLAY = function()\r\n{\r\n\tvar self = this,\r\n\t\tfocusableElems = {},\r\n\t\tcurrent,\r\n\t\tprevState,\r\n\t\telem;\r\n\r\n\t// Modified code from jQuery UI 1.10.0 source\r\n\t// http://code.jquery.com/ui/1.10.0/jquery-ui.js\r\n\tfunction focusable(element) {\r\n\t\t// Use the defined focusable checker when possible\r\n\t\tif($.expr[':'].focusable) { return $.expr[':'].focusable; }\r\n\r\n\t\tvar isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex')),\r\n\t\t\tnodeName = element.nodeName && element.nodeName.toLowerCase(),\r\n\t\t\tmap, mapName, img;\r\n\r\n\t\tif('area' === nodeName) {\r\n\t\t\tmap = element.parentNode;\r\n\t\t\tmapName = map.name;\r\n\t\t\tif(!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\timg = $('img[usemap=#' + mapName + ']')[0];\r\n\t\t\treturn !!img && img.is(':visible');\r\n\t\t}\r\n\r\n\t\treturn /input|select|textarea|button|object/.test( nodeName ) ?\r\n\t\t\t!element.disabled :\r\n\t\t\t'a' === nodeName ?\r\n\t\t\t\telement.href || isTabIndexNotNaN :\r\n\t\t\t\tisTabIndexNotNaN\r\n\t\t;\r\n\t}\r\n\r\n\t// Focus inputs using cached focusable elements (see update())\r\n\tfunction focusInputs(blurElems) {\r\n\t\t// Blurring body element in IE causes window.open windows to unfocus!\r\n\t\tif(focusableElems.length < 1 && blurElems.length) { blurElems.not('body').blur(); }\r\n\r\n\t\t// Focus the inputs\r\n\t\telse { focusableElems.first().focus(); }\r\n\t}\r\n\r\n\t// Steal focus from elements outside tooltip\r\n\tfunction stealFocus(event) {\r\n\t\tif(!elem.is(':visible')) { return; }\r\n\r\n\t\tvar target = $(event.target),\r\n\t\t\ttooltip = current.tooltip,\r\n\t\t\tcontainer = target.closest(SELECTOR),\r\n\t\t\ttargetOnTop;\r\n\r\n\t\t// Determine if input container target is above this\r\n\t\ttargetOnTop = container.length < 1 ? FALSE :\r\n\t\t\tparseInt(container[0].style.zIndex, 10) > parseInt(tooltip[0].style.zIndex, 10);\r\n\r\n\t\t// If we're showing a modal, but focus has landed on an input below\r\n\t\t// this modal, divert focus to the first visible input in this modal\r\n\t\t// or if we can't find one... the tooltip itself\r\n\t\tif(!targetOnTop && target.closest(SELECTOR)[0] !== tooltip[0]) {\r\n\t\t\tfocusInputs(target);\r\n\t\t}\r\n\t}\r\n\r\n\t$.extend(self, {\r\n\t\tinit: function() {\r\n\t\t\t// Create document overlay\r\n\t\t\telem = self.elem = $('<div />', {\r\n\t\t\t\tid: 'qtip-overlay',\r\n\t\t\t\thtml: '<div></div>',\r\n\t\t\t\tmousedown: function() { return FALSE; }\r\n\t\t\t})\r\n\t\t\t.hide();\r\n\r\n\t\t\t// Make sure we can't focus anything outside the tooltip\r\n\t\t\t$(document.body).bind('focusin'+MODALSELECTOR, stealFocus);\r\n\r\n\t\t\t// Apply keyboard \"Escape key\" close handler\r\n\t\t\t$(document).bind('keydown'+MODALSELECTOR, function(event) {\r\n\t\t\t\tif(current && current.options.show.modal.escape && event.keyCode === 27) {\r\n\t\t\t\t\tcurrent.hide(event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Apply click handler for blur option\r\n\t\t\telem.bind('click'+MODALSELECTOR, function(event) {\r\n\t\t\t\tif(current && current.options.show.modal.blur) {\r\n\t\t\t\t\tcurrent.hide(event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tupdate: function(api) {\r\n\t\t\t// Update current API reference\r\n\t\t\tcurrent = api;\r\n\r\n\t\t\t// Update focusable elements if enabled\r\n\t\t\tif(api.options.show.modal.stealfocus !== FALSE) {\r\n\t\t\t\tfocusableElems = api.tooltip.find('*').filter(function() {\r\n\t\t\t\t\treturn focusable(this);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse { focusableElems = []; }\r\n\t\t},\r\n\r\n\t\ttoggle: function(api, state, duration) {\r\n\t\t\tvar tooltip = api.tooltip,\r\n\t\t\t\toptions = api.options.show.modal,\r\n\t\t\t\teffect = options.effect,\r\n\t\t\t\ttype = state ? 'show': 'hide',\r\n\t\t\t\tvisible = elem.is(':visible'),\r\n\t\t\t\tvisibleModals = $(MODALSELECTOR).filter(':visible:not(:animated)').not(tooltip);\r\n\r\n\t\t\t// Set active tooltip API reference\r\n\t\t\tself.update(api);\r\n\r\n\t\t\t// If the modal can steal the focus...\r\n\t\t\t// Blur the current item and focus anything in the modal we an\r\n\t\t\tif(state && options.stealfocus !== FALSE) {\r\n\t\t\t\tfocusInputs( $(':focus') );\r\n\t\t\t}\r\n\r\n\t\t\t// Toggle backdrop cursor style on show\r\n\t\t\telem.toggleClass('blurs', options.blur);\r\n\r\n\t\t\t// Append to body on show\r\n\t\t\tif(state) {\r\n\t\t\t\telem.appendTo(document.body);\r\n\t\t\t}\r\n\r\n\t\t\t// Prevent modal from conflicting with show.solo, and don't hide backdrop is other modals are visible\r\n\t\t\tif(elem.is(':animated') && visible === state && prevState !== FALSE || !state && visibleModals.length) {\r\n\t\t\t\treturn self;\r\n\t\t\t}\r\n\r\n\t\t\t// Stop all animations\r\n\t\t\telem.stop(TRUE, FALSE);\r\n\r\n\t\t\t// Use custom function if provided\r\n\t\t\tif($.isFunction(effect)) {\r\n\t\t\t\teffect.call(elem, state);\r\n\t\t\t}\r\n\r\n\t\t\t// If no effect type is supplied, use a simple toggle\r\n\t\t\telse if(effect === FALSE) {\r\n\t\t\t\telem[ type ]();\r\n\t\t\t}\r\n\r\n\t\t\t// Use basic fade function\r\n\t\t\telse {\r\n\t\t\t\telem.fadeTo( parseInt(duration, 10) || 90, state ? 1 : 0, function() {\r\n\t\t\t\t\tif(!state) { elem.hide(); }\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Reset position and detach from body on hide\r\n\t\t\tif(!state) {\r\n\t\t\t\telem.queue(function(next) {\r\n\t\t\t\t\telem.css({ left: '', top: '' });\r\n\t\t\t\t\tif(!$(MODALSELECTOR).length) { elem.detach(); }\r\n\t\t\t\t\tnext();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Cache the state\r\n\t\t\tprevState = state;\r\n\r\n\t\t\t// If the tooltip is destroyed, set reference to null\r\n\t\t\tif(current.destroyed) { current = NULL; }\r\n\r\n\t\t\treturn self;\r\n\t\t}\r\n\t});\r\n\r\n\tself.init();\r\n};\r\nOVERLAY = new OVERLAY();\r\n\r\nfunction Modal(api, options) {\r\n\tthis.options = options;\r\n\tthis._ns = '-modal';\r\n\r\n\tthis.qtip = api;\r\n\tthis.init(api);\r\n}\r\n\r\n$.extend(Modal.prototype, {\r\n\tinit: function(qtip) {\r\n\t\tvar tooltip = qtip.tooltip;\r\n\r\n\t\t// If modal is disabled... return\r\n\t\tif(!this.options.on) { return this; }\r\n\r\n\t\t// Set overlay reference\r\n\t\tqtip.elements.overlay = OVERLAY.elem;\r\n\r\n\t\t// Add unique attribute so we can grab modal tooltips easily via a SELECTOR, and set z-index\r\n\t\ttooltip.addClass(MODALCLASS).css('z-index', QTIP.modal_zindex + $(MODALSELECTOR).length);\r\n\r\n\t\t// Apply our show/hide/focus modal events\r\n\t\tqtip._bind(tooltip, ['tooltipshow', 'tooltiphide'], function(event, api, duration) {\r\n\t\t\tvar oEvent = event.originalEvent;\r\n\r\n\t\t\t// Make sure mouseout doesn't trigger a hide when showing the modal and mousing onto backdrop\r\n\t\t\tif(event.target === tooltip[0]) {\r\n\t\t\t\tif(oEvent && event.type === 'tooltiphide' && /mouse(leave|enter)/.test(oEvent.type) && $(oEvent.relatedTarget).closest(OVERLAY.elem[0]).length) {\r\n\t\t\t\t\t/* eslint-disable no-empty */\r\n\t\t\t\t\ttry { event.preventDefault(); }\r\n\t\t\t\t\tcatch(e) {}\r\n\t\t\t\t\t/* eslint-enable no-empty */\r\n\t\t\t\t}\r\n\t\t\t\telse if(!oEvent || oEvent && oEvent.type !== 'tooltipsolo') {\r\n\t\t\t\t\tthis.toggle(event, event.type === 'tooltipshow', duration);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, this._ns, this);\r\n\r\n\t\t// Adjust modal z-index on tooltip focus\r\n\t\tqtip._bind(tooltip, 'tooltipfocus', function(event, api) {\r\n\t\t\t// If focus was cancelled before it reached us, don't do anything\r\n\t\t\tif(event.isDefaultPrevented() || event.target !== tooltip[0]) { return; }\r\n\r\n\t\t\tvar qtips = $(MODALSELECTOR),\r\n\r\n\t\t\t// Keep the modal's lower than other, regular qtips\r\n\t\t\tnewIndex = QTIP.modal_zindex + qtips.length,\r\n\t\t\tcurIndex = parseInt(tooltip[0].style.zIndex, 10);\r\n\r\n\t\t\t// Set overlay z-index\r\n\t\t\tOVERLAY.elem[0].style.zIndex = newIndex - 1;\r\n\r\n\t\t\t// Reduce modal z-index's and keep them properly ordered\r\n\t\t\tqtips.each(function() {\r\n\t\t\t\tif(this.style.zIndex > curIndex) {\r\n\t\t\t\t\tthis.style.zIndex -= 1;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Fire blur event for focused tooltip\r\n\t\t\tqtips.filter('.' + CLASS_FOCUS).qtip('blur', event.originalEvent);\r\n\r\n\t\t\t// Set the new z-index\r\n\t\t\ttooltip.addClass(CLASS_FOCUS)[0].style.zIndex = newIndex;\r\n\r\n\t\t\t// Set current\r\n\t\t\tOVERLAY.update(api);\r\n\r\n\t\t\t// Prevent default handling\r\n\t\t\t/* eslint-disable no-empty */\r\n\t\t\ttry { event.preventDefault(); }\r\n\t\t\tcatch(e) {}\r\n\t\t\t/* eslint-enable no-empty */\r\n\t\t}, this._ns, this);\r\n\r\n\t\t// Focus any other visible modals when this one hides\r\n\t\tqtip._bind(tooltip, 'tooltiphide', function(event) {\r\n\t\t\tif(event.target === tooltip[0]) {\r\n\t\t\t\t$(MODALSELECTOR).filter(':visible').not(tooltip).last().qtip('focus', event);\r\n\t\t\t}\r\n\t\t}, this._ns, this);\r\n\t},\r\n\r\n\ttoggle: function(event, state, duration) {\r\n\t\t// Make sure default event hasn't been prevented\r\n\t\tif(event && event.isDefaultPrevented()) { return this; }\r\n\r\n\t\t// Toggle it\r\n\t\tOVERLAY.toggle(this.qtip, !!state, duration);\r\n\t},\r\n\r\n\tdestroy: function() {\r\n\t\t// Remove modal class\r\n\t\tthis.qtip.tooltip.removeClass(MODALCLASS);\r\n\r\n\t\t// Remove bound events\r\n\t\tthis.qtip._unbind(this.qtip.tooltip, this._ns);\r\n\r\n\t\t// Delete element reference\r\n\t\tOVERLAY.toggle(this.qtip, FALSE);\r\n\t\tdelete this.qtip.elements.overlay;\r\n\t}\r\n});\r\n\r\n\r\nMODAL = PLUGINS.modal = function(api) {\r\n\treturn new Modal(api, api.options.show.modal);\r\n};\r\n\r\n// Setup sanitiztion rules\r\nMODAL.sanitize = function(opts) {\r\n\tif(opts.show) {\r\n\t\tif(typeof opts.show.modal !== 'object') { opts.show.modal = { on: !!opts.show.modal }; }\r\n\t\telse if(typeof opts.show.modal.on === 'undefined') { opts.show.modal.on = TRUE; }\r\n\t}\r\n};\r\n\r\n// Base z-index for all modal tooltips (use qTip core z-index as a base)\r\n/* eslint-disable camelcase */\r\nQTIP.modal_zindex = QTIP.zindex - 200;\r\n/* eslint-enable camelcase */\r\n\r\n// Plugin needs to be initialized on render\r\nMODAL.initialize = 'render';\r\n\r\n// Setup option set checks\r\nCHECKS.modal = {\r\n\t'^show.modal.(on|blur)$': function() {\r\n\t\t// Initialise\r\n\t\tthis.destroy();\r\n\t\tthis.init();\r\n\r\n\t\t// Show the modal if not visible already and tooltip is visible\r\n\t\tthis.qtip.elems.overlay.toggle(\r\n\t\t\tthis.qtip.tooltip[0].offsetWidth > 0\r\n\t\t);\r\n\t}\r\n};\r\n\r\n// Extend original api defaults\r\n$.extend(TRUE, QTIP.defaults, {\r\n\tshow: {\r\n\t\tmodal: {\r\n\t\t\ton: FALSE,\r\n\t\t\teffect: TRUE,\r\n\t\t\tblur: TRUE,\r\n\t\t\tstealfocus: TRUE,\r\n\t\t\tescape: TRUE\r\n\t\t}\r\n\t}\r\n});\r\n;PLUGINS.viewport = function(api, position, posOptions, targetWidth, targetHeight, elemWidth, elemHeight)\r\n{\r\n\tvar target = posOptions.target,\r\n\t\ttooltip = api.elements.tooltip,\r\n\t\tmy = posOptions.my,\r\n\t\tat = posOptions.at,\r\n\t\tadjust = posOptions.adjust,\r\n\t\tmethod = adjust.method.split(' '),\r\n\t\tmethodX = method[0],\r\n\t\tmethodY = method[1] || method[0],\r\n\t\tviewport = posOptions.viewport,\r\n\t\tcontainer = posOptions.container,\r\n\t\tadjusted = { left: 0, top: 0 },\r\n\t\tfixed, newMy, containerOffset, containerStatic,\r\n\t\tviewportWidth, viewportHeight, viewportScroll, viewportOffset;\r\n\r\n\t// If viewport is not a jQuery element, or it's the window/document, or no adjustment method is used... return\r\n\tif(!viewport.jquery || target[0] === window || target[0] === document.body || adjust.method === 'none') {\r\n\t\treturn adjusted;\r\n\t}\r\n\r\n\t// Cach container details\r\n\tcontainerOffset = container.offset() || adjusted;\r\n\tcontainerStatic = container.css('position') === 'static';\r\n\r\n\t// Cache our viewport details\r\n\tfixed = tooltip.css('position') === 'fixed';\r\n\tviewportWidth = viewport[0] === window ? viewport.width() : viewport.outerWidth(FALSE);\r\n\tviewportHeight = viewport[0] === window ? viewport.height() : viewport.outerHeight(FALSE);\r\n\tviewportScroll = { left: fixed ? 0 : viewport.scrollLeft(), top: fixed ? 0 : viewport.scrollTop() };\r\n\tviewportOffset = viewport[0] !== window && viewport.offset() || adjusted;\r\n\r\n\t// Generic calculation method\r\n\tfunction calculate(side, otherSide, type, adjustment, side1, side2, lengthName, targetLength, elemLength) {\r\n\t\tvar initialPos = position[side1],\r\n\t\t\tmySide = my[side],\r\n\t\t\tatSide = at[side],\r\n\t\t\tisShift = type === SHIFT,\r\n\t\t\tmyLength = mySide === side1 ? elemLength : mySide === side2 ? -elemLength : -elemLength / 2,\r\n\t\t\tatLength = atSide === side1 ? targetLength : atSide === side2 ? -targetLength : -targetLength / 2,\r\n\t\t\tsideOffset = viewportScroll[side1] + viewportOffset[side1] - (containerStatic ? 0 : containerOffset[side1]),\r\n\t\t\toverflow1 = sideOffset - initialPos,\r\n\t\t\toverflow2 = initialPos + elemLength - (lengthName === WIDTH ? viewportWidth : viewportHeight) - sideOffset,\r\n\t\t\toffset = myLength - (my.precedance === side || mySide === my[otherSide] ? atLength : 0) - (atSide === CENTER ? targetLength / 2 : 0);\r\n\r\n\t\t// shift\r\n\t\tif(isShift) {\r\n\t\t\toffset = (mySide === side1 ? 1 : -1) * myLength;\r\n\r\n\t\t\t// Adjust position but keep it within viewport dimensions\r\n\t\t\tposition[side1] += overflow1 > 0 ? overflow1 : overflow2 > 0 ? -overflow2 : 0;\r\n\t\t\tposition[side1] = Math.max(\r\n\t\t\t\t-containerOffset[side1] + viewportOffset[side1],\r\n\t\t\t\tinitialPos - offset,\r\n\t\t\t\tMath.min(\r\n\t\t\t\t\tMath.max(\r\n\t\t\t\t\t\t-containerOffset[side1] + viewportOffset[side1] + (lengthName === WIDTH ? viewportWidth : viewportHeight),\r\n\t\t\t\t\t\tinitialPos + offset\r\n\t\t\t\t\t),\r\n\t\t\t\t\tposition[side1],\r\n\r\n\t\t\t\t\t// Make sure we don't adjust complete off the element when using 'center'\r\n\t\t\t\t\tmySide === 'center' ? initialPos - myLength : 1E9\r\n\t\t\t\t)\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\t// flip/flipinvert\r\n\t\telse {\r\n\t\t\t// Update adjustment amount depending on if using flipinvert or flip\r\n\t\t\tadjustment *= type === FLIPINVERT ? 2 : 0;\r\n\r\n\t\t\t// Check for overflow on the left/top\r\n\t\t\tif(overflow1 > 0 && (mySide !== side1 || overflow2 > 0)) {\r\n\t\t\t\tposition[side1] -= offset + adjustment;\r\n\t\t\t\tnewMy.invert(side, side1);\r\n\t\t\t}\r\n\r\n\t\t\t// Check for overflow on the bottom/right\r\n\t\t\telse if(overflow2 > 0 && (mySide !== side2 || overflow1 > 0)  ) {\r\n\t\t\t\tposition[side1] -= (mySide === CENTER ? -offset : offset) + adjustment;\r\n\t\t\t\tnewMy.invert(side, side2);\r\n\t\t\t}\r\n\r\n\t\t\t// Make sure we haven't made things worse with the adjustment and reset if so\r\n\t\t\tif(position[side1] < viewportScroll[side1] && -position[side1] > overflow2) {\r\n\t\t\t\tposition[side1] = initialPos; newMy = my.clone();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn position[side1] - initialPos;\r\n\t}\r\n\r\n\t// Set newMy if using flip or flipinvert methods\r\n\tif(methodX !== 'shift' || methodY !== 'shift') { newMy = my.clone(); }\r\n\r\n\t// Adjust position based onviewport and adjustment options\r\n\tadjusted = {\r\n\t\tleft: methodX !== 'none' ? calculate( X, Y, methodX, adjust.x, LEFT, RIGHT, WIDTH, targetWidth, elemWidth ) : 0,\r\n\t\ttop: methodY !== 'none' ? calculate( Y, X, methodY, adjust.y, TOP, BOTTOM, HEIGHT, targetHeight, elemHeight ) : 0,\r\n\t\tmy: newMy\r\n\t};\r\n\r\n\treturn adjusted;\r\n};\r\n;PLUGINS.polys = {\r\n\t// POLY area coordinate calculator\r\n\t//\tSpecial thanks to Ed Cradock for helping out with this.\r\n\t//\tUses a binary search algorithm to find suitable coordinates.\r\n\tpolygon: function(baseCoords, corner) {\r\n\t\tvar result = {\r\n\t\t\twidth: 0, height: 0,\r\n\t\t\tposition: {\r\n\t\t\t\ttop: 1e10, right: 0,\r\n\t\t\t\tbottom: 0, left: 1e10\r\n\t\t\t},\r\n\t\t\tadjustable: FALSE\r\n\t\t},\r\n\t\ti = 0, next,\r\n\t\tcoords = [],\r\n\t\tcompareX = 1, compareY = 1,\r\n\t\trealX = 0, realY = 0,\r\n\t\tnewWidth, newHeight;\r\n\r\n\t\t// First pass, sanitize coords and determine outer edges\r\n\t\ti = baseCoords.length; \r\n\t\twhile(i--) {\r\n\t\t\tnext = [ parseInt(baseCoords[--i], 10), parseInt(baseCoords[i+1], 10) ];\r\n\r\n\t\t\tif(next[0] > result.position.right){ result.position.right = next[0]; }\r\n\t\t\tif(next[0] < result.position.left){ result.position.left = next[0]; }\r\n\t\t\tif(next[1] > result.position.bottom){ result.position.bottom = next[1]; }\r\n\t\t\tif(next[1] < result.position.top){ result.position.top = next[1]; }\r\n\r\n\t\t\tcoords.push(next);\r\n\t\t}\r\n\r\n\t\t// Calculate height and width from outer edges\r\n\t\tnewWidth = result.width = Math.abs(result.position.right - result.position.left);\r\n\t\tnewHeight = result.height = Math.abs(result.position.bottom - result.position.top);\r\n\r\n\t\t// If it's the center corner...\r\n\t\tif(corner.abbrev() === 'c') {\r\n\t\t\tresult.position = {\r\n\t\t\t\tleft: result.position.left + result.width / 2,\r\n\t\t\t\ttop: result.position.top + result.height / 2\r\n\t\t\t};\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Second pass, use a binary search algorithm to locate most suitable coordinate\r\n\t\t\twhile(newWidth > 0 && newHeight > 0 && compareX > 0 && compareY > 0)\r\n\t\t\t{\r\n\t\t\t\tnewWidth = Math.floor(newWidth / 2);\r\n\t\t\t\tnewHeight = Math.floor(newHeight / 2);\r\n\r\n\t\t\t\tif(corner.x === LEFT){ compareX = newWidth; }\r\n\t\t\t\telse if(corner.x === RIGHT){ compareX = result.width - newWidth; }\r\n\t\t\t\telse{ compareX += Math.floor(newWidth / 2); }\r\n\r\n\t\t\t\tif(corner.y === TOP){ compareY = newHeight; }\r\n\t\t\t\telse if(corner.y === BOTTOM){ compareY = result.height - newHeight; }\r\n\t\t\t\telse{ compareY += Math.floor(newHeight / 2); }\r\n\r\n\t\t\t\ti = coords.length;\r\n\t\t\t\twhile(i--)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(coords.length < 2){ break; }\r\n\r\n\t\t\t\t\trealX = coords[i][0] - result.position.left;\r\n\t\t\t\t\trealY = coords[i][1] - result.position.top;\r\n\r\n\t\t\t\t\tif(\r\n\t\t\t\t\t\tcorner.x === LEFT && realX >= compareX ||\r\n\t\t\t\t\t\tcorner.x === RIGHT && realX <= compareX ||\r\n\t\t\t\t\t\tcorner.x === CENTER && (realX < compareX || realX > result.width - compareX) ||\r\n\t\t\t\t\t\tcorner.y === TOP && realY >= compareY ||\r\n\t\t\t\t\t\tcorner.y === BOTTOM && realY <= compareY ||\r\n\t\t\t\t\t\tcorner.y === CENTER && (realY < compareY || realY > result.height - compareY)) {\r\n\t\t\t\t\t\tcoords.splice(i, 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresult.position = { left: coords[0][0], top: coords[0][1] };\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t},\r\n\r\n\trect: function(ax, ay, bx, by) {\r\n\t\treturn {\r\n\t\t\twidth: Math.abs(bx - ax),\r\n\t\t\theight: Math.abs(by - ay),\r\n\t\t\tposition: {\r\n\t\t\t\tleft: Math.min(ax, bx),\r\n\t\t\t\ttop: Math.min(ay, by)\r\n\t\t\t}\r\n\t\t};\r\n\t},\r\n\r\n\t_angles: {\r\n\t\ttc: 3 / 2, tr: 7 / 4, tl: 5 / 4,\r\n\t\tbc: 1 / 2, br: 1 / 4, bl: 3 / 4,\r\n\t\trc: 2, lc: 1, c: 0\r\n\t},\r\n\tellipse: function(cx, cy, rx, ry, corner) {\r\n\t\tvar c = PLUGINS.polys._angles[ corner.abbrev() ],\r\n\t\t\trxc = c === 0 ? 0 : rx * Math.cos( c * Math.PI ),\r\n\t\t\trys = ry * Math.sin( c * Math.PI );\r\n\r\n\t\treturn {\r\n\t\t\twidth: rx * 2 - Math.abs(rxc),\r\n\t\t\theight: ry * 2 - Math.abs(rys),\r\n\t\t\tposition: {\r\n\t\t\t\tleft: cx + rxc,\r\n\t\t\t\ttop: cy + rys\r\n\t\t\t},\r\n\t\t\tadjustable: FALSE\r\n\t\t};\r\n\t},\r\n\tcircle: function(cx, cy, r, corner) {\r\n\t\treturn PLUGINS.polys.ellipse(cx, cy, r, r, corner);\r\n\t}\r\n};\r\n;PLUGINS.svg = function(api, svg, corner)\r\n{\r\n\tvar elem = svg[0],\r\n\t\troot = $(elem.ownerSVGElement),\r\n\t\townerDocument = elem.ownerDocument,\r\n\t\tstrokeWidth2 = (parseInt(svg.css('stroke-width'), 10) || 0) / 2,\r\n\t\tframeOffset, mtx, transformed,\r\n\t\tlen, next, i, points,\r\n\t\tresult, position;\r\n\r\n\t// Ascend the parentNode chain until we find an element with getBBox()\r\n\twhile(!elem.getBBox) { elem = elem.parentNode; }\r\n\tif(!elem.getBBox || !elem.parentNode) { return FALSE; }\r\n\r\n\t// Determine which shape calculation to use\r\n\tswitch(elem.nodeName) {\r\n\t\tcase 'ellipse':\r\n\t\tcase 'circle':\r\n\t\t\tresult = PLUGINS.polys.ellipse(\r\n\t\t\t\telem.cx.baseVal.value,\r\n\t\t\t\telem.cy.baseVal.value,\r\n\t\t\t\t(elem.rx || elem.r).baseVal.value + strokeWidth2,\r\n\t\t\t\t(elem.ry || elem.r).baseVal.value + strokeWidth2,\r\n\t\t\t\tcorner\r\n\t\t\t);\r\n\t\tbreak;\r\n\r\n\t\tcase 'line':\r\n\t\tcase 'polygon':\r\n\t\tcase 'polyline':\r\n\t\t\t// Determine points object (line has none, so mimic using array)\r\n\t\t\tpoints = elem.points || [\r\n\t\t\t\t{ x: elem.x1.baseVal.value, y: elem.y1.baseVal.value },\r\n\t\t\t\t{ x: elem.x2.baseVal.value, y: elem.y2.baseVal.value }\r\n\t\t\t];\r\n\r\n\t\t\tfor(result = [], i = -1, len = points.numberOfItems || points.length; ++i < len;) {\r\n\t\t\t\tnext = points.getItem ? points.getItem(i) : points[i];\r\n\t\t\t\tresult.push.apply(result, [next.x, next.y]);\r\n\t\t\t}\r\n\r\n\t\t\tresult = PLUGINS.polys.polygon(result, corner);\r\n\t\tbreak;\r\n\r\n\t\t// Unknown shape or rectangle? Use bounding box\r\n\t\tdefault:\r\n\t\t\tresult = elem.getBBox();\r\n\t\t\tresult = {\r\n\t\t\t\twidth: result.width,\r\n\t\t\t\theight: result.height,\r\n\t\t\t\tposition: {\r\n\t\t\t\t\tleft: result.x,\r\n\t\t\t\t\ttop: result.y\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\tbreak;\r\n\t}\r\n\r\n\t// Shortcut assignments\r\n\tposition = result.position;\r\n\troot = root[0];\r\n\r\n\t// Convert position into a pixel value\r\n\tif(root.createSVGPoint) {\r\n\t\tmtx = elem.getScreenCTM();\r\n\t\tpoints = root.createSVGPoint();\r\n\r\n\t\tpoints.x = position.left;\r\n\t\tpoints.y = position.top;\r\n\t\ttransformed = points.matrixTransform( mtx );\r\n\t\tposition.left = transformed.x;\r\n\t\tposition.top = transformed.y;\r\n\t}\r\n\r\n\t// Check the element is not in a child document, and if so, adjust for frame elements offset\r\n\tif(ownerDocument !== document && api.position.target !== 'mouse') {\r\n\t\tframeOffset = $((ownerDocument.defaultView || ownerDocument.parentWindow).frameElement).offset();\r\n\t\tif(frameOffset) {\r\n\t\t\tposition.left += frameOffset.left;\r\n\t\t\tposition.top += frameOffset.top;\r\n\t\t}\r\n\t}\r\n\r\n\t// Adjust by scroll offset of owner document\r\n\townerDocument = $(ownerDocument);\r\n\tposition.left += ownerDocument.scrollLeft();\r\n\tposition.top += ownerDocument.scrollTop();\r\n\r\n\treturn result;\r\n};\r\n;PLUGINS.imagemap = function(api, area, corner)\r\n{\r\n\tif(!area.jquery) { area = $(area); }\r\n\r\n\tvar shape = (area.attr('shape') || 'rect').toLowerCase().replace('poly', 'polygon'),\r\n\t\timage = $('img[usemap=\"#'+area.parent('map').attr('name')+'\"]'),\r\n\t\tcoordsString = $.trim(area.attr('coords')),\r\n\t\tcoordsArray = coordsString.replace(/,$/, '').split(','),\r\n\t\timageOffset, coords, i, result, len;\r\n\r\n\t// If we can't find the image using the map...\r\n\tif(!image.length) { return FALSE; }\r\n\r\n\t// Pass coordinates string if polygon\r\n\tif(shape === 'polygon') {\r\n\t\tresult = PLUGINS.polys.polygon(coordsArray, corner);\r\n\t}\r\n\r\n\t// Otherwise parse the coordinates and pass them as arguments\r\n\telse if(PLUGINS.polys[shape]) {\r\n\t\tfor(i = -1, len = coordsArray.length, coords = []; ++i < len;) {\r\n\t\t\tcoords.push( parseInt(coordsArray[i], 10) );\r\n\t\t}\r\n\r\n\t\tresult = PLUGINS.polys[shape].apply(\r\n\t\t\tthis, coords.concat(corner)\r\n\t\t);\r\n\t}\r\n\r\n\t// If no shapre calculation method was found, return false\r\n\telse { return FALSE; }\r\n\r\n\t// Make sure we account for padding and borders on the image\r\n\timageOffset = image.offset();\r\n\timageOffset.left += Math.ceil((image.outerWidth(FALSE) - image.width()) / 2);\r\n\timageOffset.top += Math.ceil((image.outerHeight(FALSE) - image.height()) / 2);\r\n\r\n\t// Add image position to offset coordinates\r\n\tresult.position.left += imageOffset.left;\r\n\tresult.position.top += imageOffset.top;\r\n\r\n\treturn result;\r\n};\r\n;var IE6,\r\n\r\n/*\r\n * BGIFrame adaption (http://plugins.jquery.com/project/bgiframe)\r\n * Special thanks to Brandon Aaron\r\n */\r\nBGIFRAME = '<iframe class=\"qtip-bgiframe\" frameborder=\"0\" tabindex=\"-1\" src=\"javascript:\\'\\';\" ' +\r\n\t' style=\"display:block; position:absolute; z-index:-1; filter:alpha(opacity=0); ' +\r\n\t\t'-ms-filter:\"progid:DXImageTransform.Microsoft.Alpha(Opacity=0)\";\"></iframe>';\r\n\r\nfunction Ie6(api) {\r\n\tthis._ns = 'ie6';\r\n\r\n\tthis.qtip = api;\r\n\tthis.init(api);\r\n}\r\n\r\n$.extend(Ie6.prototype, {\r\n\t_scroll : function() {\r\n\t\tvar overlay = this.qtip.elements.overlay;\r\n\t\toverlay && (overlay[0].style.top = $(window).scrollTop() + 'px');\r\n\t},\r\n\r\n\tinit: function(qtip) {\r\n\t\tvar tooltip = qtip.tooltip;\r\n\r\n\t\t// Create the BGIFrame element if needed\r\n\t\tif($('select, object').length < 1) {\r\n\t\t\tthis.bgiframe = qtip.elements.bgiframe = $(BGIFRAME).appendTo(tooltip);\r\n\r\n\t\t\t// Update BGIFrame on tooltip move\r\n\t\t\tqtip._bind(tooltip, 'tooltipmove', this.adjustBGIFrame, this._ns, this);\r\n\t\t}\r\n\r\n\t\t// redraw() container for width/height calculations\r\n\t\tthis.redrawContainer = $('<div/>', { id: NAMESPACE+'-rcontainer' })\r\n\t\t\t.appendTo(document.body);\r\n\r\n\t\t// Fixup modal plugin if present too\r\n\t\tif( qtip.elements.overlay && qtip.elements.overlay.addClass('qtipmodal-ie6fix') ) {\r\n\t\t\tqtip._bind(window, ['scroll', 'resize'], this._scroll, this._ns, this);\r\n\t\t\tqtip._bind(tooltip, ['tooltipshow'], this._scroll, this._ns, this);\r\n\t\t}\r\n\r\n\t\t// Set dimensions\r\n\t\tthis.redraw();\r\n\t},\r\n\r\n\tadjustBGIFrame: function() {\r\n\t\tvar tooltip = this.qtip.tooltip,\r\n\t\t\tdimensions = {\r\n\t\t\t\theight: tooltip.outerHeight(FALSE),\r\n\t\t\t\twidth: tooltip.outerWidth(FALSE)\r\n\t\t\t},\r\n\t\t\tplugin = this.qtip.plugins.tip,\r\n\t\t\ttip = this.qtip.elements.tip,\r\n\t\t\ttipAdjust, offset;\r\n\r\n\t\t// Adjust border offset\r\n\t\toffset = parseInt(tooltip.css('borderLeftWidth'), 10) || 0;\r\n\t\toffset = { left: -offset, top: -offset };\r\n\r\n\t\t// Adjust for tips plugin\r\n\t\tif(plugin && tip) {\r\n\t\t\ttipAdjust = plugin.corner.precedance === 'x' ? [WIDTH, LEFT] : [HEIGHT, TOP];\r\n\t\t\toffset[ tipAdjust[1] ] -= tip[ tipAdjust[0] ]();\r\n\t\t}\r\n\r\n\t\t// Update bgiframe\r\n\t\tthis.bgiframe.css(offset).css(dimensions);\r\n\t},\r\n\r\n\t// Max/min width simulator function\r\n\tredraw: function() {\r\n\t\tif(this.qtip.rendered < 1 || this.drawing) { return this; }\r\n\r\n\t\tvar tooltip = this.qtip.tooltip,\r\n\t\t\tstyle = this.qtip.options.style,\r\n\t\t\tcontainer = this.qtip.options.position.container,\r\n\t\t\tperc, width, max, min;\r\n\r\n\t\t// Set drawing flag\r\n\t\tthis.qtip.drawing = 1;\r\n\r\n\t\t// If tooltip has a set height/width, just set it... like a boss!\r\n\t\tif(style.height) { tooltip.css(HEIGHT, style.height); }\r\n\t\tif(style.width) { tooltip.css(WIDTH, style.width); }\r\n\r\n\t\t// Simulate max/min width if not set width present...\r\n\t\telse {\r\n\t\t\t// Reset width and add fluid class\r\n\t\t\ttooltip.css(WIDTH, '').appendTo(this.redrawContainer);\r\n\r\n\t\t\t// Grab our tooltip width (add 1 if odd so we don't get wrapping problems.. huzzah!)\r\n\t\t\twidth = tooltip.width();\r\n\t\t\tif(width % 2 < 1) { width += 1; }\r\n\r\n\t\t\t// Grab our max/min properties\r\n\t\t\tmax = tooltip.css('maxWidth') || '';\r\n\t\t\tmin = tooltip.css('minWidth') || '';\r\n\r\n\t\t\t// Parse into proper pixel values\r\n\t\t\tperc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;\r\n\t\t\tmax = (max.indexOf('%') > -1 ? perc : 1 * parseInt(max, 10)) || width;\r\n\t\t\tmin = (min.indexOf('%') > -1 ? perc : 1 * parseInt(min, 10)) || 0;\r\n\r\n\t\t\t// Determine new dimension size based on max/min/current values\r\n\t\t\twidth = max + min ? Math.min(Math.max(width, min), max) : width;\r\n\r\n\t\t\t// Set the newly calculated width and remvoe fluid class\r\n\t\t\ttooltip.css(WIDTH, Math.round(width)).appendTo(container);\r\n\t\t}\r\n\r\n\t\t// Set drawing flag\r\n\t\tthis.drawing = 0;\r\n\r\n\t\treturn this;\r\n\t},\r\n\r\n\tdestroy: function() {\r\n\t\t// Remove iframe\r\n\t\tthis.bgiframe && this.bgiframe.remove();\r\n\r\n\t\t// Remove bound events\r\n\t\tthis.qtip._unbind([window, this.qtip.tooltip], this._ns);\r\n\t}\r\n});\r\n\r\nIE6 = PLUGINS.ie6 = function(api) {\r\n\t// Proceed only if the browser is IE6\r\n\treturn BROWSER.ie === 6 ? new Ie6(api) : FALSE;\r\n};\r\n\r\nIE6.initialize = 'render';\r\n\r\nCHECKS.ie6 = {\r\n\t'^content|style$': function() {\r\n\t\tthis.redraw();\r\n\t}\r\n};\r\n;}));\r\n}( window, document ));\r\n","/*!\n * clipboard.js v2.0.8\n * https://clipboardjs.com/\n *\n * Licensed MIT © Zeno Rocha\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ClipboardJS\"] = factory();\n\telse\n\t\troot[\"ClipboardJS\"] = factory();\n})(this, function() {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 134:\n/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": function() { return /* binding */ clipboard; }\n});\n\n// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js\nvar tiny_emitter = __webpack_require__(279);\nvar tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);\n// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js\nvar listen = __webpack_require__(370);\nvar listen_default = /*#__PURE__*/__webpack_require__.n(listen);\n// EXTERNAL MODULE: ./node_modules/select/src/select.js\nvar src_select = __webpack_require__(817);\nvar select_default = /*#__PURE__*/__webpack_require__.n(src_select);\n;// CONCATENATED MODULE: ./src/clipboard-action.js\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n/**\n * Inner class which performs selection from either `text` or `target`\n * properties and then executes copy or cut operations.\n */\n\nvar ClipboardAction = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options\n   */\n  function ClipboardAction(options) {\n    _classCallCheck(this, ClipboardAction);\n\n    this.resolveOptions(options);\n    this.initSelection();\n  }\n  /**\n   * Defines base properties passed from constructor.\n   * @param {Object} options\n   */\n\n\n  _createClass(ClipboardAction, [{\n    key: \"resolveOptions\",\n    value: function resolveOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.action = options.action;\n      this.container = options.container;\n      this.emitter = options.emitter;\n      this.target = options.target;\n      this.text = options.text;\n      this.trigger = options.trigger;\n      this.selectedText = '';\n    }\n    /**\n     * Decides which selection strategy is going to be applied based\n     * on the existence of `text` and `target` properties.\n     */\n\n  }, {\n    key: \"initSelection\",\n    value: function initSelection() {\n      if (this.text) {\n        this.selectFake();\n      } else if (this.target) {\n        this.selectTarget();\n      }\n    }\n    /**\n     * Creates a fake textarea element, sets its value from `text` property,\n     */\n\n  }, {\n    key: \"createFakeElement\",\n    value: function createFakeElement() {\n      var isRTL = document.documentElement.getAttribute('dir') === 'rtl';\n      this.fakeElem = document.createElement('textarea'); // Prevent zooming on iOS\n\n      this.fakeElem.style.fontSize = '12pt'; // Reset box model\n\n      this.fakeElem.style.border = '0';\n      this.fakeElem.style.padding = '0';\n      this.fakeElem.style.margin = '0'; // Move element out of screen horizontally\n\n      this.fakeElem.style.position = 'absolute';\n      this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically\n\n      var yPosition = window.pageYOffset || document.documentElement.scrollTop;\n      this.fakeElem.style.top = \"\".concat(yPosition, \"px\");\n      this.fakeElem.setAttribute('readonly', '');\n      this.fakeElem.value = this.text;\n      return this.fakeElem;\n    }\n    /**\n     * Get's the value of fakeElem,\n     * and makes a selection on it.\n     */\n\n  }, {\n    key: \"selectFake\",\n    value: function selectFake() {\n      var _this = this;\n\n      var fakeElem = this.createFakeElement();\n\n      this.fakeHandlerCallback = function () {\n        return _this.removeFake();\n      };\n\n      this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;\n      this.container.appendChild(fakeElem);\n      this.selectedText = select_default()(fakeElem);\n      this.copyText();\n      this.removeFake();\n    }\n    /**\n     * Only removes the fake element after another click event, that way\n     * a user can hit `Ctrl+C` to copy because selection still exists.\n     */\n\n  }, {\n    key: \"removeFake\",\n    value: function removeFake() {\n      if (this.fakeHandler) {\n        this.container.removeEventListener('click', this.fakeHandlerCallback);\n        this.fakeHandler = null;\n        this.fakeHandlerCallback = null;\n      }\n\n      if (this.fakeElem) {\n        this.container.removeChild(this.fakeElem);\n        this.fakeElem = null;\n      }\n    }\n    /**\n     * Selects the content from element passed on `target` property.\n     */\n\n  }, {\n    key: \"selectTarget\",\n    value: function selectTarget() {\n      this.selectedText = select_default()(this.target);\n      this.copyText();\n    }\n    /**\n     * Executes the copy operation based on the current selection.\n     */\n\n  }, {\n    key: \"copyText\",\n    value: function copyText() {\n      var succeeded;\n\n      try {\n        succeeded = document.execCommand(this.action);\n      } catch (err) {\n        succeeded = false;\n      }\n\n      this.handleResult(succeeded);\n    }\n    /**\n     * Fires an event based on the copy operation result.\n     * @param {Boolean} succeeded\n     */\n\n  }, {\n    key: \"handleResult\",\n    value: function handleResult(succeeded) {\n      this.emitter.emit(succeeded ? 'success' : 'error', {\n        action: this.action,\n        text: this.selectedText,\n        trigger: this.trigger,\n        clearSelection: this.clearSelection.bind(this)\n      });\n    }\n    /**\n     * Moves focus away from `target` and back to the trigger, removes current selection.\n     */\n\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (this.trigger) {\n        this.trigger.focus();\n      }\n\n      document.activeElement.blur();\n      window.getSelection().removeAllRanges();\n    }\n    /**\n     * Sets the `action` to be performed which can be either 'copy' or 'cut'.\n     * @param {String} action\n     */\n\n  }, {\n    key: \"destroy\",\n\n    /**\n     * Destroy lifecycle.\n     */\n    value: function destroy() {\n      this.removeFake();\n    }\n  }, {\n    key: \"action\",\n    set: function set() {\n      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';\n      this._action = action;\n\n      if (this._action !== 'copy' && this._action !== 'cut') {\n        throw new Error('Invalid \"action\" value, use either \"copy\" or \"cut\"');\n      }\n    }\n    /**\n     * Gets the `action` property.\n     * @return {String}\n     */\n    ,\n    get: function get() {\n      return this._action;\n    }\n    /**\n     * Sets the `target` property using an element\n     * that will be have its content copied.\n     * @param {Element} target\n     */\n\n  }, {\n    key: \"target\",\n    set: function set(target) {\n      if (target !== undefined) {\n        if (target && _typeof(target) === 'object' && target.nodeType === 1) {\n          if (this.action === 'copy' && target.hasAttribute('disabled')) {\n            throw new Error('Invalid \"target\" attribute. Please use \"readonly\" instead of \"disabled\" attribute');\n          }\n\n          if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {\n            throw new Error('Invalid \"target\" attribute. You can\\'t cut text from elements with \"readonly\" or \"disabled\" attributes');\n          }\n\n          this._target = target;\n        } else {\n          throw new Error('Invalid \"target\" value, use a valid Element');\n        }\n      }\n    }\n    /**\n     * Gets the `target` property.\n     * @return {String|HTMLElement}\n     */\n    ,\n    get: function get() {\n      return this._target;\n    }\n  }]);\n\n  return ClipboardAction;\n}();\n\n/* harmony default export */ var clipboard_action = (ClipboardAction);\n;// CONCATENATED MODULE: ./src/clipboard.js\nfunction clipboard_typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return clipboard_typeof(obj); }\n\nfunction clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction clipboard_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction clipboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) clipboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) clipboard_defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n\n\n\n/**\n * Helper function to retrieve attribute value.\n * @param {String} suffix\n * @param {Element} element\n */\n\nfunction getAttributeValue(suffix, element) {\n  var attribute = \"data-clipboard-\".concat(suffix);\n\n  if (!element.hasAttribute(attribute)) {\n    return;\n  }\n\n  return element.getAttribute(attribute);\n}\n/**\n * Base class which takes one or more elements, adds event listeners to them,\n * and instantiates a new `ClipboardAction` on each click.\n */\n\n\nvar Clipboard = /*#__PURE__*/function (_Emitter) {\n  _inherits(Clipboard, _Emitter);\n\n  var _super = _createSuper(Clipboard);\n\n  /**\n   * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n   * @param {Object} options\n   */\n  function Clipboard(trigger, options) {\n    var _this;\n\n    clipboard_classCallCheck(this, Clipboard);\n\n    _this = _super.call(this);\n\n    _this.resolveOptions(options);\n\n    _this.listenClick(trigger);\n\n    return _this;\n  }\n  /**\n   * Defines if attributes would be resolved using internal setter functions\n   * or custom functions that were passed in the constructor.\n   * @param {Object} options\n   */\n\n\n  clipboard_createClass(Clipboard, [{\n    key: \"resolveOptions\",\n    value: function resolveOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.action = typeof options.action === 'function' ? options.action : this.defaultAction;\n      this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;\n      this.text = typeof options.text === 'function' ? options.text : this.defaultText;\n      this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;\n    }\n    /**\n     * Adds a click event listener to the passed trigger.\n     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger\n     */\n\n  }, {\n    key: \"listenClick\",\n    value: function listenClick(trigger) {\n      var _this2 = this;\n\n      this.listener = listen_default()(trigger, 'click', function (e) {\n        return _this2.onClick(e);\n      });\n    }\n    /**\n     * Defines a new `ClipboardAction` on each click event.\n     * @param {Event} e\n     */\n\n  }, {\n    key: \"onClick\",\n    value: function onClick(e) {\n      var trigger = e.delegateTarget || e.currentTarget;\n\n      if (this.clipboardAction) {\n        this.clipboardAction = null;\n      }\n\n      this.clipboardAction = new clipboard_action({\n        action: this.action(trigger),\n        target: this.target(trigger),\n        text: this.text(trigger),\n        container: this.container,\n        trigger: trigger,\n        emitter: this\n      });\n    }\n    /**\n     * Default `action` lookup function.\n     * @param {Element} trigger\n     */\n\n  }, {\n    key: \"defaultAction\",\n    value: function defaultAction(trigger) {\n      return getAttributeValue('action', trigger);\n    }\n    /**\n     * Default `target` lookup function.\n     * @param {Element} trigger\n     */\n\n  }, {\n    key: \"defaultTarget\",\n    value: function defaultTarget(trigger) {\n      var selector = getAttributeValue('target', trigger);\n\n      if (selector) {\n        return document.querySelector(selector);\n      }\n    }\n    /**\n     * Returns the support of the given action, or all actions if no action is\n     * given.\n     * @param {String} [action]\n     */\n\n  }, {\n    key: \"defaultText\",\n\n    /**\n     * Default `text` lookup function.\n     * @param {Element} trigger\n     */\n    value: function defaultText(trigger) {\n      return getAttributeValue('text', trigger);\n    }\n    /**\n     * Destroy lifecycle.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.listener.destroy();\n\n      if (this.clipboardAction) {\n        this.clipboardAction.destroy();\n        this.clipboardAction = null;\n      }\n    }\n  }], [{\n    key: \"isSupported\",\n    value: function isSupported() {\n      var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];\n      var actions = typeof action === 'string' ? [action] : action;\n      var support = !!document.queryCommandSupported;\n      actions.forEach(function (action) {\n        support = support && !!document.queryCommandSupported(action);\n      });\n      return support;\n    }\n  }]);\n\n  return Clipboard;\n}((tiny_emitter_default()));\n\n/* harmony default export */ var clipboard = (Clipboard);\n\n/***/ }),\n\n/***/ 828:\n/***/ (function(module) {\n\nvar DOCUMENT_NODE_TYPE = 9;\n\n/**\n * A polyfill for Element.matches()\n */\nif (typeof Element !== 'undefined' && !Element.prototype.matches) {\n    var proto = Element.prototype;\n\n    proto.matches = proto.matchesSelector ||\n                    proto.mozMatchesSelector ||\n                    proto.msMatchesSelector ||\n                    proto.oMatchesSelector ||\n                    proto.webkitMatchesSelector;\n}\n\n/**\n * Finds the closest parent that matches a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @return {Function}\n */\nfunction closest (element, selector) {\n    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {\n        if (typeof element.matches === 'function' &&\n            element.matches(selector)) {\n          return element;\n        }\n        element = element.parentNode;\n    }\n}\n\nmodule.exports = closest;\n\n\n/***/ }),\n\n/***/ 438:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar closest = __webpack_require__(828);\n\n/**\n * Delegates event to a selector.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */\nfunction _delegate(element, selector, type, callback, useCapture) {\n    var listenerFn = listener.apply(this, arguments);\n\n    element.addEventListener(type, listenerFn, useCapture);\n\n    return {\n        destroy: function() {\n            element.removeEventListener(type, listenerFn, useCapture);\n        }\n    }\n}\n\n/**\n * Delegates event to a selector.\n *\n * @param {Element|String|Array} [elements]\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @param {Boolean} useCapture\n * @return {Object}\n */\nfunction delegate(elements, selector, type, callback, useCapture) {\n    // Handle the regular Element usage\n    if (typeof elements.addEventListener === 'function') {\n        return _delegate.apply(null, arguments);\n    }\n\n    // Handle Element-less usage, it defaults to global delegation\n    if (typeof type === 'function') {\n        // Use `document` as the first parameter, then apply arguments\n        // This is a short way to .unshift `arguments` without running into deoptimizations\n        return _delegate.bind(null, document).apply(null, arguments);\n    }\n\n    // Handle Selector-based usage\n    if (typeof elements === 'string') {\n        elements = document.querySelectorAll(elements);\n    }\n\n    // Handle Array-like based usage\n    return Array.prototype.map.call(elements, function (element) {\n        return _delegate(element, selector, type, callback, useCapture);\n    });\n}\n\n/**\n * Finds closest match and invokes callback.\n *\n * @param {Element} element\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Function}\n */\nfunction listener(element, selector, type, callback) {\n    return function(e) {\n        e.delegateTarget = closest(e.target, selector);\n\n        if (e.delegateTarget) {\n            callback.call(element, e);\n        }\n    }\n}\n\nmodule.exports = delegate;\n\n\n/***/ }),\n\n/***/ 879:\n/***/ (function(__unused_webpack_module, exports) {\n\n/**\n * Check if argument is a HTML element.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.node = function(value) {\n    return value !== undefined\n        && value instanceof HTMLElement\n        && value.nodeType === 1;\n};\n\n/**\n * Check if argument is a list of HTML elements.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.nodeList = function(value) {\n    var type = Object.prototype.toString.call(value);\n\n    return value !== undefined\n        && (type === '[object NodeList]' || type === '[object HTMLCollection]')\n        && ('length' in value)\n        && (value.length === 0 || exports.node(value[0]));\n};\n\n/**\n * Check if argument is a string.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.string = function(value) {\n    return typeof value === 'string'\n        || value instanceof String;\n};\n\n/**\n * Check if argument is a function.\n *\n * @param {Object} value\n * @return {Boolean}\n */\nexports.fn = function(value) {\n    var type = Object.prototype.toString.call(value);\n\n    return type === '[object Function]';\n};\n\n\n/***/ }),\n\n/***/ 370:\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\nvar is = __webpack_require__(879);\nvar delegate = __webpack_require__(438);\n\n/**\n * Validates all params and calls the right\n * listener function based on its target type.\n *\n * @param {String|HTMLElement|HTMLCollection|NodeList} target\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listen(target, type, callback) {\n    if (!target && !type && !callback) {\n        throw new Error('Missing required arguments');\n    }\n\n    if (!is.string(type)) {\n        throw new TypeError('Second argument must be a String');\n    }\n\n    if (!is.fn(callback)) {\n        throw new TypeError('Third argument must be a Function');\n    }\n\n    if (is.node(target)) {\n        return listenNode(target, type, callback);\n    }\n    else if (is.nodeList(target)) {\n        return listenNodeList(target, type, callback);\n    }\n    else if (is.string(target)) {\n        return listenSelector(target, type, callback);\n    }\n    else {\n        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');\n    }\n}\n\n/**\n * Adds an event listener to a HTML element\n * and returns a remove listener function.\n *\n * @param {HTMLElement} node\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenNode(node, type, callback) {\n    node.addEventListener(type, callback);\n\n    return {\n        destroy: function() {\n            node.removeEventListener(type, callback);\n        }\n    }\n}\n\n/**\n * Add an event listener to a list of HTML elements\n * and returns a remove listener function.\n *\n * @param {NodeList|HTMLCollection} nodeList\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenNodeList(nodeList, type, callback) {\n    Array.prototype.forEach.call(nodeList, function(node) {\n        node.addEventListener(type, callback);\n    });\n\n    return {\n        destroy: function() {\n            Array.prototype.forEach.call(nodeList, function(node) {\n                node.removeEventListener(type, callback);\n            });\n        }\n    }\n}\n\n/**\n * Add an event listener to a selector\n * and returns a remove listener function.\n *\n * @param {String} selector\n * @param {String} type\n * @param {Function} callback\n * @return {Object}\n */\nfunction listenSelector(selector, type, callback) {\n    return delegate(document.body, selector, type, callback);\n}\n\nmodule.exports = listen;\n\n\n/***/ }),\n\n/***/ 817:\n/***/ (function(module) {\n\nfunction select(element) {\n    var selectedText;\n\n    if (element.nodeName === 'SELECT') {\n        element.focus();\n\n        selectedText = element.value;\n    }\n    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {\n        var isReadOnly = element.hasAttribute('readonly');\n\n        if (!isReadOnly) {\n            element.setAttribute('readonly', '');\n        }\n\n        element.select();\n        element.setSelectionRange(0, element.value.length);\n\n        if (!isReadOnly) {\n            element.removeAttribute('readonly');\n        }\n\n        selectedText = element.value;\n    }\n    else {\n        if (element.hasAttribute('contenteditable')) {\n            element.focus();\n        }\n\n        var selection = window.getSelection();\n        var range = document.createRange();\n\n        range.selectNodeContents(element);\n        selection.removeAllRanges();\n        selection.addRange(range);\n\n        selectedText = selection.toString();\n    }\n\n    return selectedText;\n}\n\nmodule.exports = select;\n\n\n/***/ }),\n\n/***/ 279:\n/***/ (function(module) {\n\nfunction E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t!function() {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = function(module) {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\tfunction() { return module['default']; } :\n/******/ \t\t\t\tfunction() { return module; };\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(134);\n/******/ })()\n.default;\n});","/*!\nSlimbox v2.04 - The ultimate lightweight Lightbox clone for jQuery\n(c) 2007-2010 Christophe Beyls <http://www.digitalia.be>\nMIT-style license.\n*/\r\n\r\n/*! Innovasys Modifications\n*\n*  Changed default speed to 200 for most animations\n*  Added linkMapper property so that urls can be fixed up in Mshv outputs\n* \n*/\r\n(function ($) {\r\n\r\n    // Global variables, accessible to Slimbox only\r\n    var win = $(window), options, images, activeImage = -1, activeURL, prevImage, nextImage, compatibleOverlay, middle, centerWidth, centerHeight,\r\n        ie6 = !window.XMLHttpRequest, hiddenElements = [], documentElement = document.documentElement,\r\n\r\n    // Preload images\r\n    preload = {}, preloadPrev = new Image(), preloadNext = new Image(),\r\n\r\n    // DOM elements\r\n    overlay, center, image, sizer, prevLink, nextLink, bottomContainer, bottom, caption, number;\r\n\r\n    /*\n    Initialization\n    */\r\n\r\n    $(function () {\r\n        // Append the Slimbox HTML code at the bottom of the document\r\n        $(\"div.slimboxcontainer\").add(\"body\").first().append(\r\n            $([\r\n                overlay = $('<div id=\"lbOverlay\" />')[0],\r\n                center = $('<div id=\"lbCenter\" />')[0],\r\n                bottomContainer = $('<div id=\"lbBottomContainer\" />')[0]\r\n            ]).css(\"display\", \"none\")\r\n        );\r\n\r\n        image = $('<div id=\"lbImage\" />').appendTo(center).append(\r\n            sizer = $('<div style=\"position: relative;\" />').append([\r\n                prevLink = $('<a id=\"lbPrevLink\" href=\"#\" />').click(previous)[0],\r\n                nextLink = $('<a id=\"lbNextLink\" href=\"#\" />').click(next)[0]\r\n            ])[0]\r\n        )[0];\r\n\r\n        bottom = $('<div id=\"lbBottom\" />').appendTo(bottomContainer).append([\r\n            $('<a id=\"lbCloseLink\" href=\"#\" />').click(close)[0],\r\n            caption = $('<div id=\"lbCaption\" />')[0],\r\n            number = $('<div id=\"lbNumber\" />')[0],\r\n            $('<div style=\"clear: both;\" />')[0]\r\n        ])[0];\r\n    });\r\n\r\n\r\n    /*\n    API\n    */\r\n\r\n    // Open Slimbox with the specified parameters\r\n    $.slimbox = function (_images, startImage, _options) {\r\n        options = $.extend({\r\n            loop: false, \t\t\t// Allows to navigate between first and last images\r\n            overlayOpacity: 0.8, \t\t// 1 is opaque, 0 is completely transparent (change the color in the CSS file)\r\n            overlayFadeDuration: 200, \t// Duration of the overlay fade-in and fade-out animations (in milliseconds)\r\n            resizeDuration: 200, \t\t// Duration of each of the box resize animations (in milliseconds)\r\n            resizeEasing: \"swing\", \t\t// \"swing\" is jQuery's default easing\r\n            initialWidth: 250, \t\t// Initial width of the box (in pixels)\r\n            initialHeight: 250, \t\t// Initial height of the box (in pixels)\r\n            imageFadeDuration: 200, \t\t// Duration of the image fade-in animation (in milliseconds)\r\n            captionAnimationDuration: 200, \t// Duration of the caption animation (in milliseconds)\r\n            counterText: \"Image {x} of {y}\", // Translate or change as you wish, or set it to false to disable counter text for image groups\r\n            closeKeys: [27, 88, 67], \t// Array of keycodes to close Slimbox, default: Esc (27), 'x' (88), 'c' (67)\r\n            previousKeys: [37, 80], \t\t// Array of keycodes to navigate to the previous image, default: Left arrow (37), 'p' (80)\r\n            nextKeys: [39, 78]\t\t\t// Array of keycodes to navigate to the next image, default: Right arrow (39), 'n' (78)\r\n        }, _options);\r\n\r\n        // The function is called for a single image, with URL and Title as first two arguments\r\n        if (typeof _images == \"string\") {\r\n            _images = [[_images, startImage]];\r\n            startImage = 0;\r\n        }\r\n\r\n        middle = win.scrollTop() + (win.height() / 2);\r\n        centerWidth = options.initialWidth;\r\n        centerHeight = options.initialHeight;\r\n        $(center).css({ top: Math.max(0, middle - (centerHeight / 2)), width: centerWidth, height: centerHeight, marginLeft: -centerWidth / 2 }).show();\r\n        compatibleOverlay = ie6 || (overlay.currentStyle && (overlay.currentStyle.position != \"fixed\"));\r\n        if (compatibleOverlay) overlay.style.position = \"absolute\";\r\n        $(overlay).css(\"opacity\", options.overlayOpacity).fadeIn(options.overlayFadeDuration);\r\n        position();\r\n        setup(1);\r\n\r\n        images = _images;\r\n        options.loop = options.loop && (images.length > 1);\r\n        return changeImage(startImage);\r\n    };\r\n\r\n    $.slimbox.linkMapper = function (el) {\r\n        var href = $(el).data('href');\r\n        if (!href) {\r\n            href = el.href;\r\n        }\r\n        return [href, el.title];\r\n    };\r\n\r\n    /*\n    options:\tOptional options object, see jQuery.slimbox()\n    linkMapper:\tOptional function taking a link DOM element and an index as arguments and returning an array containing 2 elements:\n    the image URL and the image caption (may contain HTML)\n    linksFilter:\tOptional function taking a link DOM element and an index as arguments and returning true if the element is part of\n    the image collection that will be shown on click, false if not. \"this\" refers to the element that was clicked.\n    This function must always return true when the DOM element argument is \"this\".\n    */\r\n    $.fn.slimbox = function (_options, linkMapper, linksFilter) {\r\n        linkMapper = linkMapper || $.slimbox.linkMapper;\r\n\r\n        linksFilter = linksFilter || function () {\r\n            return true;\r\n        };\r\n\r\n        var links = this;\r\n\r\n        return links.unbind(\"click\").click(function () {\r\n            // Build the list of images that will be displayed\r\n            var link = this, startIndex = 0, filteredLinks, i = 0, length;\r\n            filteredLinks = $.grep(links, function (el, i) {\r\n                return linksFilter.call(link, el, i);\r\n            });\r\n\r\n            // We cannot use jQuery.map() because it flattens the returned array\r\n            for (length = filteredLinks.length; i < length; ++i) {\r\n                if (filteredLinks[i] == link) startIndex = i;\r\n                filteredLinks[i] = linkMapper(filteredLinks[i], i);\r\n            }\r\n\r\n            return $.slimbox(filteredLinks, startIndex, _options);\r\n        });\r\n    };\r\n\r\n\r\n    /*\n    Internal functions\n    */\r\n\r\n    function position() {\r\n        var l = win.scrollLeft(), w = win.width();\r\n        $([center, bottomContainer]).css(\"left\", l + (w / 2));\r\n        if (compatibleOverlay) $(overlay).css({ left: l, top: win.scrollTop(), width: w, height: win.height() });\r\n    }\r\n\r\n    function setup(open) {\r\n        if (open) {\r\n            $(\"object\").add(ie6 ? \"select\" : \"embed\").each(function (index, el) {\r\n                hiddenElements[index] = [el, el.style.visibility];\r\n                el.style.visibility = \"hidden\";\r\n            });\r\n        } else {\r\n            $.each(hiddenElements, function (index, el) {\r\n                el[0].style.visibility = el[1];\r\n            });\r\n            hiddenElements = [];\r\n        }\r\n        var fn = open ? \"bind\" : \"unbind\";\r\n        win[fn](\"scroll resize\", position);\r\n        $(document)[fn](\"keydown\", keyDown);\r\n    }\r\n\r\n    function keyDown(event) {\r\n        var code = event.keyCode, fn = $.inArray;\r\n        // Prevent default keyboard action (like navigating inside the page)\r\n        return (fn(code, options.closeKeys) >= 0) ? close()\r\n            : (fn(code, options.nextKeys) >= 0) ? next()\r\n            : (fn(code, options.previousKeys) >= 0) ? previous()\r\n            : false;\r\n    }\r\n\r\n    function previous() {\r\n        return changeImage(prevImage);\r\n    }\r\n\r\n    function next() {\r\n        return changeImage(nextImage);\r\n    }\r\n\r\n    function changeImage(imageIndex) {\r\n        if (imageIndex >= 0) {\r\n            activeImage = imageIndex;\r\n            activeURL = images[activeImage][0];\r\n            // HelpStudio extension for Microsoft Help Viewer compatibility\r\n            activeURL = Innovasys.Content.Features.HelpViewerCompatibilityDocumentFeature.fixUrl(activeURL);\r\n            prevImage = (activeImage || (options.loop ? images.length : 0)) - 1;\r\n            nextImage = ((activeImage + 1) % images.length) || (options.loop ? 0 : -1);\r\n\r\n            stop();\r\n            center.className = \"lbLoading\";\r\n\r\n            preload = new Image();\r\n            preload.onload = animateBox;\r\n            preload.src = activeURL;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function animateBox() {\r\n        center.className = \"\";\r\n\r\n        /* Modified code to constrain image overlay to window dimensions */\n\n        var useDefaultSizing = true;\n        try {\n            /* make sure the image won't be bigger than the window */\n            var windowWidth = $(window).width() - 20;\n            var windowHeight = $(window).height() - 40;\n\n            /* determine proper w and h for img, based on original image's dimensions and maximumSize */\n            var maximumWidth = preload.width;\n            var maximumHeight = preload.height;\r\n\r\n            if ((preload.width - windowWidth) > (preload.height - windowHeight)) {\r\n                // Less space horizontally, determine max size from width\r\n                maximumWidth = windowWidth - 100;\r\n                maximumHeight = preload.height * (maximumWidth / preload.width);\r\n            } else {\r\n                maximumHeight = windowHeight - 200;\r\n                maximumWidth = preload.width * (maximumHeight / preload.height);\r\n            }\n\n            if (preload.width > maximumWidth || preload.height > maximumHeight) {\n                /* constrain it */\n                $(image).css({ backgroundImage: \"url(\" + activeURL + \")\", backgroundSize: maximumWidth + \"px \" + maximumHeight + \"px\", visibility: \"hidden\", display: \"\" });\n                $(sizer).width(maximumWidth);\n                $([sizer, prevLink, nextLink]).height(maximumHeight);\r\n\r\n                useDefaultSizing = false;\r\n            }\r\n        }\n        catch (ex) {\n            /* Falls back to original sizing code */\r\n        }\n        if (useDefaultSizing) {\r\n            $(image).css({ backgroundImage: \"url(\" + activeURL + \")\", backgroundSize: \"\", visibility: \"hidden\", display: \"\" });\n            $(sizer).width(preload.width);\n            $([sizer, prevLink, nextLink]).height(preload.height);\r\n        }\n\n        /* End Modified code to constrain image to window dimensions */\r\n\r\n        $(caption).html(images[activeImage][1] || \"\");\r\n        $(number).html((((images.length > 1) && options.counterText) || \"\").replace(/{x}/, activeImage + 1).replace(/{y}/, images.length));\r\n\r\n        if (prevImage >= 0) preloadPrev.src = images[prevImage][0];\r\n        if (nextImage >= 0) preloadNext.src = images[nextImage][0];\r\n\r\n        centerWidth = image.offsetWidth;\r\n        centerHeight = image.offsetHeight;\r\n        var top = Math.max(0, middle - (centerHeight / 2));\r\n        if (center.offsetHeight != centerHeight) {\r\n            $(center).animate({ height: centerHeight, top: top }, options.resizeDuration, options.resizeEasing);\r\n        }\r\n        if (center.offsetWidth != centerWidth) {\r\n            $(center).animate({ width: centerWidth, marginLeft: -centerWidth / 2 }, options.resizeDuration, options.resizeEasing);\r\n        }\r\n        $(center).queue(function () {\r\n            $(bottomContainer).css({ width: centerWidth, top: top + centerHeight, marginLeft: -centerWidth / 2, visibility: \"hidden\", display: \"\" });\r\n            $(image).css({ display: \"none\", visibility: \"\", opacity: \"\" }).fadeIn(options.imageFadeDuration, animateCaption);\r\n        });\r\n    }\r\n\r\n    function animateCaption() {\r\n        if (prevImage >= 0) $(prevLink).show();\r\n        if (nextImage >= 0) $(nextLink).show();\r\n        $(bottom).css(\"marginTop\", -bottom.offsetHeight).animate({ marginTop: 0 }, options.captionAnimationDuration);\r\n        bottomContainer.style.visibility = \"\";\r\n    }\r\n\r\n    function stop() {\r\n        preload.onload = null;\r\n        preload.src = preloadPrev.src = preloadNext.src = activeURL;\r\n        $([center, image, bottom]).stop(true);\r\n        $([prevLink, nextLink, image, bottomContainer]).hide();\r\n    }\r\n\r\n    function close() {\r\n        if (activeImage >= 0) {\r\n            stop();\r\n            activeImage = prevImage = nextImage = -1;\r\n            $(center).hide();\r\n            $(overlay).stop().fadeOut(options.overlayFadeDuration, setup);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n})(jQuery);","/*jshint browser:true */\r\n/*!\r\n* FitVids 1.1\r\n*\r\n* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com\r\n* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/\r\n* Released under the WTFPL license - http://sam.zoy.org/wtfpl/\r\n*\r\n*/\r\n\r\n; (function ($) {\r\n\r\n    'use strict';\r\n\r\n    $.fn.fitVids = function (options) {\r\n        var settings = {\r\n            customSelector: null,\r\n            ignore: null\r\n        };\r\n\r\n        if (!document.getElementById('fit-vids-style')) {\r\n            // appendStyles: https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.js\r\n            var head = document.head || document.getElementsByTagName('head')[0];\r\n            var css = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}';\r\n            var div = document.createElement(\"div\");\r\n            div.innerHTML = '<p>x</p><style id=\"fit-vids-style\">' + css + '</style>';\r\n            head.appendChild(div.childNodes[1]);\r\n        }\r\n\r\n        if (options) {\r\n            $.extend(settings, options);\r\n        }\r\n\r\n        return this.each(function () {\r\n            var selectors = [\r\n              'iframe[src*=\"player.vimeo.com\"]',\r\n              'iframe[src*=\"youtube.com\"]',\r\n              'iframe[src*=\"youtube-nocookie.com\"]',\r\n              'iframe[src*=\"kickstarter.com\"][src*=\"video.html\"]',\r\n              'object',\r\n              'embed'\r\n            ];\r\n\r\n            if (settings.customSelector) {\r\n                selectors.push(settings.customSelector);\r\n            }\r\n\r\n            var ignoreList = '.fitvidsignore';\r\n\r\n            if (settings.ignore) {\r\n                ignoreList = ignoreList + ', ' + settings.ignore;\r\n            }\r\n\r\n            var $allVideos = $(this).find(selectors.join(','));\r\n            $allVideos = $allVideos.not('object object'); // SwfObj conflict patch\r\n            $allVideos = $allVideos.not(ignoreList); // Disable FitVids on this video.\r\n\r\n            $allVideos.each(function () {\r\n                var $this = $(this);\r\n                if ($this.parents(ignoreList).length > 0) {\r\n                    return; // Disable FitVids on this video.\r\n                }\r\n                if (this.tagName.toLowerCase() === 'embed' && $this.parent('object').length || $this.parent('.fluid-width-video-wrapper').length) { return; }\r\n                if ((!$this.css('height') && !$this.css('width')) && (isNaN($this.attr('height')) || isNaN($this.attr('width')))) {\r\n                    $this.attr('height', 9);\r\n                    $this.attr('width', 16);\r\n                }\r\n                var height = (this.tagName.toLowerCase() === 'object' || ($this.attr('height') && !isNaN(parseInt($this.attr('height'), 10)))) ? parseInt($this.attr('height'), 10) : $this.height(),\r\n                    width = !isNaN(parseInt($this.attr('width'), 10)) ? parseInt($this.attr('width'), 10) : $this.width(),\r\n                    aspectRatio = height / width;\r\n                if (!$this.attr('name')) {\r\n                    var videoName = 'fitvid' + $.fn.fitVids._count;\r\n                    $this.attr('name', videoName);\r\n                    $.fn.fitVids._count++;\r\n                }\r\n                $this.wrap('<div class=\"fluid-width-video-wrapper\"></div>').parent('.fluid-width-video-wrapper').css('padding-top', (aspectRatio * 100) + '%');\r\n                $this.removeAttr('height').removeAttr('width');\r\n            });\r\n        });\r\n    };\r\n\r\n    // Internal counter for unique video names.\r\n    $.fn.fitVids._count = 0;\r\n\r\n    // Works with either jQuery or Zepto\r\n})(window.jQuery || window.Zepto);","/*! modernizr 3.6.0 (Custom Build) | MIT *\r\n * https://modernizr.com/download/?-mq-prefixes-setclasses-shiv-teststyles !*/\r\n!function (e, t, n) { function a(e, t) { return typeof e === t } function r() { var e, t, n, r, o, i, s; for (var l in d) if (d.hasOwnProperty(l)) { if (e = [], t = d[l], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++)e.push(t.options.aliases[n].toLowerCase()); for (r = a(t.fn, \"function\") ? t.fn() : t.fn, o = 0; o < e.length; o++)i = e[o], s = i.split(\".\"), 1 === s.length ? Modernizr[s[0]] = r : (!Modernizr[s[0]] || Modernizr[s[0]] instanceof Boolean || (Modernizr[s[0]] = new Boolean(Modernizr[s[0]])), Modernizr[s[0]][s[1]] = r), c.push((r ? \"\" : \"no-\") + s.join(\"-\")) } } function o(e) { var t = m.className, n = Modernizr._config.classPrefix || \"\"; if (p && (t = t.baseVal), Modernizr._config.enableJSClass) { var a = new RegExp(\"(^|\\\\s)\" + n + \"no-js(\\\\s|$)\"); t = t.replace(a, \"$1\" + n + \"js$2\") } Modernizr._config.enableClasses && (t += \" \" + n + e.join(\" \" + n), p ? m.className.baseVal = t : m.className = t) } function i() { return \"function\" != typeof t.createElement ? t.createElement(arguments[0]) : p ? t.createElementNS.call(t, \"http://www.w3.org/2000/svg\", arguments[0]) : t.createElement.apply(t, arguments) } function s() { var e = t.body; return e || (e = i(p ? \"svg\" : \"body\"), e.fake = !0), e } function l(e, n, a, r) { var o, l, c, d, u = \"modernizr\", f = i(\"div\"), p = s(); if (parseInt(a, 10)) for (; a--;)c = i(\"div\"), c.id = r ? r[a] : u + (a + 1), f.appendChild(c); return o = i(\"style\"), o.type = \"text/css\", o.id = \"s\" + u, (p.fake ? p : f).appendChild(o), p.appendChild(f), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(t.createTextNode(e)), f.id = u, p.fake && (p.style.background = \"\", p.style.overflow = \"hidden\", d = m.style.overflow, m.style.overflow = \"hidden\", m.appendChild(p)), l = n(f, e), p.fake ? (p.parentNode.removeChild(p), m.style.overflow = d, m.offsetHeight) : f.parentNode.removeChild(f), !!l } var c = [], d = [], u = { _version: \"3.6.0\", _config: { classPrefix: \"\", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function (e, t) { var n = this; setTimeout(function () { t(n[e]) }, 0) }, addTest: function (e, t, n) { d.push({ name: e, fn: t, options: n }) }, addAsyncTest: function (e) { d.push({ name: null, fn: e }) } }, Modernizr = function () { }; Modernizr.prototype = u, Modernizr = new Modernizr; var f = u._config.usePrefixes ? \" -webkit- -moz- -o- -ms- \".split(\" \") : [\"\", \"\"]; u._prefixes = f; var m = t.documentElement, p = \"svg\" === m.nodeName.toLowerCase(); p || !function (e, t) { function n(e, t) { var n = e.createElement(\"p\"), a = e.getElementsByTagName(\"head\")[0] || e.documentElement; return n.innerHTML = \"x<style>\" + t + \"</style>\", a.insertBefore(n.lastChild, a.firstChild) } function a() { var e = E.elements; return \"string\" == typeof e ? e.split(\" \") : e } function r(e, t) { var n = E.elements; \"string\" != typeof n && (n = n.join(\" \")), \"string\" != typeof e && (e = e.join(\" \")), E.elements = n + \" \" + e, c(t) } function o(e) { var t = y[e[g]]; return t || (t = {}, v++, e[g] = v, y[v] = t), t } function i(e, n, a) { if (n || (n = t), u) return n.createElement(e); a || (a = o(n)); var r; return r = a.cache[e] ? a.cache[e].cloneNode() : h.test(e) ? (a.cache[e] = a.createElem(e)).cloneNode() : a.createElem(e), !r.canHaveChildren || p.test(e) || r.tagUrn ? r : a.frag.appendChild(r) } function s(e, n) { if (e || (e = t), u) return e.createDocumentFragment(); n = n || o(e); for (var r = n.frag.cloneNode(), i = 0, s = a(), l = s.length; l > i; i++)r.createElement(s[i]); return r } function l(e, t) { t.cache || (t.cache = {}, t.createElem = e.createElement, t.createFrag = e.createDocumentFragment, t.frag = t.createFrag()), e.createElement = function (n) { return E.shivMethods ? i(n, e, t) : t.createElem(n) }, e.createDocumentFragment = Function(\"h,f\", \"return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(\" + a().join().replace(/[\\w\\-:]+/g, function (e) { return t.createElem(e), t.frag.createElement(e), 'c(\"' + e + '\")' }) + \");return n}\")(E, t.frag) } function c(e) { e || (e = t); var a = o(e); return !E.shivCSS || d || a.hasCSS || (a.hasCSS = !!n(e, \"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}\")), u || l(e, a), e } var d, u, f = \"3.7.3\", m = e.html5 || {}, p = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i, h = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i, g = \"_html5shiv\", v = 0, y = {}; !function () { try { var e = t.createElement(\"a\"); e.innerHTML = \"<xyz></xyz>\", d = \"hidden\" in e, u = 1 == e.childNodes.length || function () { t.createElement(\"a\"); var e = t.createDocumentFragment(); return \"undefined\" == typeof e.cloneNode || \"undefined\" == typeof e.createDocumentFragment || \"undefined\" == typeof e.createElement }() } catch (n) { d = !0, u = !0 } }(); var E = { elements: m.elements || \"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video\", version: f, shivCSS: m.shivCSS !== !1, supportsUnknownElements: u, shivMethods: m.shivMethods !== !1, type: \"default\", shivDocument: c, createElement: i, createDocumentFragment: s, addElements: r }; e.html5 = E, c(t), \"object\" == typeof module && module.exports && (module.exports = E) }(\"undefined\" != typeof e ? e : this, t); var h = function () { var t = e.matchMedia || e.msMatchMedia; return t ? function (e) { var n = t(e); return n && n.matches || !1 } : function (t) { var n = !1; return l(\"@media \" + t + \" { #modernizr { position: absolute; } }\", function (t) { n = \"absolute\" == (e.getComputedStyle ? e.getComputedStyle(t, null) : t.currentStyle).position }), n } }(); u.mq = h; u.testStyles = l; r(), o(c), delete u.addTest, delete u.addAsyncTest; for (var g = 0; g < Modernizr._q.length; g++)Modernizr._q[g](); e.Modernizr = Modernizr }(window, document);","// yepnope.js\r\n// v2.0.0\r\n//\r\n// by\r\n// Alex Sexton - @slexaxton - alexsexton[at]gmail.com\r\n// Ralph Holzmann - @rlph - ralphholzmann[at]gmail.com\r\n//\r\n// http://yepnopejs.com/\r\n// https://github.com/SlexAxton/yepnope.js/\r\n//\r\n// New BSD\r\n//\r\n// Consider inlining this script after minifying\r\n\r\nwindow.yepnope = (function (window, document, undef) {\r\n    // Yepnope's style is intentionally very flat to aid in\r\n    // minification. The authors are usually against too much\r\n    // self-minification, but in the case of a script loader, we're\r\n    // especially file size sensitive.\r\n\r\n    // Some aliases\r\n    var sTimeout = window.setTimeout;\r\n    var firstScript;\r\n    var scriptsQueue = [];\r\n    var count = 0;\r\n    var toString = {}.toString;\r\n\r\n    function noop() { }\r\n\r\n    // Helper functions\r\n    function isObject(obj) {\r\n        return Object(obj) === obj;\r\n    }\r\n\r\n    function isString(s) {\r\n        return typeof s == 'string';\r\n    }\r\n\r\n    // Loader Utilities\r\n    function uniq() {\r\n        return 'yn_' + (count++);\r\n    }\r\n\r\n    function readFirstScript() {\r\n        if (!firstScript || !firstScript.parentNode) {\r\n            firstScript = document.getElementsByTagName('script')[0];\r\n        }\r\n    }\r\n\r\n    function isFileReady(readyState) {\r\n        // Check to see if any of the ways a file can be ready are available as properties on the file's element\r\n        return (!readyState || readyState == 'loaded' || readyState == 'complete' || readyState == 'uninitialized');\r\n    }\r\n\r\n    function runWhenReady(src, cb) {\r\n        cb.call(window);\r\n    }\r\n\r\n    // Inject a script into the page and know when it's done\r\n    function injectJs(options, cb) {\r\n        var src;\r\n        var attrs;\r\n        var timeout;\r\n\r\n        if (isString(options)) {\r\n            src = options;\r\n        }\r\n        else if (isObject(options)) {\r\n            // Allow rewritten url to take precedence\r\n            src = options._url || options.src;\r\n            attrs = options.attrs;\r\n            timeout = options.timeout;\r\n        }\r\n\r\n        cb = cb || noop;\r\n        attrs = attrs || {};\r\n\r\n        var script = document.createElement('script');\r\n        var done;\r\n        var i;\r\n\r\n        timeout = timeout || yepnope.errorTimeout;\r\n\r\n        script.src = src;\r\n\r\n        // Add our extra attributes to the script element\r\n        for (i in attrs) {\r\n            script.setAttribute(i, attrs[i]);\r\n        }\r\n\r\n        // Bind to load events\r\n        script.onreadystatechange = script.onload = function () {\r\n\r\n            if (!done && isFileReady(script.readyState)) {\r\n                // Set done to prevent this function from being called twice.\r\n                done = 1;\r\n\r\n                // Just run the callback\r\n                runWhenReady(src, cb);\r\n            }\r\n\r\n            // Handle memory leak in IE\r\n            script.onload = script.onreadystatechange = script.onerror = null;\r\n        };\r\n\r\n        // This won't work in every browser, but\r\n        // would be helpful in those that it does.\r\n        // http://stackoverflow.com/questions/2027849/how-to-trigger-script-onerror-in-internet-explorer/2032014#2032014\r\n        // For those that don't support it, the timeout will be the backup\r\n        script.onerror = function () {\r\n            // Don't call the callback again, so we mark it done\r\n            done = 1;\r\n            cb(new Error('Script Error: ' + src));\r\n            // We don't waste bytes on cleaning up memory in error cases\r\n            // because hopefully it doesn't happen often enough to matter.\r\n            // And you're probably already in an 'uh-oh' situation.\r\n        };\r\n\r\n        // 404 Fallback\r\n        sTimeout(function () {\r\n            // Don't do anything if the script has already finished\r\n            if (!done) {\r\n                // Mark it as done, which means the callback won't run again\r\n                done = 1;\r\n\r\n                // Might as well pass in an error-state if we fire the 404 fallback\r\n                cb(new Error('Timeout: ' + src));\r\n                // Maybe...\r\n                script.parentNode.removeChild(script);\r\n            }\r\n        }, timeout);\r\n\r\n        // Inject script into to document\r\n        readFirstScript();\r\n        firstScript.parentNode.insertBefore(script, firstScript);\r\n    }\r\n\r\n    function injectCss(options, cb) {\r\n        var attrs = {};\r\n        var href;\r\n        var i;\r\n        var media;\r\n\r\n        // optionally accept an object of settings\r\n        // or a string that's the url\r\n        if (isObject(options)) {\r\n            // allow the overriden _url property to take precendence\r\n            href = options._url || options.href;\r\n            attrs = options.attrs || {};\r\n        }\r\n        else if (isString(options)) {\r\n            href = options;\r\n        }\r\n\r\n        // Create stylesheet link\r\n        var link = document.createElement('link');\r\n\r\n        cb = cb || noop;\r\n\r\n        // Add attributes\r\n        link.href = href;\r\n        link.rel = 'stylesheet';\r\n        // Technique to force non-blocking loading from:\r\n        // https://github.com/filamentgroup/loadCSS/blob/master/loadCSS.js#L20\r\n        link.media = 'only x';\r\n        link.type = 'text/css';\r\n\r\n        // On next tick, just set the media to what it's supposed to be\r\n        sTimeout(function () {\r\n            link.media = attrs.media || 'all';\r\n        });\r\n\r\n        // Add our extra attributes to the link element\r\n        for (i in attrs) {\r\n            link.setAttribute(i, attrs[i]);\r\n        }\r\n\r\n        readFirstScript();\r\n        // We append link tags so the cascades work as expected.\r\n        // A little more dangerous, but if you're injecting CSS\r\n        // dynamically, you probably can handle it.\r\n        firstScript.parentNode.appendChild(link);\r\n\r\n        // Always just run the callback for CSS on next tick. We're not\r\n        // going to try to normalize this, so don't worry about runwhenready here.\r\n        sTimeout(function () {\r\n            cb.call(window);\r\n        });\r\n    }\r\n\r\n    function getExtension(url) {\r\n        //The extension is always the last characters before the ? and after a period.\r\n        //The previous method was not accounting for the possibility of a period in the query string.\r\n        var b = url.split('?')[0];\r\n        return b.substr(b.lastIndexOf('.') + 1);\r\n    }\r\n\r\n    function defaultUrlFormatter(base, tests) {\r\n        var url = base;\r\n        var passed = [];\r\n        var failed = [];\r\n\r\n        for (var i in tests) {\r\n            if (tests.hasOwnProperty(i)) {\r\n                if (tests[i]) {\r\n                    passed.push(encodeURIComponent(i));\r\n                }\r\n                else {\r\n                    failed.push(encodeURIComponent(i));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (passed.length || failed.length) {\r\n            url += '?';\r\n        }\r\n\r\n        if (passed.length) {\r\n            url += 'yep=' + passed.join(',');\r\n        }\r\n\r\n        if (failed.length) {\r\n            url += (passed.length ? '&' : '') + 'nope=' + failed.join(',');\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    // The leaked function. Mostly just takes a set\r\n    // of arguments, and then passes them to be run.\r\n    function yepnope(url, tests, cb) {\r\n        var options;\r\n\r\n        if (isObject(url)) {\r\n            // It was just kidding about being the url\r\n            options = url;\r\n            // Can't ever have both, so this is fine\r\n            url = options.src || options.href;\r\n        }\r\n\r\n        url = yepnope.urlFormatter(url, tests);\r\n\r\n        if (!options) {\r\n            options = { _url: url };\r\n        }\r\n        else {\r\n            options._url = url;\r\n        }\r\n\r\n        var type = getExtension(url);\r\n\r\n        if (type === 'js') {\r\n            injectJs(options, cb);\r\n        }\r\n        else if (type === 'css') {\r\n            injectCss(options, cb);\r\n        }\r\n        else {\r\n            throw new Error('Unable to determine filetype.');\r\n        }\r\n    }\r\n\r\n    // Add a default for the error timer\r\n    yepnope.errorTimeout = 10e3;\r\n    // Expose no BS script injection\r\n    yepnope.injectJs = injectJs;\r\n    // Expose super-lightweight css injector\r\n    yepnope.injectCss = injectCss;\r\n    // Allow someone to override the url writer\r\n    yepnope.urlFormatter = defaultUrlFormatter;\r\n\r\n    return yepnope;\r\n})(window, document);"]}