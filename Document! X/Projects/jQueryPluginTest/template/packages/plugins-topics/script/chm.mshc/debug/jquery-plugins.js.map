{"version":3,"sources":["js.cookie.js","json2.js","jquery.qtip.chm.js","slimbox2.js","jquery.fitvids.js","modernizr.custom.js","yepnope.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClhFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrFA;AACA;AACA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"innovasys.jqueryplugins.chm.js","sourcesContent":["/*!\n * JavaScript Cookie v2.2.1\n * https://github.com/js-cookie/js-cookie\n *\n * Copyright 2006, 2015 Klaus Hartl & Fagner Brack\n * Released under the MIT license\n */\n;(function (factory) {\n\tvar registeredInModuleLoader;\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory);\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (typeof exports === 'object') {\n\t\tmodule.exports = factory();\n\t\tregisteredInModuleLoader = true;\n\t}\n\tif (!registeredInModuleLoader) {\n\t\tvar OldCookies = window.Cookies;\n\t\tvar api = window.Cookies = factory();\n\t\tapi.noConflict = function () {\n\t\t\twindow.Cookies = OldCookies;\n\t\t\treturn api;\n\t\t};\n\t}\n}(function () {\n\tfunction extend () {\n\t\tvar i = 0;\n\t\tvar result = {};\n\t\tfor (; i < arguments.length; i++) {\n\t\t\tvar attributes = arguments[ i ];\n\t\t\tfor (var key in attributes) {\n\t\t\t\tresult[key] = attributes[key];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction decode (s) {\n\t\treturn s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);\n\t}\n\n\tfunction init (converter) {\n\t\tfunction api() {}\n\n\t\tfunction set (key, value, attributes) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tattributes = extend({\n\t\t\t\tpath: '/'\n\t\t\t}, api.defaults, attributes);\n\n\t\t\tif (typeof attributes.expires === 'number') {\n\t\t\t\tattributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);\n\t\t\t}\n\n\t\t\t// We're using \"expires\" because \"max-age\" is not supported by IE\n\t\t\tattributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';\n\n\t\t\ttry {\n\t\t\t\tvar result = JSON.stringify(value);\n\t\t\t\tif (/^[\\{\\[]/.test(result)) {\n\t\t\t\t\tvalue = result;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\n\t\t\tvalue = converter.write ?\n\t\t\t\tconverter.write(value, key) :\n\t\t\t\tencodeURIComponent(String(value))\n\t\t\t\t\t.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);\n\n\t\t\tkey = encodeURIComponent(String(key))\n\t\t\t\t.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)\n\t\t\t\t.replace(/[\\(\\)]/g, escape);\n\n\t\t\tvar stringifiedAttributes = '';\n\t\t\tfor (var attributeName in attributes) {\n\t\t\t\tif (!attributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstringifiedAttributes += '; ' + attributeName;\n\t\t\t\tif (attributes[attributeName] === true) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Considers RFC 6265 section 5.2:\n\t\t\t\t// ...\n\t\t\t\t// 3.  If the remaining unparsed-attributes contains a %x3B (\";\")\n\t\t\t\t//     character:\n\t\t\t\t// Consume the characters of the unparsed-attributes up to,\n\t\t\t\t// not including, the first %x3B (\";\") character.\n\t\t\t\t// ...\n\t\t\t\tstringifiedAttributes += '=' + attributes[attributeName].split(';')[0];\n\t\t\t}\n\n\t\t\treturn (document.cookie = key + '=' + value + stringifiedAttributes);\n\t\t}\n\n\t\tfunction get (key, json) {\n\t\t\tif (typeof document === 'undefined') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar jar = {};\n\t\t\t// To prevent the for loop in the first place assign an empty array\n\t\t\t// in case there are no cookies at all.\n\t\t\tvar cookies = document.cookie ? document.cookie.split('; ') : [];\n\t\t\tvar i = 0;\n\n\t\t\tfor (; i < cookies.length; i++) {\n\t\t\t\tvar parts = cookies[i].split('=');\n\t\t\t\tvar cookie = parts.slice(1).join('=');\n\n\t\t\t\tif (!json && cookie.charAt(0) === '\"') {\n\t\t\t\t\tcookie = cookie.slice(1, -1);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tvar name = decode(parts[0]);\n\t\t\t\t\tcookie = (converter.read || converter)(cookie, name) ||\n\t\t\t\t\t\tdecode(cookie);\n\n\t\t\t\t\tif (json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcookie = JSON.parse(cookie);\n\t\t\t\t\t\t} catch (e) {}\n\t\t\t\t\t}\n\n\t\t\t\t\tjar[name] = cookie;\n\n\t\t\t\t\tif (key === name) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\treturn key ? jar[key] : jar;\n\t\t}\n\n\t\tapi.set = set;\n\t\tapi.get = function (key) {\n\t\t\treturn get(key, false /* read as raw */);\n\t\t};\n\t\tapi.getJSON = function (key) {\n\t\t\treturn get(key, true /* read as json */);\n\t\t};\n\t\tapi.remove = function (key, attributes) {\n\t\t\tset(key, '', extend(attributes, {\n\t\t\t\texpires: -1\n\t\t\t}));\n\t\t};\n\n\t\tapi.defaults = {};\n\n\t\tapi.withConverter = init;\n\n\t\treturn api;\n\t}\n\n\treturn init(function () {});\n}));\n","/*\r\n    json2.js\r\n    2011-10-19\r\n\r\n    Public Domain.\r\n\r\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\r\n\r\n    See http://www.JSON.org/js.html\r\n\r\n\r\n    This code should be minified before deployment.\r\n    See http://javascript.crockford.com/jsmin.html\r\n\r\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\r\n    NOT CONTROL.\r\n\r\n\r\n    This file creates a global JSON object containing two methods: stringify\r\n    and parse.\r\n\r\n        JSON.stringify(value, replacer, space)\r\n            value       any JavaScript value, usually an object or array.\r\n\r\n            replacer    an optional parameter that determines how object\r\n                        values are stringified for objects. It can be a\r\n                        function or an array of strings.\r\n\r\n            space       an optional parameter that specifies the indentation\r\n                        of nested structures. If it is omitted, the text will\r\n                        be packed without extra whitespace. If it is a number,\r\n                        it will specify the number of spaces to indent at each\r\n                        level. If it is a string (such as '\\t' or '&nbsp;'),\r\n                        it contains the characters used to indent at each level.\r\n\r\n            This method produces a JSON text from a JavaScript value.\r\n\r\n            When an object value is found, if the object contains a toJSON\r\n            method, its toJSON method will be called and the result will be\r\n            stringified. A toJSON method does not serialize: it returns the\r\n            value represented by the name/value pair that should be serialized,\r\n            or undefined if nothing should be serialized. The toJSON method\r\n            will be passed the key associated with the value, and this will be\r\n            bound to the value\r\n\r\n            For example, this would serialize Dates as ISO strings.\r\n\r\n                Date.prototype.toJSON = function (key) {\r\n                    function f(n) {\r\n                        // Format integers to have at least two digits.\r\n                        return n < 10 ? '0' + n : n;\r\n                    }\r\n\r\n                    return this.getUTCFullYear()   + '-' +\r\n                         f(this.getUTCMonth() + 1) + '-' +\r\n                         f(this.getUTCDate())      + 'T' +\r\n                         f(this.getUTCHours())     + ':' +\r\n                         f(this.getUTCMinutes())   + ':' +\r\n                         f(this.getUTCSeconds())   + 'Z';\r\n                };\r\n\r\n            You can provide an optional replacer method. It will be passed the\r\n            key and value of each member, with this bound to the containing\r\n            object. The value that is returned from your method will be\r\n            serialized. If your method returns undefined, then the member will\r\n            be excluded from the serialization.\r\n\r\n            If the replacer parameter is an array of strings, then it will be\r\n            used to select the members to be serialized. It filters the results\r\n            such that only members with keys listed in the replacer array are\r\n            stringified.\r\n\r\n            Values that do not have JSON representations, such as undefined or\r\n            functions, will not be serialized. Such values in objects will be\r\n            dropped; in arrays they will be replaced with null. You can use\r\n            a replacer function to replace those with JSON values.\r\n            JSON.stringify(undefined) returns undefined.\r\n\r\n            The optional space parameter produces a stringification of the\r\n            value that is filled with line breaks and indentation to make it\r\n            easier to read.\r\n\r\n            If the space parameter is a non-empty string, then that string will\r\n            be used for indentation. If the space parameter is a number, then\r\n            the indentation will be that many spaces.\r\n\r\n            Example:\r\n\r\n            text = JSON.stringify(['e', {pluribus: 'unum'}]);\r\n            // text is '[\"e\",{\"pluribus\":\"unum\"}]'\r\n\r\n\r\n            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\\t');\r\n            // text is '[\\n\\t\"e\",\\n\\t{\\n\\t\\t\"pluribus\": \"unum\"\\n\\t}\\n]'\r\n\r\n            text = JSON.stringify([new Date()], function (key, value) {\r\n                return this[key] instanceof Date ?\r\n                    'Date(' + this[key] + ')' : value;\r\n            });\r\n            // text is '[\"Date(---current time---)\"]'\r\n\r\n\r\n        JSON.parse(text, reviver)\r\n            This method parses a JSON text to produce an object or array.\r\n            It can throw a SyntaxError exception.\r\n\r\n            The optional reviver parameter is a function that can filter and\r\n            transform the results. It receives each of the keys and values,\r\n            and its return value is used instead of the original value.\r\n            If it returns what it received, then the structure is not modified.\r\n            If it returns undefined then the member is deleted.\r\n\r\n            Example:\r\n\r\n            // Parse the text. Values that look like ISO date strings will\r\n            // be converted to Date objects.\r\n\r\n            myData = JSON.parse(text, function (key, value) {\r\n                var a;\r\n                if (typeof value === 'string') {\r\n                    a =\r\n/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)Z$/.exec(value);\r\n                    if (a) {\r\n                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],\r\n                            +a[5], +a[6]));\r\n                    }\r\n                }\r\n                return value;\r\n            });\r\n\r\n            myData = JSON.parse('[\"Date(09/09/2001)\"]', function (key, value) {\r\n                var d;\r\n                if (typeof value === 'string' &&\r\n                        value.slice(0, 5) === 'Date(' &&\r\n                        value.slice(-1) === ')') {\r\n                    d = new Date(value.slice(5, -1));\r\n                    if (d) {\r\n                        return d;\r\n                    }\r\n                }\r\n                return value;\r\n            });\r\n\r\n\r\n    This is a reference implementation. You are free to copy, modify, or\r\n    redistribute.\r\n*/\r\n\r\n/*jslint evil: true, regexp: true */\r\n\r\n/*members \"\", \"\\b\", \"\\t\", \"\\n\", \"\\f\", \"\\r\", \"\\\"\", JSON, \"\\\\\", apply,\r\n    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,\r\n    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,\r\n    lastIndex, length, parse, prototype, push, replace, slice, stringify,\r\n    test, toJSON, toString, valueOf\r\n*/\r\n\r\n\r\n// Create a JSON object only if one does not already exist. We create the\r\n// methods in a closure to avoid creating global variables.\r\n\r\nvar JSON;\r\nif (!JSON) {\r\n    JSON = {};\r\n}\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    function f(n) {\r\n        // Format integers to have at least two digits.\r\n        return n < 10 ? '0' + n : n;\r\n    }\r\n\r\n    if (typeof Date.prototype.toJSON !== 'function') {\r\n\r\n        Date.prototype.toJSON = function (key) {\r\n\r\n            return isFinite(this.valueOf())\r\n                ? this.getUTCFullYear()     + '-' +\r\n                    f(this.getUTCMonth() + 1) + '-' +\r\n                    f(this.getUTCDate())      + 'T' +\r\n                    f(this.getUTCHours())     + ':' +\r\n                    f(this.getUTCMinutes())   + ':' +\r\n                    f(this.getUTCSeconds())   + 'Z'\r\n                : null;\r\n        };\r\n\r\n        String.prototype.toJSON      =\r\n            Number.prototype.toJSON  =\r\n            Boolean.prototype.toJSON = function (key) {\r\n                return this.valueOf();\r\n            };\r\n    }\r\n\r\n    var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n        escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n        gap,\r\n        indent,\r\n        meta = {    // table of character substitutions\r\n            '\\b': '\\\\b',\r\n            '\\t': '\\\\t',\r\n            '\\n': '\\\\n',\r\n            '\\f': '\\\\f',\r\n            '\\r': '\\\\r',\r\n            '\"' : '\\\\\"',\r\n            '\\\\': '\\\\\\\\'\r\n        },\r\n        rep;\r\n\r\n\r\n    function quote(string) {\r\n\r\n// If the string contains no control characters, no quote characters, and no\r\n// backslash characters, then we can safely slap some quotes around it.\r\n// Otherwise we must also replace the offending characters with safe escape\r\n// sequences.\r\n\r\n        escapable.lastIndex = 0;\r\n        return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\r\n            var c = meta[a];\r\n            return typeof c === 'string'\r\n                ? c\r\n                : '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n        }) + '\"' : '\"' + string + '\"';\r\n    }\r\n\r\n\r\n    function str(key, holder) {\r\n\r\n// Produce a string from holder[key].\r\n\r\n        var i,          // The loop counter.\r\n            k,          // The member key.\r\n            v,          // The member value.\r\n            length,\r\n            mind = gap,\r\n            partial,\r\n            value = holder[key];\r\n\r\n// If the value has a toJSON method, call it to obtain a replacement value.\r\n\r\n        if (value && typeof value === 'object' &&\r\n                typeof value.toJSON === 'function') {\r\n            value = value.toJSON(key);\r\n        }\r\n\r\n// If we were called with a replacer function, then call the replacer to\r\n// obtain a replacement value.\r\n\r\n        if (typeof rep === 'function') {\r\n            value = rep.call(holder, key, value);\r\n        }\r\n\r\n// What happens next depends on the value's type.\r\n\r\n        switch (typeof value) {\r\n        case 'string':\r\n            return quote(value);\r\n\r\n        case 'number':\r\n\r\n// JSON numbers must be finite. Encode non-finite numbers as null.\r\n\r\n            return isFinite(value) ? String(value) : 'null';\r\n\r\n        case 'boolean':\r\n        case 'null':\r\n\r\n// If the value is a boolean or null, convert it to a string. Note:\r\n// typeof null does not produce 'null'. The case is included here in\r\n// the remote chance that this gets fixed someday.\r\n\r\n            return String(value);\r\n\r\n// If the type is 'object', we might be dealing with an object or an array or\r\n// null.\r\n\r\n        case 'object':\r\n\r\n// Due to a specification blunder in ECMAScript, typeof null is 'object',\r\n// so watch out for that case.\r\n\r\n            if (!value) {\r\n                return 'null';\r\n            }\r\n\r\n// Make an array to hold the partial results of stringifying this object value.\r\n\r\n            gap += indent;\r\n            partial = [];\r\n\r\n// Is the value an array?\r\n\r\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\r\n\r\n// The value is an array. Stringify every element. Use null as a placeholder\r\n// for non-JSON values.\r\n\r\n                length = value.length;\r\n                for (i = 0; i < length; i += 1) {\r\n                    partial[i] = str(i, value) || 'null';\r\n                }\r\n\r\n// Join all of the elements together, separated with commas, and wrap them in\r\n// brackets.\r\n\r\n                v = partial.length === 0\r\n                    ? '[]'\r\n                    : gap\r\n                    ? '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']'\r\n                    : '[' + partial.join(',') + ']';\r\n                gap = mind;\r\n                return v;\r\n            }\r\n\r\n// If the replacer is an array, use it to select the members to be stringified.\r\n\r\n            if (rep && typeof rep === 'object') {\r\n                length = rep.length;\r\n                for (i = 0; i < length; i += 1) {\r\n                    if (typeof rep[i] === 'string') {\r\n                        k = rep[i];\r\n                        v = str(k, value);\r\n                        if (v) {\r\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n\r\n// Otherwise, iterate through all of the keys in the object.\r\n\r\n                for (k in value) {\r\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\r\n                        v = str(k, value);\r\n                        if (v) {\r\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n// Join all of the member texts together, separated with commas,\r\n// and wrap them in braces.\r\n\r\n            v = partial.length === 0\r\n                ? '{}'\r\n                : gap\r\n                ? '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}'\r\n                : '{' + partial.join(',') + '}';\r\n            gap = mind;\r\n            return v;\r\n        }\r\n    }\r\n\r\n// If the JSON object does not yet have a stringify method, give it one.\r\n\r\n    if (typeof JSON.stringify !== 'function') {\r\n        JSON.stringify = function (value, replacer, space) {\r\n\r\n// The stringify method takes a value and an optional replacer, and an optional\r\n// space parameter, and returns a JSON text. The replacer can be a function\r\n// that can replace values, or an array of strings that will select the keys.\r\n// A default replacer method can be provided. Use of the space parameter can\r\n// produce text that is more easily readable.\r\n\r\n            var i;\r\n            gap = '';\r\n            indent = '';\r\n\r\n// If the space parameter is a number, make an indent string containing that\r\n// many spaces.\r\n\r\n            if (typeof space === 'number') {\r\n                for (i = 0; i < space; i += 1) {\r\n                    indent += ' ';\r\n                }\r\n\r\n// If the space parameter is a string, it will be used as the indent string.\r\n\r\n            } else if (typeof space === 'string') {\r\n                indent = space;\r\n            }\r\n\r\n// If there is a replacer, it must be a function or an array.\r\n// Otherwise, throw an error.\r\n\r\n            rep = replacer;\r\n            if (replacer && typeof replacer !== 'function' &&\r\n                    (typeof replacer !== 'object' ||\r\n                    typeof replacer.length !== 'number')) {\r\n                throw new Error('JSON.stringify');\r\n            }\r\n\r\n// Make a fake root object containing our value under the key of ''.\r\n// Return the result of stringifying the value.\r\n\r\n            return str('', {'': value});\r\n        };\r\n    }\r\n\r\n\r\n// If the JSON object does not yet have a parse method, give it one.\r\n\r\n    if (typeof JSON.parse !== 'function') {\r\n        JSON.parse = function (text, reviver) {\r\n\r\n// The parse method takes a text and an optional reviver function, and returns\r\n// a JavaScript value if the text is a valid JSON text.\r\n\r\n            var j;\r\n\r\n            function walk(holder, key) {\r\n\r\n// The walk method is used to recursively walk the resulting structure so\r\n// that modifications can be made.\r\n\r\n                var k, v, value = holder[key];\r\n                if (value && typeof value === 'object') {\r\n                    for (k in value) {\r\n                        if (Object.prototype.hasOwnProperty.call(value, k)) {\r\n                            v = walk(value, k);\r\n                            if (v !== undefined) {\r\n                                value[k] = v;\r\n                            } else {\r\n                                delete value[k];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return reviver.call(holder, key, value);\r\n            }\r\n\r\n\r\n// Parsing happens in four stages. In the first stage, we replace certain\r\n// Unicode characters with escape sequences. JavaScript handles many characters\r\n// incorrectly, either silently deleting them, or treating them as line endings.\r\n\r\n            text = String(text);\r\n            cx.lastIndex = 0;\r\n            if (cx.test(text)) {\r\n                text = text.replace(cx, function (a) {\r\n                    return '\\\\u' +\r\n                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\r\n                });\r\n            }\r\n\r\n// In the second stage, we run the text against regular expressions that look\r\n// for non-JSON patterns. We are especially concerned with '()' and 'new'\r\n// because they can cause invocation, and '=' because it can cause mutation.\r\n// But just to be safe, we want to reject all unexpected forms.\r\n\r\n// We split the second stage into 4 regexp operations in order to work around\r\n// crippling inefficiencies in IE's and Safari's regexp engines. First we\r\n// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we\r\n// replace all simple value tokens with ']' characters. Third, we delete all\r\n// open brackets that follow a colon or comma or that begin the text. Finally,\r\n// we look to see that the remaining characters are only whitespace or ']' or\r\n// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.\r\n\r\n            if (/^[\\],:{}\\s]*$/\r\n                    .test(text.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')\r\n                        .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']')\r\n                        .replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''))) {\r\n\r\n// In the third stage we use the eval function to compile the text into a\r\n// JavaScript structure. The '{' operator is subject to a syntactic ambiguity\r\n// in JavaScript: it can begin a block or an object literal. We wrap the text\r\n// in parens to eliminate the ambiguity.\r\n\r\n                j = eval('(' + text + ')');\r\n\r\n// In the optional fourth stage, we recursively walk the new structure, passing\r\n// each name/value pair to a reviver function for possible transformation.\r\n\r\n                return typeof reviver === 'function'\r\n                    ? walk({'': j}, '')\r\n                    : j;\r\n            }\r\n\r\n// If the text is not JSON parseable, then a SyntaxError is thrown.\r\n\r\n            throw new SyntaxError('JSON.parse');\r\n        };\r\n    }\r\n}());\r\n","/*\r\n* qTip2 - Pretty powerful tooltips\r\n* http://craigsworks.com/projects/qtip2/\r\n*\r\n* Version: nightly\r\n* Copyright 2009-2010 Craig Michael Thompson - http://craigsworks.com\r\n*\r\n* Dual licensed under MIT or GPLv2 licenses\r\n*   http://en.wikipedia.org/wiki/MIT_License\r\n*   http://en.wikipedia.org/wiki/GNU_General_Public_License\r\n*\r\n* Date: Tue Apr 10 11:58:19.0000000000 2012\r\n*/\r\n\r\n/*jslint browser: true, onevar: true, undef: true, nomen: true, bitwise: true, regexp: true, newcap: true, immed: true, strict: true */\r\n/*global window: false, jQuery: false, console: false, define: false */\r\n\r\n// Uses AMD or browser globals to create a jQuery plugin.\r\n(function(factory) {\r\n\tif(typeof define === 'function' && define.amd) {\r\n\t\tdefine(['jquery'], factory);\r\n\t}\r\n\telse {\r\n\t\tfactory(jQuery);\r\n\t}\r\n}\r\n(function($) {\r\n\r\n\t\"use strict\"; // Enable ECMAScript \"strict\" operation for this function. See more: http://ejohn.org/blog/ecmascript-5-strict-mode-json-and-more/\r\n\t\r\n\t// Munge the primitives - Paul Irish tip\r\n\tvar TRUE = true,\r\n\t\tFALSE = false,\r\n\t\tNULL = null,\r\n\t\tundefined,\r\n\t\t\r\n\t\t// Shortcut vars\r\n\t\tQTIP, PLUGINS, MOUSE,\r\n\t\tusedIDs = {},\r\n\t\tuitooltip = 'ui-tooltip',\r\n\t\twidget = 'ui-widget',\r\n\t\tdisabled = 'ui-state-disabled',\r\n\t\tselector = 'div.qtip.'+uitooltip,\r\n\t\tdefaultClass = uitooltip + '-default',\r\n\t\tfocusClass = uitooltip + '-focus',\r\n\t\thoverClass = uitooltip + '-hover',\r\n\t\tfluidClass = uitooltip + '-fluid',\r\n\t\thideOffset = '-31000px',\r\n\t\treplaceSuffix = '_replacedByqTip',\r\n\t\toldtitle = 'oldtitle',\r\n\t\ttrackingBound;\r\n\t\t\r\n\t/* Thanks to Paul Irish for this one: http://paulirish.com/2009/log-a-lightweight-wrapper-for-consolelog/ */\r\n\tfunction log() {\r\n\t\tlog.history = log.history || [];\r\n\t\tlog.history.push(arguments);\r\n\t\t\r\n\t\t// Make sure console is present\r\n\t\tif('object' === typeof console) {\r\n\r\n\t\t\t// Setup console and arguments\r\n\t\t\tvar c = console[ console.warn ? 'warn' : 'log' ],\r\n\t\t\targs = Array.prototype.slice.call(arguments), a;\r\n\r\n\t\t\t// Add qTip2 marker to first argument if it's a string\r\n\t\t\tif(typeof arguments[0] === 'string') { args[0] = 'qTip2: ' + args[0]; }\r\n\r\n\t\t\t// Apply console.warn or .log if not supported\r\n\t\t\ta = c.apply ? c.apply(console, args) : c(args);\r\n\t\t}\r\n\t}\r\n\r\n// Option object sanitizer\r\nfunction sanitizeOptions(opts)\r\n{\r\n\tvar content;\r\n\r\n\tif(!opts || 'object' !== typeof opts) { return FALSE; }\r\n\r\n\tif(opts.metadata === NULL || 'object' !== typeof opts.metadata) {\r\n\t\topts.metadata = {\r\n\t\t\ttype: opts.metadata\r\n\t\t};\r\n\t}\r\n\r\n\tif('content' in opts) {\r\n\t\tif(opts.content === NULL || 'object' !== typeof opts.content || opts.content.jquery) {\r\n\t\t\topts.content = {\r\n\t\t\t\ttext: opts.content\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tcontent = opts.content.text || FALSE;\r\n\t\tif(!$.isFunction(content) && ((!content && !content.attr) || content.length < 1 || ('object' === typeof content && !content.jquery))) {\r\n\t\t\topts.content.text = FALSE;\r\n\t\t}\r\n\r\n\t\tif('title' in opts.content) {\r\n\t\t\tif(opts.content.title === NULL || 'object' !== typeof opts.content.title) {\r\n\t\t\t\topts.content.title = {\r\n\t\t\t\t\ttext: opts.content.title\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tcontent = opts.content.title.text || FALSE;\r\n\t\t\tif(!$.isFunction(content) && ((!content && !content.attr) || content.length < 1 || ('object' === typeof content && !content.jquery))) {\r\n\t\t\t\topts.content.title.text = FALSE;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif('position' in opts) {\r\n\t\tif(opts.position === NULL || 'object' !== typeof opts.position) {\r\n\t\t\topts.position = {\r\n\t\t\t\tmy: opts.position,\r\n\t\t\t\tat: opts.position\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\tif('show' in opts) {\r\n\t\tif(opts.show === NULL || 'object' !== typeof opts.show) {\r\n\t\t\tif(opts.show.jquery) {\r\n\t\t\t\topts.show = { target: opts.show };\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\topts.show = { event: opts.show };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif('hide' in opts) {\r\n\t\tif(opts.hide === NULL || 'object' !== typeof opts.hide) {\r\n\t\t\tif(opts.hide.jquery) {\r\n\t\t\t\topts.hide = { target: opts.hide };\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\topts.hide = { event: opts.hide };\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif('style' in opts) {\r\n\t\tif(opts.style === NULL || 'object' !== typeof opts.style) {\r\n\t\t\topts.style = {\r\n\t\t\t\tclasses: opts.style\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\t// Sanitize plugin options\r\n\t$.each(PLUGINS, function() {\r\n\t\tif(this.sanitize) { this.sanitize(opts); }\r\n\t});\r\n\t\r\n\treturn opts;\r\n}\r\n\r\n/*\r\n* Core plugin implementation\r\n*/\r\nfunction QTip(target, options, id, attr)\r\n{\r\n\t// Declare this reference\r\n\tvar self = this,\r\n\t\tdocBody = document.body,\r\n\t\ttooltipID = uitooltip + '-' + id,\r\n\t\tisPositioning = 0,\r\n\t\tisDrawing = 0,\r\n\t\ttooltip = $(),\r\n\t\tnamespace = '.qtip-' + id,\r\n\t\telements, cache;\r\n\r\n\t// Setup class attributes\r\n\tself.id = id;\r\n\tself.rendered = FALSE;\r\n\tself.elements = elements = { target: target };\r\n\tself.timers = { img: {} };\r\n\tself.options = options;\r\n\tself.checks = {};\r\n\tself.plugins = {};\r\n\tself.cache = cache = {\r\n\t\tevent: {},\r\n\t\ttarget: $(),\r\n\t\tdisabled: FALSE,\r\n\t\tattr: attr,\r\n\t\tonTarget: FALSE\r\n\t};\r\n\r\n\t/*\r\n\t* Private core functions\r\n\t*/\r\n\tfunction convertNotation(notation)\r\n\t{\r\n\t\tvar i = 0, obj, option = options, \r\n\r\n\t\t// Split notation into array\r\n\t\tlevels = notation.split('.');\r\n\r\n\t\t// Loop through\r\n\t\twhile( option = option[ levels[i++] ] ) {\r\n\t\t\tif(i < levels.length) { obj = option; }\r\n\t\t}\r\n\r\n\t\treturn [obj || options, levels.pop()];\r\n\t}\r\n\r\n\tfunction setWidget() {\r\n\t\tvar on = options.style.widget;\r\n\r\n\t\ttooltip.toggleClass(widget, on).toggleClass(defaultClass, options.style.def && !on);\r\n\t\telements.content.toggleClass(widget+'-content', on);\r\n\t\t\r\n\t\tif(elements.titlebar){\r\n\t\t\telements.titlebar.toggleClass(widget+'-header', on);\r\n\t\t}\r\n\t\tif(elements.button){\r\n\t\t\telements.button.toggleClass(uitooltip+'-icon', !on);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removeTitle(reposition)\r\n\t{\r\n\t\tif(elements.title) {\r\n\t\t\telements.titlebar.remove();\r\n\t\t\telements.titlebar = elements.title = elements.button = NULL;\r\n\r\n\t\t\t// Reposition if enabled\r\n\t\t\tif(reposition !== FALSE) { self.reposition(); }\r\n\t\t}\r\n\t}\r\n\r\n\tfunction createButton()\r\n\t{\r\n\t\tvar button = options.content.title.button,\r\n\t\t\tisString = typeof button === 'string',\r\n\t\t\tclose = isString ? button : 'Close tooltip';\r\n\r\n\t\tif(elements.button) { elements.button.remove(); }\r\n\r\n\t\t// Use custom button if one was supplied by user, else use default\r\n\t\tif(button.jquery) {\r\n\t\t\telements.button = button;\r\n\t\t}\r\n\t\telse {\r\n\t\t\telements.button = $('<a />', {\r\n\t\t\t\t'class': 'ui-state-default ui-tooltip-close ' + (options.style.widget ? '' : uitooltip+'-icon'),\r\n\t\t\t\t'title': close,\r\n\t\t\t\t'aria-label': close\r\n\t\t\t})\r\n\t\t\t.prepend(\r\n\t\t\t\t$('<span />', {\r\n\t\t\t\t\t'class': 'ui-icon ui-icon-close',\r\n\t\t\t\t\t'html': '&times;'\r\n\t\t\t\t})\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// Create button and setup attributes\r\n\t\telements.button.appendTo(elements.titlebar)\r\n\t\t\t.attr('role', 'button')\r\n\t\t\t.click(function(event) {\r\n\t\t\t\tif(!tooltip.hasClass(disabled)) { self.hide(event); }\r\n\t\t\t\treturn FALSE;\r\n\t\t\t});\r\n\r\n\t\t// Redraw the tooltip when we're done\r\n\t\tself.redraw();\r\n\t}\r\n\r\n\tfunction createTitle()\r\n\t{\r\n\t\tvar id = tooltipID+'-title';\r\n\r\n\t\t// Destroy previous title element, if present\r\n\t\tif(elements.titlebar) { removeTitle(); }\r\n\r\n\t\t// Create title bar and title elements\r\n\t\telements.titlebar = $('<div />', {\r\n\t\t\t'class': uitooltip + '-titlebar ' + (options.style.widget ? 'ui-widget-header' : '')\r\n\t\t})\r\n\t\t.append(\r\n\t\t\telements.title = $('<div />', {\r\n\t\t\t\t'id': id,\r\n\t\t\t\t'class': uitooltip + '-title',\r\n\t\t\t\t'aria-atomic': TRUE\r\n\t\t\t})\r\n\t\t)\r\n\t\t.insertBefore(elements.content)\r\n\r\n\t\t// Button-specific events\r\n\t\t.delegate('.ui-tooltip-close', 'mousedown keydown mouseup keyup mouseout', function(event) {\r\n\t\t\t$(this).toggleClass('ui-state-active ui-state-focus', event.type.substr(-4) === 'down');\r\n\t\t})\r\n\t\t.delegate('.ui-tooltip-close', 'mouseover mouseout', function(event){\r\n\t\t\t$(this).toggleClass('ui-state-hover', event.type === 'mouseover');\r\n\t\t});\r\n\r\n\t\t// Create button if enabled\r\n\t\tif(options.content.title.button) { createButton(); }\r\n\r\n\t\t// Redraw the tooltip dimensions if it's rendered\r\n\t\telse if(self.rendered){ self.redraw(); } \r\n\t}\r\n\r\n\tfunction updateButton(button)\r\n\t{\r\n\t\tvar elem = elements.button,\r\n\t\t\ttitle = elements.title;\r\n\r\n\t\t// Make sure tooltip is rendered and if not, return\r\n\t\tif(!self.rendered) { return FALSE; }\r\n\r\n\t\tif(!button) {\r\n\t\t\telem.remove();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif(!title) {\r\n\t\t\t\tcreateTitle();\r\n\t\t\t}\r\n\t\t\tcreateButton();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction updateTitle(content, reposition)\r\n\t{\r\n\t\tvar elem = elements.title;\r\n\r\n\t\t// Make sure tooltip is rendered and if not, return\r\n\t\tif(!self.rendered || !content) { return FALSE; }\r\n\r\n\t\t// Use function to parse content\r\n\t\tif($.isFunction(content)) {\r\n\t\t\tcontent = content.call(target, cache.event, self);\r\n\t\t}\r\n\r\n\t\t// Remove title if callback returns false or null/undefined (but not '')\r\n\t\tif(content === FALSE || (!content && content !== '')) { return removeTitle(FALSE); }\r\n\r\n\t\t// Append new content if its a DOM array and show it if hidden\r\n\t\telse if(content.jquery && content.length > 0) {\r\n\t\t\telem.empty().append(content.css({ display: 'block' }));\r\n\t\t}\r\n\r\n\t\t// Content is a regular string, insert the new content\r\n\t\telse { elem.html(content); }\r\n\r\n\t\t// Redraw and reposition\r\n\t\tself.redraw();\r\n\t\tif(reposition !== FALSE && self.rendered && tooltip[0].offsetWidth > 0) {\r\n\t\t\tself.reposition(cache.event);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction updateContent(content, reposition)\r\n\t{\r\n\t\tvar elem = elements.content;\r\n\r\n\t\t// Make sure tooltip is rendered and content is defined. If not return\r\n\t\tif(!self.rendered || !content) { return FALSE; }\r\n\r\n\t\t// Use function to parse content\r\n\t\tif($.isFunction(content)) {\r\n\t\t\tcontent = content.call(target, cache.event, self) || '';\r\n\t\t}\r\n\r\n\t\t// Append new content if its a DOM array and show it if hidden\r\n\t\tif(content.jquery && content.length > 0) {\r\n\t\t\telem.empty().append(content.css({ display: 'block' }));\r\n\t\t}\r\n\r\n\t\t// Content is a regular string, insert the new content\r\n\t\telse { elem.html(content); }\r\n\r\n\t\t// Image detection\r\n\t\tfunction detectImages(next) {\r\n\t\t\tvar images, srcs = {};\r\n\r\n\t\t\tfunction imageLoad(image) {\r\n\t\t\t\t// Clear src from object and any timers and events associated with the image\r\n\t\t\t\tif(image) {\r\n\t\t\t\t\tdelete srcs[image.src];\r\n\t\t\t\t\tclearTimeout(self.timers.img[image.src]);\r\n\t\t\t\t\t$(image).unbind(namespace);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If queue is empty after image removal, update tooltip and continue the queue\r\n\t\t\t\tif($.isEmptyObject(srcs)) {\r\n\t\t\t\t\tself.redraw();\r\n\t\t\t\t\tif(reposition !== FALSE) {\r\n\t\t\t\t\t\tself.reposition(cache.event);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tnext();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Find all content images without dimensions, and if no images were found, continue\r\n\t\t\tif((images = elem.find('img[src]:not([height]):not([width])')).length === 0) { return imageLoad(); }\r\n\r\n\t\t\t// Apply timer to each image to poll for dimensions\r\n\t\t\timages.each(function(i, elem) {\r\n\t\t\t\t// Skip if the src is already present\r\n\t\t\t\tif(srcs[elem.src] !== undefined) { return; }\r\n\r\n\t\t\t\t// Keep track of how many times we poll for image dimensions.\r\n\t\t\t\t// If it doesn't return in a reasonable amount of time, it's better\r\n\t\t\t\t// to display the tooltip, rather than hold up the queue.\r\n\t\t\t\tvar iterations = 0, maxIterations = 3;\r\n\r\n\t\t\t\t(function timer(){\r\n\t\t\t\t\t// When the dimensions are found, remove the image from the queue\r\n\t\t\t\t\tif(elem.height || elem.width || (iterations > maxIterations)) { return imageLoad(elem); }\r\n\r\n\t\t\t\t\t// Increase iterations and restart timer\r\n\t\t\t\t\titerations += 1;\r\n\t\t\t\t\tself.timers.img[elem.src] = setTimeout(timer, 700);\r\n\t\t\t\t}());  \r\n\r\n\t\t\t\t// Also apply regular load/error event handlers\r\n\t\t\t\t$(elem).bind('error'+namespace+' load'+namespace, function(){ imageLoad(this); });\r\n\r\n\t\t\t\t// Store the src and element in our object\r\n\t\t\t\tsrcs[elem.src] = elem;\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If we're still rendering... insert into 'fx' queue our image dimension\r\n\t\t * checker which will halt the showing of the tooltip until image dimensions\r\n\t\t * can be detected properly.\r\n\t\t */\r\n\t\tif(self.rendered < 0) { tooltip.queue('fx', detectImages); }\r\n\r\n\t\t// We're fully rendered, so reset isDrawing flag and proceed without queue delay\r\n\t\telse { isDrawing = 0; detectImages($.noop); }\r\n\r\n\t\treturn self;\r\n\t}\r\n\r\n\tfunction assignEvents()\r\n\t{\r\n\t\tvar posOptions = options.position,\r\n\t\t\ttargets = {\r\n\t\t\t\tshow: options.show.target,\r\n\t\t\t\thide: options.hide.target,\r\n\t\t\t\tviewport: $(posOptions.viewport),\r\n\t\t\t\tdocument: $(document),\r\n\t\t\t\tbody: $(document.body),\r\n\t\t\t\twindow: $(window)\r\n\t\t\t},\r\n\t\t\tevents = {\r\n\t\t\t\tshow: $.trim('' + options.show.event).split(' '),\r\n\t\t\t\thide: $.trim('' + options.hide.event).split(' ')\r\n\t\t\t},\r\n\t\t\tIE6 = $.browser.msie && parseInt($.browser.version, 10) === 6;\r\n\r\n\t\t// Define show event method\r\n\t\tfunction showMethod(event)\r\n\t\t{\r\n\t\t\tif(tooltip.hasClass(disabled)) { return FALSE; }\r\n\r\n\t\t\t// Clear hide timers\r\n\t\t\tclearTimeout(self.timers.show);\r\n\t\t\tclearTimeout(self.timers.hide);\r\n\r\n\t\t\t// Start show timer\r\n\t\t\tvar callback = function(){ self.toggle(TRUE, event); };\r\n\t\t\tif(options.show.delay > 0) {\r\n\t\t\t\tself.timers.show = setTimeout(callback, options.show.delay);\r\n\t\t\t}\r\n\t\t\telse{ callback(); }\r\n\t\t}\r\n\r\n\t\t// Define hide method\r\n\t\tfunction hideMethod(event)\r\n\t\t{\r\n\t\t\tif(tooltip.hasClass(disabled) || isPositioning || isDrawing) { return FALSE; }\r\n\r\n\t\t\t// Check if new target was actually the tooltip element\r\n\t\t\tvar relatedTarget = $(event.relatedTarget || event.target),\r\n\t\t\t\tontoTooltip = relatedTarget.closest(selector)[0] === tooltip[0],\r\n\t\t\t\tontoTarget = relatedTarget[0] === targets.show[0];\r\n\r\n\t\t\t// Clear timers and stop animation queue\r\n\t\t\tclearTimeout(self.timers.show);\r\n\t\t\tclearTimeout(self.timers.hide);\r\n\r\n\t\t\t// Prevent hiding if tooltip is fixed and event target is the tooltip. Or if mouse positioning is enabled and cursor momentarily overlaps\r\n\t\t\tif((posOptions.target === 'mouse' && ontoTooltip) || (options.hide.fixed && ((/mouse(out|leave|move)/).test(event.type) && (ontoTooltip || ontoTarget)))) {\r\n\t\t\t\ttry { event.preventDefault(); event.stopImmediatePropagation(); } catch(e) {} return;\r\n\t\t\t}\r\n\r\n\t\t\t// If tooltip has displayed, start hide timer\r\n\t\t\tif(options.hide.delay > 0) {\r\n\t\t\t\tself.timers.hide = setTimeout(function(){ self.hide(event); }, options.hide.delay);\r\n\t\t\t}\r\n\t\t\telse{ self.hide(event); }\r\n\t\t}\r\n\r\n\t\t// Define inactive method\r\n\t\tfunction inactiveMethod(event)\r\n\t\t{\r\n\t\t\tif(tooltip.hasClass(disabled)) { return FALSE; }\r\n\r\n\t\t\t// Clear timer\r\n\t\t\tclearTimeout(self.timers.inactive);\r\n\t\t\tself.timers.inactive = setTimeout(function(){ self.hide(event); }, options.hide.inactive);\r\n\t\t}\r\n\r\n\t\tfunction repositionMethod(event) {\r\n\t\t\tif(self.rendered && tooltip[0].offsetWidth > 0) { self.reposition(event); }\r\n\t\t}\r\n\r\n\t\t// On mouseenter/mouseleave...\r\n\t\ttooltip.bind('mouseenter'+namespace+' mouseleave'+namespace, function(event) {\r\n\t\t\tvar state = event.type === 'mouseenter';\r\n\r\n\t\t\t// Focus the tooltip on mouseenter (z-index stacking)\r\n\t\t\tif(state) { self.focus(event); }\r\n\r\n\t\t\t// Add hover class\r\n\t\t\ttooltip.toggleClass(hoverClass, state);\r\n\t\t});\r\n\r\n\t\t// Enable hide.fixed\r\n\t\tif(options.hide.fixed) {\r\n\t\t\t// Add tooltip as a hide target\r\n\t\t\ttargets.hide = targets.hide.add(tooltip);\r\n\r\n\t\t\t// Clear hide timer on tooltip hover to prevent it from closing\r\n\t\t\ttooltip.bind('mouseover'+namespace, function() {\r\n\t\t\t\tif(!tooltip.hasClass(disabled)) { clearTimeout(self.timers.hide); }\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// If using mouseout/mouseleave as a hide event...\r\n\t\tif(/mouse(out|leave)/i.test(options.hide.event)) {\r\n\t\t\t// Hide tooltips when leaving current window/frame (but not select/option elements)\r\n\t\t\tif(options.hide.leave === 'window') {\r\n\t\t\t\ttargets.window.bind('mouseout'+namespace+' blur'+namespace, function(event) {\r\n\t\t\t\t\tif(/select|option/.test(event.target) && !event.relatedTarget) { self.hide(event); }\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Make sure hoverIntent functions properly by using mouseleave to clear show timer if\r\n\t\t * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\r\n\t\t */\r\n\t\telse if(/mouse(over|enter)/i.test(options.show.event)) {\r\n\t\t\ttargets.hide.bind('mouseleave'+namespace, function(event) {\r\n\t\t\t\tclearTimeout(self.timers.show);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Hide tooltip on document mousedown if unfocus events are enabled\r\n\t\tif(('' + options.hide.event).indexOf('unfocus') > -1) {\r\n\t\t\tposOptions.container.closest('html').bind('mousedown'+namespace, function(event) {\r\n\t\t\t\tvar elem = $(event.target),\r\n\t\t\t\t\tenabled = self.rendered && !tooltip.hasClass(disabled) && tooltip[0].offsetWidth > 0,\r\n\t\t\t\t\tisAncestor = elem.parents(selector).filter(tooltip[0]).length > 0;\r\n\r\n\t\t\t\tif(elem[0] !== target[0] && elem[0] !== tooltip[0] && !isAncestor &&\r\n\t\t\t\t\t!target.has(elem[0]).length && !elem.attr('disabled')\r\n\t\t\t\t) {\r\n\t\t\t\t\tself.hide(event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Check if the tooltip hides when inactive\r\n\t\tif('number' === typeof options.hide.inactive) {\r\n\t\t\t// Bind inactive method to target as a custom event\r\n\t\t\ttargets.show.bind('qtip-'+id+'-inactive', inactiveMethod);\r\n\t\t\t\r\n\t\t\t// Define events which reset the 'inactive' event handler\r\n\t\t\t$.each(QTIP.inactiveEvents, function(index, type){\r\n\t\t\t\ttargets.hide.add(elements.tooltip).bind(type+namespace+'-inactive', inactiveMethod);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Apply hide events\r\n\t\t$.each(events.hide, function(index, type) {\r\n\t\t\tvar showIndex = $.inArray(type, events.show),\r\n\t\t\t\t\ttargetHide = $(targets.hide);\r\n\r\n\t\t\t// Both events and targets are identical, apply events using a toggle\r\n\t\t\tif((showIndex > -1 && targetHide.add(targets.show).length === targetHide.length) || type === 'unfocus')\r\n\t\t\t{\r\n\t\t\t\ttargets.show.bind(type+namespace, function(event) {\r\n\t\t\t\t\tif(tooltip[0].offsetWidth > 0) { hideMethod(event); }\r\n\t\t\t\t\telse { showMethod(event); }\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// Don't bind the event again\r\n\t\t\t\tdelete events.show[ showIndex ];\r\n\t\t\t}\r\n\r\n\t\t\t// Events are not identical, bind normally\r\n\t\t\telse { targets.hide.bind(type+namespace, hideMethod); }\r\n\t\t});\r\n\r\n\t\t// Apply show events\r\n\t\t$.each(events.show, function(index, type) {\r\n\t\t\ttargets.show.bind(type+namespace, showMethod);\r\n\t\t});\r\n\r\n\t\t// Check if the tooltip hides when mouse is moved a certain distance\r\n\t\tif('number' === typeof options.hide.distance) {\r\n\t\t\t// Bind mousemove to target to detect distance difference\r\n\t\t\ttargets.show.add(tooltip).bind('mousemove'+namespace, function(event) {\r\n\t\t\t\tvar origin = cache.origin || {},\r\n\t\t\t\t\tlimit = options.hide.distance,\r\n\t\t\t\t\tabs = Math.abs;\r\n\r\n\t\t\t\t// Check if the movement has gone beyond the limit, and hide it if so\r\n\t\t\t\tif(abs(event.pageX - origin.pageX) >= limit || abs(event.pageY - origin.pageY) >= limit) {\r\n\t\t\t\t\tself.hide(event);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Mouse positioning events\r\n\t\tif(posOptions.target === 'mouse') {\r\n\t\t\t// Cache mousemove coords on show targets\r\n\t\t\ttargets.show.bind('mousemove'+namespace, function(event) {\r\n\t\t\t\tMOUSE = { pageX: event.pageX, pageY: event.pageY, type: 'mousemove' };\r\n\t\t\t});\r\n\r\n\t\t\t// If mouse adjustment is on...\r\n\t\t\tif(posOptions.adjust.mouse) {\r\n\t\t\t\t// Apply a mouseleave event so we don't get problems with overlapping\r\n\t\t\t\tif(options.hide.event) {\r\n\t\t\t\t\t// Hide when we leave the tooltip and not onto the show target\r\n\t\t\t\t\ttooltip.bind('mouseleave'+namespace, function(event) {\r\n\t\t\t\t\t\tif((event.relatedTarget || event.target) !== targets.show[0]) { self.hide(event); }\r\n\t\t\t\t\t});\r\n\r\n\t\t\t\t\t// Track if we're on the target or not\r\n\t\t\t\t\telements.target.bind('mouseenter'+namespace+' mouseleave'+namespace, function(event) {\r\n\t\t\t\t\t\tcache.onTarget = event.type === 'mouseenter';\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Update tooltip position on mousemove\r\n\t\t\t\ttargets.document.bind('mousemove'+namespace, function(event) {\r\n\t\t\t\t\t// Update the tooltip position only if the tooltip is visible and adjustment is enabled\r\n\t\t\t\t\tif(self.rendered && cache.onTarget && !tooltip.hasClass(disabled) && tooltip[0].offsetWidth > 0) {\r\n\t\t\t\t\t\tself.reposition(event || MOUSE);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Adjust positions of the tooltip on window resize if enabled\r\n\t\tif(posOptions.adjust.resize || targets.viewport.length) {\r\n\t\t\t($.event.special.resize ? targets.viewport : targets.window).bind('resize'+namespace, repositionMethod);\r\n\t\t}\r\n\r\n\t\t// Adjust tooltip position on scroll if screen adjustment is enabled\r\n\t\tif(targets.viewport.length || (IE6 && tooltip.css('position') === 'fixed')) {\r\n\t\t\ttargets.viewport.bind('scroll'+namespace, repositionMethod);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unassignEvents()\r\n\t{\r\n\t\tvar targets = [\r\n\t\t\t\toptions.show.target[0],\r\n\t\t\t\toptions.hide.target[0],\r\n\t\t\t\tself.rendered && elements.tooltip[0],\r\n\t\t\t\toptions.position.container[0],\r\n\t\t\t\toptions.position.viewport[0],\r\n\t\t\t\twindow,\r\n\t\t\t\tdocument\r\n\t\t\t];\r\n\r\n\t\t// Check if tooltip is rendered\r\n\t\tif(self.rendered) {\r\n\t\t\t$([]).pushStack( $.grep(targets, function(i){ return typeof i === 'object'; }) ).unbind(namespace);\r\n\t\t}\r\n\r\n\t\t// Tooltip isn't yet rendered, remove render event\r\n\t\telse { options.show.target.unbind(namespace+'-create'); }\r\n\t}\r\n\r\n\t// Setup builtin .set() option checks\r\n\tself.checks.builtin = {\r\n\t\t// Core checks\r\n\t\t'^id$': function(obj, o, v) {\r\n\t\t\tvar id = v === TRUE ? QTIP.nextid : v,\r\n\t\t\t\ttooltipID = uitooltip + '-' + id;\r\n\r\n\t\t\tif(id !== FALSE && id.length > 0 && !$('#'+tooltipID).length) {\r\n\t\t\t\ttooltip[0].id = tooltipID;\r\n\t\t\t\telements.content[0].id = tooltipID + '-content';\r\n\t\t\t\telements.title[0].id = tooltipID + '-title';\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Content checks\r\n\t\t'^content.text$': function(obj, o, v){ updateContent(v); },\r\n\t\t'^content.title.text$': function(obj, o, v) {\r\n\t\t\t// Remove title if content is null\r\n\t\t\tif(!v) { return removeTitle(); }\r\n\r\n\t\t\t// If title isn't already created, create it now and update\r\n\t\t\tif(!elements.title && v) { createTitle(); }\r\n\t\t\tupdateTitle(v);\r\n\t\t},\r\n\t\t'^content.title.button$': function(obj, o, v){ updateButton(v); },\r\n\r\n\t\t// Position checks\r\n\t\t'^position.(my|at)$': function(obj, o, v){\r\n\t\t\t// Parse new corner value into Corner objecct\r\n\t\t\tif('string' === typeof v) {\r\n\t\t\t\tobj[o] = new PLUGINS.Corner(v);\r\n\t\t\t}\r\n\t\t},\r\n\t\t'^position.container$': function(obj, o, v){\r\n\t\t\tif(self.rendered) { tooltip.appendTo(v); }\r\n\t\t},\r\n\r\n\t\t// Show checks\r\n\t\t'^show.ready$': function() {\r\n\t\t\tif(!self.rendered) { self.render(1); }\r\n\t\t\telse { self.toggle(TRUE); }\r\n\t\t},\r\n\r\n\t\t// Style checks\r\n\t\t'^style.classes$': function(obj, o, v) { \r\n\t\t\ttooltip.attr('class', uitooltip + ' qtip ui-helper-reset ' + v);\r\n\t\t},\r\n\t\t'^style.widget|content.title': setWidget,\r\n\r\n\t\t// Events check\r\n\t\t'^events.(render|show|move|hide|focus|blur)$': function(obj, o, v) {\r\n\t\t\ttooltip[($.isFunction(v) ? '' : 'un') + 'bind']('tooltip'+o, v);\r\n\t\t},\r\n\r\n\t\t// Properties which require event reassignment\r\n\t\t'^(show|hide|position).(event|target|fixed|inactive|leave|distance|viewport|adjust)': function() {\r\n\t\t\tvar posOptions = options.position;\r\n\r\n\t\t\t// Set tracking flag\r\n\t\t\ttooltip.attr('tracking', posOptions.target === 'mouse' && posOptions.adjust.mouse);\r\n\r\n\t\t\t// Reassign events\r\n\t\t\tunassignEvents(); assignEvents();\r\n\t\t}\r\n\t};\r\n\r\n\t/*\r\n\t* Public API methods\r\n\t*/\r\n\t$.extend(self, {\r\n\t\trender: function(show)\r\n\t\t{\r\n\t\t\tif(self.rendered) { return self; } // If tooltip has already been rendered, exit\r\n\r\n\t\t\tvar text = options.content.text,\r\n\t\t\t\ttitle = options.content.title.text,\r\n\t\t\t\tposOptions = options.position,\r\n\t\t\t\tcallback = $.Event('tooltiprender');\r\n\r\n\t\t\t// Add ARIA attributes to target\r\n\t\t\t$.attr(target[0], 'aria-describedby', tooltipID);\r\n\r\n\t\t\t// Create tooltip element\r\n\t\t\ttooltip = elements.tooltip = $('<div/>', {\r\n\t\t\t\t\t'id': tooltipID,\r\n\t\t\t\t\t'class': uitooltip + ' qtip ui-helper-reset ' + defaultClass + ' ' + options.style.classes + ' '+ uitooltip + '-pos-' + options.position.my.abbrev(),\r\n\t\t\t\t\t'width': options.style.width || '',\r\n\t\t\t\t\t'height': options.style.height || '',\r\n\t\t\t\t\t'tracking': posOptions.target === 'mouse' && posOptions.adjust.mouse,\r\n\r\n\t\t\t\t\t/* ARIA specific attributes */\r\n\t\t\t\t\t'role': 'alert',\r\n\t\t\t\t\t'aria-live': 'polite',\r\n\t\t\t\t\t'aria-atomic': FALSE,\r\n\t\t\t\t\t'aria-describedby': tooltipID + '-content',\r\n\t\t\t\t\t'aria-hidden': TRUE\r\n\t\t\t\t})\r\n\t\t\t\t.toggleClass(disabled, cache.disabled)\r\n\t\t\t\t.data('qtip', self)\r\n\t\t\t\t.appendTo(options.position.container)\r\n\t\t\t\t.append(\r\n\t\t\t\t\t// Create content element\r\n\t\t\t\t\telements.content = $('<div />', {\r\n\t\t\t\t\t\t'class': uitooltip + '-content',\r\n\t\t\t\t\t\t'id': tooltipID + '-content',\r\n\t\t\t\t\t\t'aria-atomic': TRUE\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\r\n\t\t\t// Set rendered flag and prevent redundant redraw/reposition calls for now\r\n\t\t\tself.rendered = -1;\r\n\t\t\tisDrawing = 1; isPositioning = 1;\r\n\r\n\t\t\t// Create title...\r\n\t\t\tif(title) { \r\n\t\t\t\tcreateTitle();\r\n\r\n\t\t\t\t// Update title only if its not a callback (called in toggle if so)\r\n\t\t\t\tif(!$.isFunction(title)) { updateTitle(title, FALSE); }\r\n\t\t\t}\r\n\r\n\t\t\t// Set proper rendered flag and update content if not a callback function (called in toggle)\r\n\t\t\tif(!$.isFunction(text)) { updateContent(text, FALSE); }\r\n\t\t\tself.rendered = TRUE;\r\n\r\n\t\t\t// Setup widget classes\r\n\t\t\tsetWidget();\r\n\r\n\t\t\t// Assign passed event callbacks (before plugins!)\r\n\t\t\t$.each(options.events, function(name, callback) {\r\n\t\t\t\tif($.isFunction(callback)) {\r\n\t\t\t\t\ttooltip.bind(name === 'toggle' ? 'tooltipshow tooltiphide' : 'tooltip'+name, callback);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Initialize 'render' plugins\r\n\t\t\t$.each(PLUGINS, function() {\r\n\t\t\t\tif(this.initialize === 'render') { this(self); }\r\n\t\t\t});\r\n\r\n\t\t\t// Assign events\r\n\t\t\tassignEvents();\r\n\r\n\t\t\t/* Queue this part of the render process in our fx queue so we can\r\n\t\t\t * load images before the tooltip renders fully.\r\n\t\t\t *\r\n\t\t\t * See: updateContent method\r\n\t\t\t*/\r\n\t\t\ttooltip.queue('fx', function(next) {\r\n\t\t\t\t// Trigger tooltiprender event and pass original triggering event as original\r\n\t\t\t\tcallback.originalEvent = cache.event;\r\n\t\t\t\ttooltip.trigger(callback, [self]);\r\n\r\n\t\t\t\t// Reset flags\r\n\t\t\t\tisDrawing = 0; isPositioning = 0;\r\n\r\n\t\t\t\t// Redraw the tooltip manually now we're fully rendered\r\n\t\t\t\tself.redraw();\r\n\r\n\t\t\t\t// Show tooltip if needed\r\n\t\t\t\tif(options.show.ready || show) {\r\n\t\t\t\t\tself.toggle(TRUE, cache.event, FALSE);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnext(); // Move on to next method in queue\r\n\t\t\t});\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tget: function(notation)\r\n\t\t{\r\n\t\t\tvar result, o;\r\n\r\n\t\t\tswitch(notation.toLowerCase())\r\n\t\t\t{\r\n\t\t\t\tcase 'dimensions':\r\n\t\t\t\t\tresult = {\r\n\t\t\t\t\t\theight: tooltip.outerHeight(), width: tooltip.outerWidth()\r\n\t\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'offset':\r\n\t\t\t\t\tresult = PLUGINS.offset(tooltip, options.position.container);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\to = convertNotation(notation.toLowerCase());\r\n\t\t\t\t\tresult = o[0][ o[1] ];\r\n\t\t\t\t\tresult = result.precedance ? result.string() : result;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\t\t},\r\n\r\n\t\tset: function(option, value)\r\n\t\t{\r\n\t\t\tvar rmove = /^position\\.(my|at|adjust|target|container)|style|content|show\\.ready/i,\r\n\t\t\t\trdraw = /^content\\.(title|attr)|style/i,\r\n\t\t\t\treposition = FALSE,\r\n\t\t\t\tredraw = FALSE,\r\n\t\t\t\tchecks = self.checks,\r\n\t\t\t\tname;\r\n\r\n\t\t\tfunction callback(notation, args) {\r\n\t\t\t\tvar category, rule, match;\r\n\r\n\t\t\t\tfor(category in checks) {\r\n\t\t\t\t\tfor(rule in checks[category]) {\r\n\t\t\t\t\t\tif(match = (new RegExp(rule, 'i')).exec(notation)) {\r\n\t\t\t\t\t\t\targs.push(match);\r\n\t\t\t\t\t\t\tchecks[category][rule].apply(self, args);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Convert singular option/value pair into object form\r\n\t\t\tif('string' === typeof option) {\r\n\t\t\t\tname = option; option = {}; option[name] = value;\r\n\t\t\t}\r\n\t\t\telse { option = $.extend(TRUE, {}, option); }\r\n\r\n\t\t\t// Set all of the defined options to their new values\r\n\t\t\t$.each(option, function(notation, value) {\r\n\t\t\t\tvar obj = convertNotation( notation.toLowerCase() ), previous;\r\n\r\n\t\t\t\t// Set new obj value\r\n\t\t\t\tprevious = obj[0][ obj[1] ];\r\n\t\t\t\tobj[0][ obj[1] ] = 'object' === typeof value && value.nodeType ? $(value) : value;\r\n\r\n\t\t\t\t// Set the new params for the callback\r\n\t\t\t\toption[notation] = [obj[0], obj[1], value, previous];\r\n\r\n\t\t\t\t// Also check if we need to reposition / redraw\r\n\t\t\t\treposition = rmove.test(notation) || reposition;\r\n\t\t\t\tredraw = rdraw.test(notation) || redraw;\r\n\t\t\t});\r\n\r\n\t\t\t// Re-sanitize options\r\n\t\t\tsanitizeOptions(options);\r\n\r\n\t\t\t/*\r\n\t\t\t * Execute any valid callbacks for the set options\r\n\t\t\t * Also set isPositioning/isDrawing so we don't get loads of redundant repositioning\r\n\t\t\t * and redraw calls.\r\n\t\t\t */\r\n\t\t\tisPositioning = isDrawing = 1; $.each(option, callback); isPositioning = isDrawing = 0;\r\n\r\n\t\t\t// Update position / redraw if needed\r\n\t\t\tif(self.rendered && tooltip[0].offsetWidth > 0) {\r\n\t\t\t\tif(reposition) {\r\n\t\t\t\t\tself.reposition( options.position.target === 'mouse' ? NULL : cache.event );\r\n\t\t\t\t}\r\n\t\t\t\tif(redraw) { self.redraw(); }\r\n\t\t\t}\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\ttoggle: function(state, event)\r\n\t\t{\r\n\t\t\t// Render the tooltip if showing and it isn't already\r\n\t\t\tif(!self.rendered) { return state ? self.render(1) : self; }\r\n\r\n\t\t\tvar type = state ? 'show' : 'hide',\r\n\t\t\t\topts = options[type],\r\n\t\t\t\totherOpts = options[ !state ? 'show' : 'hide' ],\r\n\t\t\t\tposOptions = options.position,\r\n\t\t\t\tcontentOptions = options.content,\r\n\t\t\t\tvisible = tooltip[0].offsetWidth > 0,\r\n\t\t\t\tanimate = state || opts.target.length === 1,\r\n\t\t\t\tsameTarget = !event || opts.target.length < 2 || cache.target[0] === event.target,\r\n\t\t\t\tdelay, callback;\r\n\r\n\t\t\t// Detect state if valid one isn't provided\r\n\t\t\tif((typeof state).search('boolean|number')) { state = !visible; }\r\n\r\n\t\t\t// Return if element is already in correct state\r\n\t\t\tif(!tooltip.is(':animated') && visible === state && sameTarget) { return self; }\r\n\r\n\t\t\t// Try to prevent flickering when tooltip overlaps show element\r\n\t\t\tif(event) {\r\n\t\t\t\tif((/over|enter/).test(event.type) && (/out|leave/).test(cache.event.type) &&\r\n\t\t\t\t\toptions.show.target.add(event.target).length === options.show.target.length &&\r\n\t\t\t\t\ttooltip.has(event.relatedTarget).length) {\r\n\t\t\t\t\treturn self;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Cache event\r\n\t\t\t\tcache.event = $.extend({}, event);\r\n\t\t\t}\r\n\r\n\t\t\t// Call API methods\r\n\t\t\tcallback = $.Event('tooltip'+type);\r\n\t\t\tcallback.originalEvent = event ? cache.event : NULL;\r\n\t\t\ttooltip.trigger(callback, [self, 90]);\r\n\t\t\tif(callback.isDefaultPrevented()){ return self; }\r\n\r\n\t\t\t// Set ARIA hidden status attribute\r\n\t\t\t$.attr(tooltip[0], 'aria-hidden', !!!state);\r\n\r\n\t\t\t// Execute state specific properties\r\n\t\t\tif(state) {\r\n\t\t\t\t// Store show origin coordinates\r\n\t\t\t\tcache.origin = $.extend({}, MOUSE);\r\n\r\n\t\t\t\t// Focus the tooltip\r\n\t\t\t\tself.focus(event);\r\n\r\n\t\t\t\t// Update tooltip content & title if it's a dynamic function\r\n\t\t\t\tif($.isFunction(contentOptions.text)) { updateContent(contentOptions.text, FALSE); }\r\n\t\t\t\tif($.isFunction(contentOptions.title.text)) { updateTitle(contentOptions.title.text, FALSE); }\r\n\r\n\t\t\t\t// Cache mousemove events for positioning purposes (if not already tracking)\r\n\t\t\t\tif(!trackingBound && posOptions.target === 'mouse' && posOptions.adjust.mouse) {\r\n\t\t\t\t\t$(document).bind('mousemove.qtip', function(event) {\r\n\t\t\t\t\t\tMOUSE = { pageX: event.pageX, pageY: event.pageY, type: 'mousemove' };\r\n\t\t\t\t\t});\r\n\t\t\t\t\ttrackingBound = TRUE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Update the tooltip position\r\n\t\t\t\tself.reposition(event, arguments[2]);\r\n\r\n\t\t\t\t// Hide other tooltips if tooltip is solo, using it as the context\r\n\t\t\t\tif((callback.solo = !!opts.solo)) { $(selector, opts.solo).not(tooltip).qtip('hide', callback); }\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Clear show timer if we're hiding \r\n\t\t\t\tclearTimeout(self.timers.show);\r\n\r\n\t\t\t\t// Remove cached origin on hide\r\n\t\t\t\tdelete cache.origin;\r\n\r\n\t\t\t\t// Remove mouse tracking event if not needed (all tracking qTips are hidden)\r\n\t\t\t\tif(trackingBound && !$(selector+'[tracking=\"true\"]:visible', opts.solo).not(tooltip).length) {\r\n\t\t\t\t\t$(document).unbind('mousemove.qtip');\r\n\t\t\t\t\ttrackingBound = FALSE;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t// Blur the tooltip\r\n\t\t\t\tself.blur(event);\r\n\t\t\t}\r\n\r\n\t\t\t// Define post-animation, state specific properties\r\n\t\t\tfunction after() {\r\n\t\t\t\tif(state) {\r\n\t\t\t\t\t// Prevent antialias from disappearing in IE by removing filter\r\n\t\t\t\t\tif($.browser.msie) { tooltip[0].style.removeAttribute('filter'); }\r\n\r\n\t\t\t\t\t// Remove overflow setting to prevent tip bugs\r\n\t\t\t\t\ttooltip.css('overflow', '');\r\n\r\n\t\t\t\t\t// Autofocus elements if enabled\r\n\t\t\t\t\tif('string' === typeof opts.autofocus) {\r\n\t\t\t\t\t\t$(opts.autofocus, tooltip).focus();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// If set, hide tooltip when inactive for delay period\r\n\t\t\t\t\topts.target.trigger('qtip-'+id+'-inactive');\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Reset CSS states\r\n\t\t\t\t\ttooltip.css({\r\n\t\t\t\t\t\tdisplay: '',\r\n\t\t\t\t\t\tvisibility: '',\r\n\t\t\t\t\t\topacity: '',\r\n\t\t\t\t\t\tleft: '',\r\n\t\t\t\t\t\ttop: ''\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Call API method\r\n\t\t\t\tcallback = $.Event('tooltip'+(state ? 'visible' : 'hidden'));\r\n\t\t\t\tcallback.originalEvent = event ? cache.event : NULL;\r\n\t\t\t\ttooltip.trigger(callback, [self]);\r\n\t\t\t}\r\n\r\n\t\t\t// If no effect type is supplied, use a simple toggle\r\n\t\t\tif(opts.effect === FALSE || animate === FALSE) {\r\n\t\t\t\ttooltip[ type ]();\r\n\t\t\t\tafter.call(tooltip);\r\n\t\t\t}\r\n\r\n\t\t\t// Use custom function if provided\r\n\t\t\telse if($.isFunction(opts.effect)) {\r\n\t\t\t\ttooltip.stop(1, 1);\r\n\t\t\t\topts.effect.call(tooltip, self);\r\n\t\t\t\ttooltip.queue('fx', function(n){ after(); n(); });\r\n\t\t\t}\r\n\r\n\t\t\t// Use basic fade function by default\r\n\t\t\telse { tooltip.fadeTo(90, state ? 1 : 0, after); }\r\n\r\n\t\t\t// If inactive hide method is set, active it\r\n\t\t\tif(state) { opts.target.trigger('qtip-'+id+'-inactive'); }\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tshow: function(event){ return self.toggle(TRUE, event); },\r\n\r\n\t\thide: function(event){ return self.toggle(FALSE, event); },\r\n\r\n\t\tfocus: function(event)\r\n\t\t{\r\n\t\t\tif(!self.rendered) { return self; }\r\n\r\n\t\t\tvar qtips = $(selector),\r\n\t\t\t\tcurIndex = parseInt(tooltip[0].style.zIndex, 10),\r\n\t\t\t\tnewIndex = QTIP.zindex + qtips.length,\r\n\t\t\t\tcachedEvent = $.extend({}, event),\r\n\t\t\t\tfocusedElem, callback;\r\n\r\n\t\t\t// Only update the z-index if it has changed and tooltip is not already focused\r\n\t\t\tif(!tooltip.hasClass(focusClass))\r\n\t\t\t{\r\n\t\t\t\t// Call API method\r\n\t\t\t\tcallback = $.Event('tooltipfocus');\r\n\t\t\t\tcallback.originalEvent = cachedEvent;\r\n\t\t\t\ttooltip.trigger(callback, [self, newIndex]);\r\n\r\n\t\t\t\t// If default action wasn't prevented...\r\n\t\t\t\tif(!callback.isDefaultPrevented()) {\r\n\t\t\t\t\t// Only update z-index's if they've changed\r\n\t\t\t\t\tif(curIndex !== newIndex) {\r\n\t\t\t\t\t\t// Reduce our z-index's and keep them properly ordered\r\n\t\t\t\t\t\tqtips.each(function() {\r\n\t\t\t\t\t\t\tif(this.style.zIndex > curIndex) {\r\n\t\t\t\t\t\t\t\tthis.style.zIndex = this.style.zIndex - 1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Fire blur event for focused tooltip\r\n\t\t\t\t\t\tqtips.filter('.' + focusClass).qtip('blur', cachedEvent);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Set the new z-index\r\n\t\t\t\t\ttooltip.addClass(focusClass)[0].style.zIndex = newIndex;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tblur: function(event) {\r\n\t\t\tvar cachedEvent = $.extend({}, event),\r\n\t\t\t\tcallback;\r\n\r\n\t\t\t// Set focused status to FALSE\r\n\t\t\ttooltip.removeClass(focusClass);\r\n\r\n\t\t\t// Trigger blur event\r\n\t\t\tcallback = $.Event('tooltipblur');\r\n\t\t\tcallback.originalEvent = cachedEvent;\r\n\t\t\ttooltip.trigger(callback, [self]);\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\treposition: function(event, effect)\r\n\t\t{\r\n\t\t\tif(!self.rendered || isPositioning) { return self; }\r\n\r\n\t\t\t// Set positioning flag\r\n\t\t\tisPositioning = 1;\r\n\t\r\n\t\t\tvar target = options.position.target,\r\n\t\t\t\tposOptions = options.position,\r\n\t\t\t\tmy = posOptions.my, \r\n\t\t\t\tat = posOptions.at,\r\n\t\t\t\tadjust = posOptions.adjust,\r\n\t\t\t\tmethod = adjust.method.split(' '),\r\n\t\t\t\telemWidth = tooltip.outerWidth(),\r\n\t\t\t\telemHeight = tooltip.outerHeight(),\r\n\t\t\t\ttargetWidth = 0,\r\n\t\t\t\ttargetHeight = 0,\r\n\t\t\t\tcallback = $.Event('tooltipmove'),\r\n\t\t\t\tfixed = tooltip.css('position') === 'fixed',\r\n\t\t\t\tviewport = posOptions.viewport,\r\n\t\t\t\tposition = { left: 0, top: 0 },\r\n\t\t\t\tcontainer = posOptions.container,\r\n\t\t\t\tflipoffset = FALSE,\r\n\t\t\t\ttip = self.plugins.tip,\r\n\t\t\t\tvisible = tooltip[0].offsetWidth > 0,\r\n\t\t\t\treadjust = {\r\n\t\t\t\t\t// Axis detection and readjustment indicator\r\n\t\t\t\t\thorizontal: method[0],\r\n\t\t\t\t\tvertical: (method[1] = method[1] || method[0]),\r\n\t\t\t\t\tenabled: viewport.jquery && target[0] !== window && target[0] !== docBody && adjust.method !== 'none',\r\n\t\t\t \r\n\t\t\t\t\t// Reposition methods\r\n\t\t\t\t\tleft: function(posLeft) {\r\n\t\t\t\t\t\tvar isShift = readjust.horizontal === 'shift',\r\n\t\t\t\t\t\t\tviewportScroll = -container.offset.left + viewport.offset.left + viewport.scrollLeft,\r\n\t\t\t\t\t\t\tmyWidth = my.x === 'left' ? elemWidth : my.x === 'right' ? -elemWidth : -elemWidth / 2,\r\n\t\t\t\t\t\t\tatWidth = at.x === 'left' ? targetWidth : at.x === 'right' ? -targetWidth : -targetWidth / 2,\r\n\t\t\t\t\t\t\ttipWidth = tip && tip.size ? tip.size.width || 0 : 0,\r\n\t\t\t\t\t\t\ttipAdjust = tip && tip.corner && tip.corner.precedance === 'x' && !isShift ? tipWidth : 0,\r\n\t\t\t\t\t\t\toverflowLeft = viewportScroll - posLeft + tipAdjust,\r\n\t\t\t\t\t\t\toverflowRight = posLeft + elemWidth - viewport.width - viewportScroll + tipAdjust,\r\n\t\t\t\t\t\t\toffset = myWidth - (my.precedance === 'x' || my.x === my.y ? atWidth : 0) - (at.x === 'center' ? targetWidth / 2 : 0),\r\n\t\t\t\t\t\t\tisCenter = my.x === 'center';\r\n\r\n\t\t\t\t\t\t// Optional 'shift' style repositioning\r\n\t\t\t\t\t\tif(isShift) {\r\n\t\t\t\t\t\t\ttipAdjust = tip && tip.corner && tip.corner.precedance === 'y' ? tipWidth : 0;\r\n\t\t\t\t\t\t\toffset = (my.x === 'left' ? 1 : -1) * myWidth - tipAdjust;\r\n\r\n\t\t\t\t\t\t\t// Adjust position but keep it within viewport dimensions\r\n\t\t\t\t\t\t\tposition.left += overflowLeft > 0 ? overflowLeft : overflowRight > 0 ? -overflowRight : 0;\r\n\t\t\t\t\t\t\tposition.left = Math.max(\r\n\t\t\t\t\t\t\t\t-container.offset.left + viewport.offset.left + (tipAdjust && tip.corner.x === 'center' ? tip.offset : 0),\r\n\t\t\t\t\t\t\t\tposLeft - offset,\r\n\t\t\t\t\t\t\t\tMath.min(\r\n\t\t\t\t\t\t\t\t\tMath.max(-container.offset.left + viewport.offset.left + viewport.width, posLeft + offset),\r\n\t\t\t\t\t\t\t\t\tposition.left\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Default 'flip' repositioning\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(overflowLeft > 0 && (my.x !== 'left' || overflowRight > 0)) {\r\n\t\t\t\t\t\t\t\tposition.left -= offset;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(overflowRight > 0 && (my.x !== 'right' || overflowLeft > 0)  ) {\r\n\t\t\t\t\t\t\t\tposition.left -= isCenter ? -offset : offset;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(position.left !== posLeft && isCenter) { position.left -= adjust.x; }\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t// Make sure we haven't made things worse with the adjustment and return the adjusted difference\r\n\t\t\t\t\t\t\tif(position.left < viewportScroll && -position.left > overflowRight) { position.left = posLeft; }\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn position.left - posLeft;\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttop: function(posTop) {\r\n\t\t\t\t\t\tvar isShift = readjust.vertical === 'shift',\r\n\t\t\t\t\t\t\tviewportScroll = -container.offset.top + viewport.offset.top + viewport.scrollTop,\r\n\t\t\t\t\t\t\tmyHeight = my.y === 'top' ? elemHeight : my.y === 'bottom' ? -elemHeight : -elemHeight / 2,\r\n\t\t\t\t\t\t\tatHeight = at.y === 'top' ? targetHeight : at.y === 'bottom' ? -targetHeight : -targetHeight / 2,\r\n\t\t\t\t\t\t\ttipHeight = tip && tip.size ? tip.size.height || 0 : 0,\r\n\t\t\t\t\t\t\ttipAdjust = tip && tip.corner && tip.corner.precedance === 'y' && !isShift ? tipHeight : 0,\r\n\t\t\t\t\t\t\toverflowTop = viewportScroll - posTop + tipAdjust,\r\n\t\t\t\t\t\t\toverflowBottom = posTop + elemHeight - viewport.height - viewportScroll + tipAdjust,\r\n\t\t\t\t\t\t\toffset = myHeight - (my.precedance === 'y' || my.x === my.y ? atHeight : 0) - (at.y === 'center' ? targetHeight / 2 : 0),\r\n\t\t\t\t\t\t\tisCenter = my.y === 'center';\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t// Optional 'shift' style repositioning\r\n\t\t\t\t\t\tif(isShift) {\r\n\t\t\t\t\t\t\ttipAdjust = tip && tip.corner && tip.corner.precedance === 'x' ? tipHeight : 0;\r\n\t\t\t\t\t\t\toffset = (my.y === 'top' ? 1 : -1) * myHeight - tipAdjust;\r\n\r\n\t\t\t\t\t\t\t// Adjust position but keep it within viewport dimensions\r\n\t\t\t\t\t\t\tposition.top += overflowTop > 0 ? overflowTop : overflowBottom > 0 ? -overflowBottom : 0;\r\n\t\t\t\t\t\t\tposition.top = Math.max(\r\n\t\t\t\t\t\t\t\t-container.offset.top + viewport.offset.top + (tipAdjust && tip.corner.x === 'center' ? tip.offset : 0),\r\n\t\t\t\t\t\t\t\tposTop - offset,\r\n\t\t\t\t\t\t\t\tMath.min(\r\n\t\t\t\t\t\t\t\t\tMath.max(-container.offset.top + viewport.offset.top + viewport.height, posTop + offset),\r\n\t\t\t\t\t\t\t\t\tposition.top\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Default 'flip' repositioning\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif(overflowTop > 0 && (my.y !== 'top' || overflowBottom > 0)) {\r\n\t\t\t\t\t\t\t\tposition.top -= offset;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(overflowBottom > 0 && (my.y !== 'bottom' || overflowTop > 0)  ) {\r\n\t\t\t\t\t\t\t\tposition.top -= isCenter ? -offset : offset;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif(position.top !== posTop && isCenter) { position.top -= adjust.y; }\r\n\r\n\t\t\t\t\t\t\t// Make sure we haven't made things worse with the adjustment and return the adjusted difference\r\n\t\t\t\t\t\t\tif(position.top < 0 && -position.top > overflowBottom) { position.top = posTop; }\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn position.top - posTop;\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\twin;\r\n\r\n\t\t\t// Check if absolute position was passed\r\n\t\t\tif($.isArray(target) && target.length === 2) {\r\n\t\t\t\t// Force left top and set position\r\n\t\t\t\tat = { x: 'left', y: 'top' };\r\n\t\t\t\tposition = { left: target[0], top: target[1] };\r\n\t\t\t}\r\n\r\n\t\t\t// Check if mouse was the target\r\n\t\t\telse if(target === 'mouse' && ((event && event.pageX) || cache.event.pageX)) {\r\n\t\t\t\t// Force left top to allow flipping\r\n\t\t\t\tat = { x: 'left', y: 'top' };\r\n\r\n\t\t\t\t// Use cached event if one isn't available for positioning\r\n\t\t\t\tevent = (event && (event.type === 'resize' || event.type === 'scroll') ? cache.event :\r\n\t\t\t\t\tevent && event.pageX && event.type === 'mousemove' ? event :\r\n\t\t\t\t\tMOUSE && MOUSE.pageX && (adjust.mouse || !event || !event.pageX) ? { pageX: MOUSE.pageX, pageY: MOUSE.pageY } :\r\n\t\t\t\t\t!adjust.mouse && cache.origin && cache.origin.pageX && options.show.distance ? cache.origin :\r\n\t\t\t\t\tevent) || event || cache.event || MOUSE || {};\r\n\r\n\t\t\t\t// Use event coordinates for position\r\n\t\t\t\tposition = { top: event.pageY, left: event.pageX };\r\n\t\t\t}\r\n\r\n\t\t\t// Target wasn't mouse or absolute...\r\n\t\t\telse {\r\n\t\t\t\t// Check if event targetting is being used\r\n\t\t\t\tif(target === 'event') {\r\n\t\t\t\t\tif(event && event.target && event.type !== 'scroll' && event.type !== 'resize') {\r\n\t\t\t\t\t\ttarget = cache.target = $(event.target);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttarget = cache.target;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\ttarget = cache.target = $(target.jquery ? target : elements.target);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Parse the target into a jQuery object and make sure there's an element present\r\n\t\t\t\ttarget = $(target).eq(0);\r\n\t\t\t\tif(target.length === 0) { return self; }\r\n\r\n\t\t\t\t// Check if window or document is the target\r\n\t\t\t\telse if(target[0] === document || target[0] === window) {\r\n\t\t\t\t\ttargetWidth = PLUGINS.iOS ? window.innerWidth : target.width();\r\n\t\t\t\t\ttargetHeight = PLUGINS.iOS ? window.innerHeight : target.height();\r\n\r\n\t\t\t\t\tif(target[0] === window) {\r\n\t\t\t\t\t\tposition = {\r\n\t\t\t\t\t\t\ttop: (viewport || target).scrollTop(),\r\n\t\t\t\t\t\t\tleft: (viewport || target).scrollLeft()\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Use Imagemap/SVG plugins if needed\r\n\t\t\t\telse if(target.is('area') && PLUGINS.imagemap) {\r\n\t\t\t\t\tposition = PLUGINS.imagemap(target, at, readjust.enabled ? method : FALSE);\r\n\t\t\t\t}\r\n\t\t\t\telse if(target[0].namespaceURI === 'http://www.w3.org/2000/svg' && PLUGINS.svg) {\r\n\t\t\t\t\tposition = PLUGINS.svg(target, at);\r\n\t\t\t\t}\r\n\r\n\t\t\t\telse {\r\n\t\t\t\t\ttargetWidth = target.outerWidth();\r\n\t\t\t\t\ttargetHeight = target.outerHeight();\r\n\r\n\t\t\t\t\tposition = PLUGINS.offset(target, container);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Parse returned plugin values into proper variables\r\n\t\t\t\tif(position.offset) {\r\n\t\t\t\t\ttargetWidth = position.width;\r\n\t\t\t\t\ttargetHeight = position.height;\r\n\t\t\t\t\tflipoffset = position.flipoffset;\r\n\t\t\t\t\tposition = position.offset;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Adjust for position.fixed tooltips (and also iOS scroll bug in v3.2 - v4.0)\r\n\t\t\t\tif((PLUGINS.iOS < 4.1 && PLUGINS.iOS > 3.1) || PLUGINS.iOS == 4.3 || (!PLUGINS.iOS && fixed)) {\r\n\t\t\t\t\twin = $(window);\r\n\t\t\t\t\tposition.left -= win.scrollLeft();\r\n\t\t\t\t\tposition.top -= win.scrollTop();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Adjust position relative to target\r\n\t\t\t\tposition.left += at.x === 'right' ? targetWidth : at.x === 'center' ? targetWidth / 2 : 0;\r\n\t\t\t\tposition.top += at.y === 'bottom' ? targetHeight : at.y === 'center' ? targetHeight / 2 : 0;\r\n\t\t\t}\r\n\r\n\t\t\t// Adjust position relative to tooltip\r\n\t\t\tposition.left += adjust.x + (my.x === 'right' ? -elemWidth : my.x === 'center' ? -elemWidth / 2 : 0);\r\n\t\t\tposition.top += adjust.y + (my.y === 'bottom' ? -elemHeight : my.y === 'center' ? -elemHeight / 2 : 0);\r\n\r\n\t\t\t// Calculate collision offset values if viewport positioning is enabled\r\n\t\t\tif(readjust.enabled) {\r\n\t\t\t\t// Cache our viewport details\r\n\t\t\t\tviewport = {\r\n\t\t\t\t\telem: viewport,\r\n\t\t\t\t\theight: viewport[ (viewport[0] === window ? 'h' : 'outerH') + 'eight' ](),\r\n\t\t\t\t\twidth: viewport[ (viewport[0] === window ? 'w' : 'outerW') + 'idth' ](),\r\n\t\t\t\t\tscrollLeft: fixed ? 0 : viewport.scrollLeft(),\r\n\t\t\t\t\tscrollTop: fixed ? 0 : viewport.scrollTop(),\r\n\t\t\t\t\toffset: viewport.offset() || { left: 0, top: 0 }\r\n\t\t\t\t};\r\n\t\t\t\tcontainer = {\r\n\t\t\t\t\telem: container,\r\n\t\t\t\t\tscrollLeft: container.scrollLeft(),\r\n\t\t\t\t\tscrollTop: container.scrollTop(),\r\n\t\t\t\t\toffset: container.offset() || { left: 0, top: 0 }\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Adjust position based onviewport and adjustment options\r\n\t\t\t\tposition.adjusted = {\r\n\t\t\t\t\tleft: readjust.horizontal !== 'none' ? readjust.left(position.left) : 0,\r\n\t\t\t\t\ttop: readjust.vertical !== 'none' ? readjust.top(position.top) : 0\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// Set tooltip position class\r\n\t\t\t\tif(position.adjusted.left + position.adjusted.top) {\r\n\t\t\t\t\ttooltip.attr('class', tooltip[0].className.replace(/ui-tooltip-pos-\\w+/i, uitooltip + '-pos-' + my.abbrev()));\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Apply flip offsets supplied by positioning plugins\r\n\t\t\t\tif(flipoffset && position.adjusted.left) { position.left += flipoffset.left; }\r\n\t\t\t\tif(flipoffset && position.adjusted.top) {  position.top += flipoffset.top; }\r\n\t\t\t}\r\n\r\n\t\t\t//Viewport adjustment is disabled, set values to zero\r\n\t\t\telse { position.adjusted = { left: 0, top: 0 }; }\r\n\r\n\t\t\t// Call API method\r\n\t\t\tcallback.originalEvent = $.extend({}, event);\r\n\t\t\ttooltip.trigger(callback, [self, position, viewport.elem || viewport]);\r\n\t\t\tif(callback.isDefaultPrevented()){ return self; }\r\n\t\t\tdelete position.adjusted;\r\n\r\n\t\t\t// If effect is disabled, target it mouse, no animation is defined or positioning gives NaN out, set CSS directly\r\n\t\t\tif(effect === FALSE || !visible || isNaN(position.left) || isNaN(position.top) || target === 'mouse' || !$.isFunction(posOptions.effect)) {\r\n\t\t\t\ttooltip.css(position);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// Use custom function if provided\r\n\t\t\telse if($.isFunction(posOptions.effect)) {\r\n\t\t\t\tposOptions.effect.call(tooltip, self, $.extend({}, position));\r\n\t\t\t\ttooltip.queue(function(next) {\r\n\t\t\t\t\t// Reset attributes to avoid cross-browser rendering bugs\r\n\t\t\t\t\t$(this).css({ opacity: '', height: '' });\r\n\t\t\t\t\tif($.browser.msie) { this.style.removeAttribute('filter'); }\r\n\r\n\t\t\t\t\tnext();\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Set positioning flag\r\n\t\t\tisPositioning = 0;\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\t// Max/min width simulator function for all browsers.. yeaaah!\r\n\t\tredraw: function()\r\n\t\t{\r\n\t\t\tif(self.rendered < 1 || isDrawing) { return self; }\r\n\r\n\t\t\tvar container = options.position.container,\r\n\t\t\t\tperc, width, max, min;\r\n\r\n\t\t\t// Set drawing flag\r\n\t\t\tisDrawing = 1;\r\n\r\n\t\t\t// If tooltip has a set height, just set it... like a boss!\r\n\t\t\tif(options.style.height) { tooltip.css('height', options.style.height); }\r\n\r\n\t\t\t// If tooltip has a set width, just set it... like a boss!\r\n\t\t\tif(options.style.width) { tooltip.css('width', options.style.width); }\r\n\r\n\t\t\t// Otherwise simualte max/min width...\r\n\t\t\telse {\r\n\t\t\t\t// Reset width and add fluid class\r\n\t\t\t\ttooltip.css('width', '').addClass(fluidClass);\r\n\r\n\t\t\t\t// Grab our tooltip width (add 1 so we don't get wrapping problems.. huzzah!)\r\n\t\t\t\twidth = tooltip.width() + 1;\r\n\r\n\t\t\t\t// Grab our max/min properties\r\n\t\t\t\tmax = tooltip.css('max-width') || '';\r\n\t\t\t\tmin = tooltip.css('min-width') || '';\r\n\r\n\t\t\t\t// Parse into proper pixel values\r\n\t\t\t\tperc = (max + min).indexOf('%') > -1 ? container.width() / 100 : 0;\r\n\t\t\t\tmax = ((max.indexOf('%') > -1 ? perc : 1) * parseInt(max, 10)) || width;\r\n\t\t\t\tmin = ((min.indexOf('%') > -1 ? perc : 1) * parseInt(min, 10)) || 0;\r\n\r\n\t\t\t\t// Determine new dimension size based on max/min/current values\r\n\t\t\t\twidth = max + min ? Math.min(Math.max(width, min), max) : width;\r\n\r\n\t\t\t\t// Set the newly calculated width and remvoe fluid class\r\n\t\t\t\ttooltip.css('width', Math.round(width)).removeClass(fluidClass);\r\n\t\t\t}\r\n\r\n\t\t\t// Set drawing flag\r\n\t\t\tisDrawing = 0;\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\r\n\t\tdisable: function(state)\r\n\t\t{\r\n\t\t\tif('boolean' !== typeof state) {\r\n\t\t\t\tstate = !(tooltip.hasClass(disabled) || cache.disabled);\r\n\t\t\t}\r\n\t\t\t \r\n\t\t\tif(self.rendered) {\r\n\t\t\t\ttooltip.toggleClass(disabled, state);\r\n\t\t\t\t$.attr(tooltip[0], 'aria-disabled', state);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcache.disabled = !!state;\r\n\t\t\t}\r\n\r\n\t\t\treturn self;\r\n\t\t},\r\n\t\t\r\n\t\tenable: function() { return self.disable(FALSE); },\r\n\r\n\t\tdestroy: function()\r\n\t\t{\r\n\t\t\tvar t = target[0],\r\n\t\t\t\ttitle = $.attr(t, oldtitle),\r\n\t\t\t\telemAPI = target.data('qtip');\r\n\r\n\t\t\t// Destroy tooltip and  any associated plugins if rendered\r\n\t\t\tif(self.rendered) {\r\n\t\t\t\ttooltip.stop(1,0).remove();\r\n\t\t\t\t\r\n\t\t\t\t$.each(self.plugins, function() {\r\n\t\t\t\t\tif(this.destroy) { this.destroy(); }\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Clear timers and remove bound events\r\n\t\t\tclearTimeout(self.timers.show);\r\n\t\t\tclearTimeout(self.timers.hide);\r\n\t\t\tunassignEvents();\r\n\r\n\t\t\t// If the API if actually this qTip API...\r\n\t\t\tif(!elemAPI || self === elemAPI) {\r\n\t\t\t\t// Remove api object\r\n\t\t\t\t$.removeData(t, 'qtip');\r\n\r\n\t\t\t\t// Reset old title attribute if removed\r\n\t\t\t\tif(options.suppress && title) {\r\n\t\t\t\t\t$.attr(t, 'title', title);\r\n\t\t\t\t\ttarget.removeAttr(oldtitle);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Remove ARIA attributes\r\n\t\t\t\ttarget.removeAttr('aria-describedby');\r\n\t\t\t}\r\n\r\n\t\t\t// Remove qTip events associated with this API\r\n\t\t\ttarget.unbind('.qtip-'+id);\r\n\r\n\t\t\t// Remove ID from sued id object\r\n\t\t\tdelete usedIDs[self.id];\r\n\r\n\t\t\treturn target;\r\n\t\t}\r\n\t});\r\n}\r\n\r\n// Initialization method\r\nfunction init(id, opts)\r\n{\r\n\tvar obj, posOptions, attr, config, title,\r\n\r\n\t// Setup element references\r\n\telem = $(this),\r\n\tdocBody = $(document.body),\r\n\r\n\t// Use document body instead of document element if needed\r\n\tnewTarget = this === document ? docBody : elem,\r\n\r\n\t// Grab metadata from element if plugin is present\r\n\tmetadata = (elem.metadata) ? elem.metadata(opts.metadata) : NULL,\r\n\r\n\t// If metadata type if HTML5, grab 'name' from the object instead, or use the regular data object otherwise\r\n\tmetadata5 = opts.metadata.type === 'html5' && metadata ? metadata[opts.metadata.name] : NULL,\r\n\r\n\t// Grab data from metadata.name (or data-qtipopts as fallback) using .data() method,\r\n\thtml5 = elem.data(opts.metadata.name || 'qtipopts');\r\n\r\n\t// If we don't get an object returned attempt to parse it manualyl without parseJSON\r\n\ttry { html5 = typeof html5 === 'string' ? (new Function(\"return \" + html5))() : html5; }\r\n\tcatch(e) { log('Unable to parse HTML5 attribute data: ' + html5); }\r\n\r\n\t// Merge in and sanitize metadata\r\n\tconfig = $.extend(TRUE, {}, QTIP.defaults, opts, \r\n\t\ttypeof html5 === 'object' ? sanitizeOptions(html5) : NULL,\r\n\t\tsanitizeOptions(metadata5 || metadata));\r\n\r\n\t// Re-grab our positioning options now we've merged our metadata and set id to passed value\r\n\tposOptions = config.position;\r\n\tconfig.id = id;\r\n\t\r\n\t// Setup missing content if none is detected\r\n\tif('boolean' === typeof config.content.text) {\r\n\t\tattr = elem.attr(config.content.attr);\r\n\r\n\t\t// Grab from supplied attribute if available\r\n\t\tif(config.content.attr !== FALSE && attr) { config.content.text = attr; }\r\n\r\n\t\t// No valid content was found, abort render\r\n\t\telse {\r\n\t\t\tlog('Unable to locate content for tooltip! Aborting render of tooltip on element: ', elem);\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t// Setup target options\r\n\tif(!posOptions.container.length) { posOptions.container = docBody; }\r\n\tif(posOptions.target === FALSE) { posOptions.target = newTarget; }\r\n\tif(config.show.target === FALSE) { config.show.target = newTarget; }\r\n\tif(config.show.solo === TRUE) { config.show.solo = posOptions.container.closest('body'); }\r\n\tif(config.hide.target === FALSE) { config.hide.target = newTarget; }\r\n\tif(config.position.viewport === TRUE) { config.position.viewport = posOptions.container; }\r\n\r\n\t// Ensure we only use a single container\r\n\tposOptions.container = posOptions.container.eq(0);\r\n\r\n\t// Convert position corner values into x and y strings\r\n\tposOptions.at = new PLUGINS.Corner(posOptions.at);\r\n\tposOptions.my = new PLUGINS.Corner(posOptions.my);\r\n\r\n\t// Destroy previous tooltip if overwrite is enabled, or skip element if not\r\n\tif($.data(this, 'qtip')) {\r\n\t\tif(config.overwrite) {\r\n\t\t\telem.qtip('destroy');\r\n\t\t}\r\n\t\telse if(config.overwrite === FALSE) {\r\n\t\t\treturn FALSE;\r\n\t\t}\r\n\t}\r\n\r\n\t// Remove title attribute and store it if present\r\n\tif(config.suppress && (title = $.attr(this, 'title'))) {\r\n\t\t$(this).removeAttr('title').attr(oldtitle, title);\r\n\t}\r\n\r\n\t// Initialize the tooltip and add API reference\r\n\tobj = new QTip(elem, config, id, !!attr);\r\n\t$.data(this, 'qtip', obj);\r\n\r\n\t// Catch remove/removeqtip events on target element to destroy redundant tooltip\r\n\telem.bind('remove.qtip-'+id+' removeqtip.qtip-'+id, function(){ obj.destroy(); });\r\n\r\n\treturn obj;\r\n}\r\n\r\n// jQuery $.fn extension method\r\nQTIP = $.fn.qtip = function(options, notation, newValue)\r\n{\r\n\tvar command = ('' + options).toLowerCase(), // Parse command\r\n\t\treturned = NULL,\r\n\t\targs = $.makeArray(arguments).slice(1),\r\n\t\tevent = args[args.length - 1],\r\n\t\topts = this[0] ? $.data(this[0], 'qtip') : NULL;\r\n\r\n\t// Check for API request\r\n\tif((!arguments.length && opts) || command === 'api') {\r\n\t\treturn opts;\r\n\t}\r\n\r\n\t// Execute API command if present\r\n\telse if('string' === typeof options)\r\n\t{\r\n\t\tthis.each(function()\r\n\t\t{\r\n\t\t\tvar api = $.data(this, 'qtip');\r\n\t\t\tif(!api) { return TRUE; }\r\n\r\n\t\t\t// Cache the event if possible\r\n\t\t\tif(event && event.timeStamp) { api.cache.event = event; }\r\n\r\n\t\t\t// Check for specific API commands\r\n\t\t\tif((command === 'option' || command === 'options') && notation) {\r\n\t\t\t\tif($.isPlainObject(notation) || newValue !== undefined) {\r\n\t\t\t\t\tapi.set(notation, newValue);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturned = api.get(notation);\r\n\t\t\t\t\treturn FALSE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Execute API command\r\n\t\t\telse if(api[command]) {\r\n\t\t\t\tapi[command].apply(api[command], args);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn returned !== NULL ? returned : this;\r\n\t}\r\n\r\n\t// No API commands. validate provided options and setup qTips\r\n\telse if('object' === typeof options || !arguments.length)\r\n\t{\r\n\t\topts = sanitizeOptions($.extend(TRUE, {}, options));\r\n\r\n\t\t// Bind the qTips\r\n\t\treturn QTIP.bind.call(this, opts, event);\r\n\t}\r\n};\r\n\r\n// $.fn.qtip Bind method\r\nQTIP.bind = function(opts, event)\r\n{\r\n\treturn this.each(function(i) {\r\n\t\tvar options, targets, events, namespace, api, id;\r\n\r\n\t\t// Find next available ID, or use custom ID if provided\r\n\t\tid = $.isArray(opts.id) ? opts.id[i] : opts.id;\r\n\t\tid = !id || id === FALSE || id.length < 1 || usedIDs[id] ? QTIP.nextid++ : (usedIDs[id] = id);\r\n\r\n\t\t// Setup events namespace\r\n\t\tnamespace = '.qtip-'+id+'-create';\r\n\r\n\t\t// Initialize the qTip and re-grab newly sanitized options\r\n\t\tapi = init.call(this, id, opts);\r\n\t\tif(api === FALSE) { return TRUE; }\r\n\t\toptions = api.options;\r\n\r\n\t\t// Initialize plugins\r\n\t\t$.each(PLUGINS, function() {\r\n\t\t\tif(this.initialize === 'initialize') { this(api); }\r\n\t\t});\r\n\r\n\t\t// Determine hide and show targets\r\n\t\ttargets = { show: options.show.target, hide: options.hide.target };\r\n\t\tevents = {\r\n\t\t\tshow: $.trim('' + options.show.event).replace(/ /g, namespace+' ') + namespace,\r\n\t\t\thide: $.trim('' + options.hide.event).replace(/ /g, namespace+' ') + namespace\r\n\t\t};\r\n\r\n\t\t/*\r\n\t\t * Make sure hoverIntent functions properly by using mouseleave as a hide event if\r\n\t\t * mouseenter/mouseout is used for show.event, even if it isn't in the users options.\r\n\t\t */\r\n\t\tif(/mouse(over|enter)/i.test(events.show) && !/mouse(out|leave)/i.test(events.hide)) {\r\n\t\t\tevents.hide += ' mouseleave' + namespace;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * Also make sure initial mouse targetting works correctly by caching mousemove coords\r\n\t\t * on show targets before the tooltip has rendered.\r\n\t\t *\r\n\t\t * Also set onTarget when triggered to keep mouse tracking working\r\n\t\t */\r\n\t\ttargets.show.bind('mousemove'+namespace, function(event) {\r\n\t\t\tMOUSE = { pageX: event.pageX, pageY: event.pageY, type: 'mousemove' };\r\n\t\t\tapi.cache.onTarget = TRUE;\r\n\t\t});\r\n\r\n\t\t// Define hoverIntent function\r\n\t\tfunction hoverIntent(event) {\r\n\t\t\tfunction render() {\r\n\t\t\t\t// Cache mouse coords,render and render the tooltip\r\n\t\t\t\tapi.render(typeof event === 'object' || options.show.ready);\r\n\r\n\t\t\t\t// Unbind show and hide events\r\n\t\t\t\ttargets.show.add(targets.hide).unbind(namespace);\r\n\t\t\t}\r\n\r\n\t\t\t// Only continue if tooltip isn't disabled\r\n\t\t\tif(api.cache.disabled) { return FALSE; }\r\n\r\n\t\t\t// Cache the event data\r\n\t\t\tapi.cache.event = $.extend({}, event);\r\n\t\t\tapi.cache.target = event ? $(event.target) : [undefined];\r\n\r\n\t\t\t// Start the event sequence\r\n\t\t\tif(options.show.delay > 0) {\r\n\t\t\t\tclearTimeout(api.timers.show);\r\n\t\t\t\tapi.timers.show = setTimeout(render, options.show.delay);\r\n\t\t\t\tif(events.show !== events.hide) {\r\n\t\t\t\t\ttargets.hide.bind(events.hide, function() { clearTimeout(api.timers.show); });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { render(); }\r\n\t\t}\r\n\r\n\t\t// Bind show events to target\r\n\t\ttargets.show.bind(events.show, hoverIntent);\r\n\r\n\t\t// Prerendering is enabled, create tooltip now\r\n\t\tif(options.show.ready || options.prerender) { hoverIntent(event); }\r\n\t});\r\n};\r\n\r\n// Setup base plugins\r\nPLUGINS = QTIP.plugins = {\r\n\t// Corner object parser\r\n\tCorner: function(corner) {\r\n\t\tcorner = ('' + corner).replace(/([A-Z])/, ' $1').replace(/middle/gi, 'center').toLowerCase();\r\n\t\tthis.x = (corner.match(/left|right/i) || corner.match(/center/) || ['inherit'])[0].toLowerCase();\r\n\t\tthis.y = (corner.match(/top|bottom|center/i) || ['inherit'])[0].toLowerCase();\r\n\r\n\t\tvar f = corner.charAt(0); this.precedance = (f === 't' || f === 'b' ? 'y' : 'x');\r\n\r\n\t\tthis.string = function() { return this.precedance === 'y' ? this.y+this.x : this.x+this.y; };\r\n\t\tthis.abbrev = function() { \r\n\t\t\tvar x = this.x.substr(0,1), y = this.y.substr(0,1);\r\n\t\t\treturn x === y ? x : (x === 'c' || (x !== 'c' && y !== 'c')) ? y + x : x + y;\r\n\t\t};\r\n\r\n\t\tthis.clone = function() {\r\n\t\t\treturn { x: this.x, y: this.y, precedance: this.precedance, string: this.string, abbrev: this.abbrev, clone: this.clone };\r\n\t\t};\r\n\t},\r\n\r\n\t// Custom (more correct for qTip!) offset calculator\r\n\toffset: function(elem, container) {\r\n\t\tvar pos = elem.offset(),\r\n\t\t\tdocBody = elem.closest('body')[0],\r\n\t\t\tparent = container, scrolled,\r\n\t\t\tcoffset, overflow;\r\n\r\n\t\tfunction scroll(e, i) {\r\n\t\t\tpos.left += i * e.scrollLeft();\r\n\t\t\tpos.top += i * e.scrollTop();\r\n\t\t}\r\n\r\n\t\tif(parent) {\r\n\t\t\t// Compensate for non-static containers offset\r\n\t\t\tdo {\r\n\t\t\t\tif(parent.css('position') !== 'static') {\r\n\t\t\t\t\tcoffset = parent.position();\r\n\r\n\t\t\t\t\t// Account for element positioning, borders and margins\r\n\t\t\t\t\tpos.left -= coffset.left + (parseInt(parent.css('borderLeftWidth'), 10) || 0) + (parseInt(parent.css('marginLeft'), 10) || 0);\r\n\t\t\t\t\tpos.top -= coffset.top + (parseInt(parent.css('borderTopWidth'), 10) || 0) + (parseInt(parent.css('marginTop'), 10) || 0);\r\n\r\n\t\t\t\t\t// If this is the first parent element with an overflow of \"scroll\" or \"auto\", store it\r\n\t\t\t\t\tif(!scrolled && (overflow = parent.css('overflow')) !== 'hidden' && overflow !== 'visible') { scrolled = parent; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile((parent = $(parent[0].offsetParent)).length);\r\n\r\n\t\t\t// Compensate for containers scroll if it also has an offsetParent\r\n\t\t\tif(scrolled && scrolled[0] !== docBody) { scroll( scrolled, 1 ); }\r\n\t\t}\r\n\r\n\t\treturn pos;\r\n\t},\r\n\t\r\n\t/*\r\n\t * iOS 3.2 - 4.0 scroll fix detection used in offset() function.\r\n\t */\r\n\tiOS: parseFloat(\r\n\t\t('' + (/CPU.*OS ([0-9_]{1,3})|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0,''])[1])\r\n\t\t\t.replace('undefined', '3_2').replace('_','.')\r\n\t) || FALSE,\r\n\t\r\n\t/*\r\n\t * jQuery-specific $.fn overrides\r\n\t */\r\n\tfn: {\r\n\t\t/* Allow other plugins to successfully retrieve the title of an element with a qTip applied */\r\n\t\tattr: function(attr, val) {\r\n\t\t\tif(this.length) {\r\n\t\t\t\tvar self = this[0],\r\n\t\t\t\t\ttitle = 'title',\r\n\t\t\t\t\tapi = $.data(self, 'qtip');\r\n\r\n\t\t\t\tif(attr === title && api && 'object' === typeof api && api.options.suppress) {\r\n\t\t\t\t\tif(arguments.length < 2) {\r\n\t\t\t\t\t\treturn $.attr(self, oldtitle);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// If qTip is rendered and title was originally used as content, update it\r\n\t\t\t\t\t\tif(api && api.options.content.attr === title && api.cache.attr) {\r\n\t\t\t\t\t\t\tapi.set('content.text', val);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Use the regular attr method to set, then cache the result\r\n\t\t\t\t\t\treturn this.attr(oldtitle, val);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn $.fn['attr'+replaceSuffix].apply(this, arguments);\r\n\t\t},\r\n\t\t\r\n\t\t/* Allow clone to correctly retrieve cached title attributes */\r\n\t\tclone: function(keepData) {\r\n\t\t\tvar titles = $([]), title = 'title',\r\n\r\n\t\t\t// Clone our element using the real clone method\r\n\t\t\telems = $.fn['clone'+replaceSuffix].apply(this, arguments);\r\n\r\n\t\t\t// Grab all elements with an oldtitle set, and change it to regular title attribute, if keepData is false\r\n\t\t\tif(!keepData) {\r\n\t\t\t\telems.filter('['+oldtitle+']').attr('title', function() {\r\n\t\t\t\t\treturn $.attr(this, oldtitle);\r\n\t\t\t\t})\r\n\t\t\t\t.removeAttr(oldtitle);\r\n\t\t\t}\r\n\r\n\t\t\treturn elems;\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Apply the fn overrides above\r\n$.each(PLUGINS.fn, function(name, func) {\r\n\tif(!func || $.fn[name+replaceSuffix]) { return TRUE; }\r\n\t\r\n\tvar old = $.fn[name+replaceSuffix] = $.fn[name];\r\n\t$.fn[name] = function() {\r\n\t\treturn func.apply(this, arguments) || old.apply(this, arguments);\r\n\t};\r\n});\r\n\r\n/* Fire off 'removeqtip' handler in $.cleanData if jQuery UI not present (it already does similar).\r\n * This snippet is taken directly from jQuery UI source code found here:\r\n *     http://code.jquery.com/ui/jquery-ui-git.js\r\n */\r\nif(!$.ui) {\r\n\t$['cleanData'+replaceSuffix] = $.cleanData;\r\n\t$.cleanData = function( elems ) {\r\n\t\tfor(var i = 0, elem; (elem = elems[i]) !== undefined; i++) {\r\n\t\t\ttry { $( elem ).triggerHandler('removeqtip'); }\r\n\t\t\tcatch( e ) {}\r\n\t\t}\r\n\t\t$['cleanData'+replaceSuffix]( elems );\r\n\t};\r\n}\r\n\r\n// Set global qTip properties\r\nQTIP.version = 'nightly';\r\nQTIP.nextid = 0;\r\nQTIP.inactiveEvents = 'click dblclick mousedown mouseup mousemove mouseleave mouseenter'.split(' ');\r\nQTIP.zindex = 15000;\r\n\r\n// Define configuration defaults\r\nQTIP.defaults = {\r\n\tprerender: FALSE,\r\n\tid: FALSE,\r\n\toverwrite: TRUE,\r\n\tsuppress: TRUE,\r\n\tcontent: {\r\n\t\ttext: TRUE,\r\n\t\tattr: 'title',\r\n\t\ttitle: {\r\n\t\t\ttext: FALSE,\r\n\t\t\tbutton: FALSE\r\n\t\t}\r\n\t},\r\n\tposition: {\r\n\t\tmy: 'top left',\r\n\t\tat: 'bottom right',\r\n\t\ttarget: FALSE,\r\n\t\tcontainer: FALSE,\r\n\t\tviewport: FALSE,\r\n\t\tadjust: {\r\n\t\t\tx: 0, y: 0,\r\n\t\t\tmouse: TRUE,\r\n\t\t\tresize: TRUE,\r\n\t\t\tmethod: 'flip flip'\r\n\t\t},\r\n\t\teffect: function(api, pos, viewport) {\r\n\t\t\t$(this).animate(pos, {\r\n\t\t\t\tduration: 200,\r\n\t\t\t\tqueue: FALSE\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\tshow: {\r\n\t\ttarget: FALSE,\r\n\t\tevent: 'mouseenter',\r\n\t\teffect: TRUE,\r\n\t\tdelay: 90,\r\n\t\tsolo: FALSE,\r\n\t\tready: FALSE,\r\n\t\tautofocus: FALSE\r\n\t},\r\n\thide: {\r\n\t\ttarget: FALSE,\r\n\t\tevent: 'mouseleave',\r\n\t\teffect: TRUE,\r\n\t\tdelay: 0,\r\n\t\tfixed: FALSE,\r\n\t\tinactive: FALSE,\r\n\t\tleave: 'window',\r\n\t\tdistance: FALSE\r\n\t},\r\n\tstyle: {\r\n\t\tclasses: '',\r\n\t\twidget: FALSE,\r\n\t\twidth: FALSE,\r\n\t\theight: FALSE,\r\n\t\tdef: TRUE\r\n\t},\r\n\tevents: {\r\n\t\trender: NULL,\r\n\t\tmove: NULL,\r\n\t\tshow: NULL,\r\n\t\thide: NULL,\r\n\t\ttoggle: NULL,\r\n\t\tvisible: NULL,\r\n\t\thidden: NULL,\r\n\t\tfocus: NULL,\r\n\t\tblur: NULL\r\n\t}\r\n};\r\n\r\n// Tip coordinates calculator\r\nfunction calculateTip(corner, width, height)\r\n{\t\r\n\tvar width2 = Math.ceil(width / 2), height2 = Math.ceil(height / 2),\r\n\r\n\t// Define tip coordinates in terms of height and width values\r\n\ttips = {\r\n\t\tbottomright:\t[[0,0],\t\t\t\t[width,height],\t\t[width,0]],\r\n\t\tbottomleft:\t\t[[0,0],\t\t\t\t[width,0],\t\t\t\t[0,height]],\r\n\t\ttopright:\t\t[[0,height],\t\t[width,0],\t\t\t\t[width,height]],\r\n\t\ttopleft:\t\t\t[[0,0],\t\t\t\t[0,height],\t\t\t\t[width,height]],\r\n\t\ttopcenter:\t\t[[0,height],\t\t[width2,0],\t\t\t\t[width,height]],\r\n\t\tbottomcenter:\t[[0,0],\t\t\t\t[width,0],\t\t\t\t[width2,height]],\r\n\t\trightcenter:\t[[0,0],\t\t\t\t[width,height2],\t\t[0,height]],\r\n\t\tleftcenter:\t\t[[width,0],\t\t\t[width,height],\t\t[0,height2]]\r\n\t};\r\n\r\n\t// Set common side shapes\r\n\ttips.lefttop = tips.bottomright; tips.righttop = tips.bottomleft;\r\n\ttips.leftbottom = tips.topright; tips.rightbottom = tips.topleft;\r\n\r\n\treturn tips[ corner.string() ];\r\n}\r\n\r\n\r\nfunction Tip(qTip, command)\r\n{\r\n\tvar self = this,\r\n\t\topts = qTip.options.style.tip,\r\n\t\telems = qTip.elements,\r\n\t\ttooltip = elems.tooltip,\r\n\t\tcache = { top: 0, left: 0 },\r\n\t\tsize = {\r\n\t\t\twidth: opts.width,\r\n\t\t\theight: opts.height\r\n\t\t},\r\n\t\tcolor = { },\r\n\t\tborder = opts.border || 0,\r\n\t\tnamespace = '.qtip-tip',\r\n\t\thasCanvas = !!($('<canvas />')[0] || {}).getContext && !(window.external && window.external.IsInnovasysDesigner);\r\n\r\n\tself.corner = NULL;\r\n\tself.mimic = NULL;\r\n\tself.border = border;\r\n\tself.offset = opts.offset;\r\n\tself.size = size;\r\n\r\n\t// Add new option checks for the plugin\r\n\tqTip.checks.tip = {\r\n\t\t'^position.my|style.tip.(corner|mimic|border)$': function() {\r\n\t\t\t// Make sure a tip can be drawn\r\n\t\t\tif(!self.init()) {\r\n\t\t\t\tself.destroy();\r\n\t\t\t}\r\n\r\n\t\t\t// Reposition the tooltip\r\n\t\t\tqTip.reposition();\r\n\t\t},\r\n\t\t'^style.tip.(height|width)$': function() {\r\n\t\t\t// Re-set dimensions and redraw the tip\r\n\t\t\tsize = {\r\n\t\t\t\twidth: opts.width,\r\n\t\t\t\theight: opts.height\r\n\t\t\t};\r\n\t\t\tself.create();\r\n\t\t\tself.update();\r\n\r\n\t\t\t// Reposition the tooltip\r\n\t\t\tqTip.reposition();\r\n\t\t},\r\n\t\t'^content.title.text|style.(classes|widget)$': function() {\r\n\t\t\tif(elems.tip) {\r\n\t\t\t\tself.update();\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tfunction reposition(event, api, pos, viewport) {\r\n\t\tif(!elems.tip) { return; }\r\n\r\n\t\tvar newCorner = self.corner.clone(),\r\n\t\t\tadjust = pos.adjusted,\r\n\t\t\tmethod = qTip.options.position.adjust.method.split(' '),\r\n\t\t\thorizontal = method[0],\r\n\t\t\tvertical = method[1] || method[0],\r\n\t\t\tshift = { left: FALSE, top: FALSE, x: 0, y: 0 },\r\n\t\t\toffset, css = {}, props;\r\n\r\n\t\t// Make sure our tip position isn't fixed e.g. doesn't adjust with viewport\r\n\t\tif(self.corner.fixed !== TRUE) {\r\n\t\t\t// Horizontal - Shift or flip method\r\n\t\t\tif(horizontal === 'shift' && newCorner.precedance === 'x' && adjust.left && newCorner.y !== 'center') {\r\n\t\t\t\tnewCorner.precedance = newCorner.precedance === 'x' ? 'y' : 'x';\r\n\t\t\t}\r\n\t\t\telse if(horizontal === 'flip' && adjust.left){\r\n\t\t\t\tnewCorner.x = newCorner.x === 'center' ? (adjust.left > 0 ? 'left' : 'right') : (newCorner.x === 'left' ? 'right' : 'left');\r\n\t\t\t}\r\n\r\n\t\t\t// Vertical - Shift or flip method\r\n\t\t\tif(vertical === 'shift' && newCorner.precedance === 'y' && adjust.top && newCorner.x !== 'center') {\r\n\t\t\t\tnewCorner.precedance = newCorner.precedance === 'y' ? 'x' : 'y';\r\n\t\t\t}\r\n\t\t\telse if(vertical === 'flip' && adjust.top) {\r\n\t\t\t\tnewCorner.y = newCorner.y === 'center' ? (adjust.top > 0 ? 'top' : 'bottom') : (newCorner.y === 'top' ? 'bottom' : 'top');\r\n\t\t\t}\r\n\r\n\t\t\t// Update and redraw the tip if needed (check cached details of last drawn tip)\r\n\t\t\tif(newCorner.string() !== cache.corner.string() && (cache.top !== adjust.top || cache.left !== adjust.left)) {\r\n\t\t\t\tself.update(newCorner, FALSE);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Setup tip offset properties\r\n\t\toffset = self.position(newCorner, adjust);\r\n\t\tif(offset.right !== undefined) { offset.left = -offset.right; }\r\n\t\tif(offset.bottom !== undefined) { offset.top = -offset.bottom; }\r\n\t\toffset.user = Math.max(0, opts.offset);\r\n\r\n\t\t// Viewport \"shift\" specific adjustments\r\n\t\tif(shift.left = (horizontal === 'shift' && !!adjust.left)) {\r\n\t\t\tif(newCorner.x === 'center') {\r\n\t\t\t\tcss['margin-left'] = shift.x = offset['margin-left'] - adjust.left;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprops = offset.right !== undefined ?\r\n\t\t\t\t\t[ adjust.left, -offset.left ] : [ -adjust.left, offset.left ];\r\n\r\n\t\t\t\tif( (shift.x = Math.max(props[0], props[1])) > props[0] ) {\r\n\t\t\t\t\tpos.left -= adjust.left;\r\n\t\t\t\t\tshift.left = FALSE;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tcss[ offset.right !== undefined ? 'right' : 'left' ] = shift.x;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(shift.top = (vertical === 'shift' && !!adjust.top)) {\r\n\t\t\tif(newCorner.y === 'center') {\r\n\t\t\t\tcss['margin-top'] = shift.y = offset['margin-top'] - adjust.top;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tprops = offset.bottom !== undefined ?\r\n\t\t\t\t\t[ adjust.top, -offset.top ] : [ -adjust.top, offset.top ];\r\n\r\n\t\t\t\tif( (shift.y = Math.max(props[0], props[1])) > props[0] ) {\r\n\t\t\t\t\tpos.top -= adjust.top;\r\n\t\t\t\t\tshift.top = FALSE;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcss[ offset.bottom !== undefined ? 'bottom' : 'top' ] = shift.y;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t * If the tip is adjusted in both dimensions, or in a\r\n\t\t * direction that would cause it to be anywhere but the\r\n\t\t * outer border, hide it!\r\n\t\t */\r\n\t\telems.tip.css(css).toggle(\r\n\t\t\t!((shift.x && shift.y) || (newCorner.x === 'center' && shift.y) || (newCorner.y === 'center' && shift.x))\r\n\t\t);\r\n\r\n\t\t// Adjust position to accomodate tip dimensions\r\n\t\tpos.left -= offset.left.charAt ? offset.user : horizontal !== 'shift' || shift.top || !shift.left && !shift.top ? offset.left : 0;\r\n\t\tpos.top -= offset.top.charAt ? offset.user : vertical !== 'shift' || shift.left || !shift.left && !shift.top ? offset.top : 0;\r\n\r\n\t\t// Cache details\r\n\t\tcache.left = adjust.left; cache.top = adjust.top;\r\n\t\tcache.corner = newCorner.clone();\r\n\t}\r\n\r\n\t/* border width calculator */\r\n\tfunction borderWidth(corner, side, backup) {\r\n\t\tside = !side ? corner[corner.precedance] : side;\r\n\t\t\r\n\t\tvar isFluid = tooltip.hasClass(fluidClass),\r\n\t\t\tisTitleTop = elems.titlebar && corner.y === 'top',\r\n\t\t\telem = isTitleTop ? elems.titlebar : elems.content,\r\n\t\t\tcss = 'border-' + side + '-width',\r\n\t\t\tval;\r\n\r\n\t\t// Grab the border-width value (add fluid class if needed)\r\n\t\ttooltip.addClass(fluidClass);\r\n\t\tval = parseInt(elem.css(css), 10);\r\n\t\tval = (backup ? val || parseInt(tooltip.css(css), 10) : val) || 0;\r\n\t\ttooltip.toggleClass(fluidClass, isFluid);\r\n\r\n\t\treturn val;\r\n\t}\r\n\r\n\tfunction borderRadius(corner) {\r\n\t\tvar isTitleTop = elems.titlebar && corner.y === 'top',\r\n\t\t\telem = isTitleTop ? elems.titlebar : elems.content,\r\n\t\t\tmoz = $.browser.mozilla,\r\n\t\t\tprefix = moz ? '-moz-' : $.browser.webkit ? '-webkit-' : '',\r\n\t\t\tside = corner.y + (moz ? '' : '-') + corner.x,\r\n\t\t\tcss = prefix + (moz ? 'border-radius-' + side : 'border-' + side + '-radius');\r\n\r\n\t\treturn parseInt(elem.css(css), 10) || parseInt(tooltip.css(css), 10) || 0;\r\n\t}\r\n\r\n\tfunction calculateSize(corner) {\r\n\t\tvar y = corner.precedance === 'y',\r\n\t\t\twidth = size [ y ? 'width' : 'height' ],\r\n\t\t\theight = size [ y ? 'height' : 'width' ],\r\n\t\t\tisCenter = corner.string().indexOf('center') > -1,\r\n\t\t\tbase = width * (isCenter ? 0.5 : 1),\r\n\t\t\tpow = Math.pow,\r\n\t\t\tround = Math.round,\r\n\t\t\tbigHyp, ratio, result,\r\n\r\n\t\tsmallHyp = Math.sqrt( pow(base, 2) + pow(height, 2) ),\r\n\t\t\r\n\t\thyp = [\r\n\t\t\t(border / base) * smallHyp, (border / height) * smallHyp\r\n\t\t];\r\n\t\thyp[2] = Math.sqrt( pow(hyp[0], 2) - pow(border, 2) );\r\n\t\thyp[3] = Math.sqrt( pow(hyp[1], 2) - pow(border, 2) );\r\n\r\n\t\tbigHyp = smallHyp + hyp[2] + hyp[3] + (isCenter ? 0 : hyp[0]);\r\n\t\tratio = bigHyp / smallHyp;\r\n\r\n\t\tresult = [ round(ratio * height), round(ratio * width) ];\r\n\t\treturn { height: result[ y ? 0 : 1 ], width: result[ y ? 1 : 0 ] };\r\n\t}\r\n\r\n\t$.extend(self, {\r\n\t\tinit: function()\r\n\t\t{\r\n\t\t\tvar enabled = self.detectCorner() && (hasCanvas || $.browser.msie);\r\n\r\n\t\t\t// Determine tip corner and type\r\n\t\t\tif(enabled) {\r\n\t\t\t\t// Create a new tip and draw it\r\n\t\t\t\tself.create();\r\n\t\t\t\tself.update();\r\n\r\n\t\t\t\t// Bind update events\r\n\t\t\t\ttooltip.unbind(namespace).bind('tooltipmove'+namespace, reposition);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn enabled;\r\n\t\t},\r\n\r\n\t\tdetectCorner: function()\r\n\t\t{\r\n\t\t\tvar corner = opts.corner,\r\n\t\t\t\tposOptions = qTip.options.position,\r\n\t\t\t\tat = posOptions.at,\r\n\t\t\t\tmy = posOptions.my.string ? posOptions.my.string() : posOptions.my;\r\n\r\n\t\t\t// Detect corner and mimic properties\r\n\t\t\tif(corner === FALSE || (my === FALSE && at === FALSE)) {\r\n\t\t\t\treturn FALSE;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif(corner === TRUE) {\r\n\t\t\t\t\tself.corner = new PLUGINS.Corner(my);\r\n\t\t\t\t}\r\n\t\t\t\telse if(!corner.string) {\r\n\t\t\t\t\tself.corner = new PLUGINS.Corner(corner);\r\n\t\t\t\t\tself.corner.fixed = TRUE;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Cache it\r\n\t\t\tcache.corner = new PLUGINS.Corner( self.corner.string() );\r\n\r\n\t\t\treturn self.corner.string() !== 'centercenter';\r\n\t\t},\r\n\r\n\t\tdetectColours: function(actual) {\r\n\t\t\tvar i, fill, border,\r\n\t\t\t\ttip = elems.tip.css('cssText', ''),\r\n\t\t\t\tcorner = actual || self.corner,\r\n\t\t\t\tprecedance = corner[ corner.precedance ],\r\n\r\n\t\t\t\tborderSide = 'border-' + precedance + '-color',\r\n\t\t\t\tborderSideCamel = 'border' + precedance.charAt(0) + precedance.substr(1) + 'Color',\r\n\r\n\t\t\t\tinvalid = /rgba?\\(0, 0, 0(, 0)?\\)|transparent|#123456/i,\r\n\t\t\t\tbackgroundColor = 'background-color',\r\n\t\t\t\ttransparent = 'transparent',\r\n\t\t\t\timportant = ' !important',\r\n\r\n\t\t\t\tbodyBorder = $(document.body).css('color'),\r\n\t\t\t\tcontentColour = qTip.elements.content.css('color'),\r\n\r\n\t\t\t\tuseTitle = elems.titlebar && (corner.y === 'top' || (corner.y === 'center' && tip.position().top + (size.height / 2) + opts.offset < elems.titlebar.outerHeight(1))),\r\n\t\t\t\tcolorElem = useTitle ? elems.titlebar : elems.content;\r\n\r\n\t\t\t// Apply the fluid class so we can see our CSS values properly\r\n\t\t\ttooltip.addClass(fluidClass);\r\n\r\n\t\t\t// Detect tip colours from CSS styles\r\n\t\t\tcolor.fill = fill = tip.css(backgroundColor);\r\n\t\t\tcolor.border = border = tip[0].style[ borderSideCamel ] || tip.css(borderSide) || tooltip.css(borderSide);\r\n\r\n\t\t\t// Make sure colours are valid\r\n\t\t\tif(!fill || invalid.test(fill)) {\r\n\t\t\t\tcolor.fill = colorElem.css(backgroundColor) || transparent;\r\n\t\t\t\tif(invalid.test(color.fill)) {\r\n\t\t\t\t\tcolor.fill = tooltip.css(backgroundColor) || fill;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif(!border || invalid.test(border) || border === bodyBorder) {\r\n\t\t\t\tcolor.border = colorElem.css(borderSide) || transparent;\r\n\t\t\t\tif(invalid.test(color.border)) {\r\n\t\t\t\t\tcolor.border = border;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Reset background and border colours\r\n\t\t\t$('*', tip).add(tip).css('cssText', backgroundColor+':'+transparent+important+';border:0'+important+';');\r\n\r\n\t\t\t// Remove fluid class\r\n\t\t\ttooltip.removeClass(fluidClass);\r\n\t\t},\r\n\r\n\t\tcreate: function()\r\n\t\t{\r\n\t\t\tvar width = size.width,\r\n\t\t\t\theight = size.height,\r\n\t\t\t\tvml;\r\n\r\n\t\t\t// Remove previous tip element if present\r\n\t\t\tif(elems.tip) { elems.tip.remove(); }\r\n\r\n\t\t\t// Create tip element and prepend to the tooltip\r\n\t\t\telems.tip = $('<div />', { 'class': 'ui-tooltip-tip' }).css({ width: width, height: height }).prependTo(tooltip);\r\n\r\n\t\t\t// Create tip drawing element(s)\r\n\t\t\tif(hasCanvas) {\r\n\t\t\t\t// save() as soon as we create the canvas element so FF2 doesn't bork on our first restore()!\r\n\t\t\t\t$('<canvas />').appendTo(elems.tip)[0].getContext('2d').save();\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvml = '<vml:shape coordorigin=\"0,0\" style=\"display:inline-block; position:absolute; behavior:url(#default#VML);\"></vml:shape>';\r\n\t\t\t\telems.tip.html(vml + vml);\r\n\r\n\t\t\t\t// Prevent mousing down on the tip since it causes problems with .live() handling in IE due to VML\r\n\t\t\t\t$('*', elems.tip).bind('click mousedown', function(event) { event.stopPropagation(); });\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tupdate: function(corner, position)\r\n\t\t{\r\n\t\t\tvar tip = elems.tip,\r\n\t\t\t\tinner = tip.children(),\r\n\t\t\t\twidth = size.width,\r\n\t\t\t\theight = size.height,\r\n\t\t\t\tregular = 'px solid ',\r\n\t\t\t\ttransparent = 'px dashed transparent', // Dashed IE6 border-transparency hack. Awesome!\r\n\t\t\t\tmimic = opts.mimic,\r\n\t\t\t\tround = Math.round,\r\n\t\t\t\tprecedance, context, coords, translate, newSize;\r\n\r\n\t\t\t// Re-determine tip if not already set\r\n\t\t\tif(!corner) { corner = cache.corner || self.corner; }\r\n\r\n\t\t\t// Use corner property if we detect an invalid mimic value\r\n\t\t\tif(mimic === FALSE) { mimic = corner; }\r\n\r\n\t\t\t// Otherwise inherit mimic properties from the corner object as necessary\r\n\t\t\telse {\r\n\t\t\t\tmimic = new PLUGINS.Corner(mimic);\r\n\t\t\t\tmimic.precedance = corner.precedance;\r\n\r\n\t\t\t\tif(mimic.x === 'inherit') { mimic.x = corner.x; }\r\n\t\t\t\telse if(mimic.y === 'inherit') { mimic.y = corner.y; }\r\n\t\t\t\telse if(mimic.x === mimic.y) {\r\n\t\t\t\t\tmimic[ corner.precedance ] = corner[ corner.precedance ];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tprecedance = mimic.precedance;\r\n\r\n\t\t\t// Update our colours\r\n\t\t\tself.detectColours(corner);\r\n\r\n\t\t\t// Detect border width, taking into account colours\r\n\t\t\tif(color.border !== 'transparent' && color.border !== '#123456') {\r\n\t\t\t\t// Grab border width\r\n\t\t\t\tborder = borderWidth(corner, NULL, TRUE);\r\n\r\n\t\t\t\t// If border width isn't zero, use border color as fill (1.0 style tips)\r\n\t\t\t\tif(opts.border === 0 && border > 0) { color.fill = color.border; }\r\n\r\n\t\t\t\t// Set border width (use detected border width if opts.border is true)\r\n\t\t\t\tself.border = border = opts.border !== TRUE ? opts.border : border;\r\n\t\t\t}\r\n\r\n\t\t\t// Border colour was invalid, set border to zero\r\n\t\t\telse { self.border = border = 0; }\r\n\r\n\t\t\t// Calculate coordinates\r\n\t\t\tcoords = calculateTip(mimic, width , height);\r\n\r\n\t\t\t// Determine tip size\r\n\t\t\tself.size = newSize = calculateSize(corner);\r\n\t\t\ttip.css(newSize);\r\n\r\n\t\t\t// Calculate tip translation\r\n\t\t\tif(corner.precedance === 'y') {\r\n\t\t\t\ttranslate = [\r\n\t\t\t\t\tround(mimic.x === 'left' ? border : mimic.x === 'right' ? newSize.width - width - border : (newSize.width - width) / 2),\r\n\t\t\t\t\tround(mimic.y === 'top' ?  newSize.height - height : 0)\r\n\t\t\t\t];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttranslate = [\r\n\t\t\t\t\tround(mimic.x === 'left' ? newSize.width - width : 0),\r\n\t\t\t\t\tround(mimic.y === 'top' ? border : mimic.y === 'bottom' ? newSize.height - height - border : (newSize.height - height) / 2)\r\n\t\t\t\t];\r\n\t\t\t}\r\n\r\n\t\t\t// Canvas drawing implementation\r\n\t\t\tif(hasCanvas) {\r\n\t\t\t\t// Set the canvas size using calculated size\r\n\t\t\t\tinner.attr(newSize);\r\n\t\t\t\t\r\n\t\t\t\t// Grab canvas context and clear/save it\r\n\t\t\t\tcontext = inner[0].getContext('2d');\r\n\t\t\t\tcontext.restore(); context.save();\r\n\t\t\t\tcontext.clearRect(0,0,3000,3000);\r\n\t\t\t\t\r\n\t\t\t\t// Translate origin\r\n\t\t\t\tcontext.translate(translate[0], translate[1]);\r\n\t\t\t\t\r\n\t\t\t\t// Draw the tip\r\n\t\t\t\tcontext.beginPath();\r\n\t\t\t\tcontext.moveTo(coords[0][0], coords[0][1]);\r\n\t\t\t\tcontext.lineTo(coords[1][0], coords[1][1]);\r\n\t\t\t\tcontext.lineTo(coords[2][0], coords[2][1]);\r\n\t\t\t\tcontext.closePath();\r\n\t\t\t\tcontext.fillStyle = color.fill;\r\n\t\t\t\tcontext.strokeStyle = color.border;\r\n\t\t\t\tcontext.lineWidth = border * 2;\r\n\t\t\t\tcontext.lineJoin = 'miter';\r\n\t\t\t\tcontext.miterLimit = 100;\r\n\t\t\t\tif(border) { context.stroke(); }\r\n\t\t\t\tcontext.fill();\r\n\t\t\t}\r\n\r\n\t\t\t// VML (IE Proprietary implementation)\r\n\t\t\telse {\r\n\t\t\t\t// Setup coordinates string\r\n\t\t\t\tcoords = 'm' + coords[0][0] + ',' + coords[0][1] + ' l' + coords[1][0] +\r\n\t\t\t\t\t',' + coords[1][1] + ' ' + coords[2][0] + ',' + coords[2][1] + ' xe';\r\n\r\n\t\t\t\t// Setup VML-specific offset for pixel-perfection\r\n\t\t\t\ttranslate[2] = border && /^(r|b)/i.test(corner.string()) ?\r\n\t\t\t\t\tparseFloat($.browser.version, 10) === 8 ? 2 : 1 : 0;\r\n\r\n\t\t\t\t// Set initial CSS\r\n\t\t\t\tinner.css({\r\n\t\t\t\t\tantialias: ''+(mimic.string().indexOf('center') > -1),\r\n\t\t\t\t\tleft: translate[0] - (translate[2] * Number(precedance === 'x')),\r\n\t\t\t\t\ttop: translate[1] - (translate[2] * Number(precedance === 'y')),\r\n\t\t\t\t\twidth: width + border,\r\n\t\t\t\t\theight: height + border\r\n\t\t\t\t})\r\n\t\t\t\t.each(function(i) {\r\n\t\t\t\t\tvar $this = $(this);\r\n\r\n\t\t\t\t\t// Set shape specific attributes\r\n\t\t\t\t\t$this[ $this.prop ? 'prop' : 'attr' ]({\r\n\t\t\t\t\t\tcoordsize: (width+border) + ' ' + (height+border),\r\n\t\t\t\t\t\tpath: coords,\r\n\t\t\t\t\t\tfillcolor: color.fill,\r\n\t\t\t\t\t\tfilled: !!i,\r\n\t\t\t\t\t\tstroked: !!!i\r\n\t\t\t\t\t})\r\n\t\t\t\t\t.css({ display: border || i ? 'block' : 'none' });\r\n\r\n\t\t\t\t\t// Check if border is enabled and add stroke element\r\n\t\t\t\t\tif(!i && $this.html() === '') {\r\n\t\t\t\t\t\t$this.html(\r\n\t\t\t\t\t\t\t'<vml:stroke weight=\"'+(border*2)+'px\" color=\"'+color.border+'\" miterlimit=\"1000\" joinstyle=\"miter\" ' +\r\n\t\t\t\t\t\t\t' style=\"behavior:url(#default#VML); display:inline-block;\" />'\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Position if needed\r\n\t\t\tif(position !== FALSE) { self.position(corner); }\r\n\t\t},\r\n\r\n\t\t// Tip positioning method\r\n\t\tposition: function(corner)\r\n\t\t{\r\n\t\t\tvar tip = elems.tip,\r\n\t\t\t\tposition = {},\r\n\t\t\t\tuserOffset = Math.max(0, opts.offset),\r\n\t\t\t\tprecedance, dimensions, corners;\r\n\r\n\t\t\t// Return if tips are disabled or tip is not yet rendered\r\n\t\t\tif(opts.corner === FALSE || !tip) { return FALSE; }\r\n\r\n\t\t\t// Inherit corner if not provided\r\n\t\t\tcorner = corner || self.corner;\r\n\t\t\tprecedance = corner.precedance;\r\n\r\n\t\t\t// Determine which tip dimension to use for adjustment\r\n\t\t\tdimensions = calculateSize(corner);\r\n\r\n\t\t\t// Setup corners and offset array\r\n\t\t\tcorners = [ corner.x, corner.y ];\r\n\t\t\tif(precedance === 'x') { corners.reverse(); }\r\n\r\n\t\t\t// Calculate tip position\r\n\t\t\t$.each(corners, function(i, side) {\r\n\t\t\t\tvar b, br;\r\n\r\n\t\t\t\tif(side === 'center') {\r\n\t\t\t\t\tb = precedance === 'y' ? 'left' : 'top';\r\n\t\t\t\t\tposition[ b ] = '50%';\r\n\t\t\t\t\tposition['margin-' + b] = -Math.round(dimensions[ precedance === 'y' ? 'width' : 'height' ] / 2) + userOffset;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tb = borderWidth(corner, side, TRUE);\r\n\t\t\t\t\tbr = borderRadius(corner);\r\n\t\t\t\t\t\r\n\t\t\t\t\tposition[ side ] = i ?\r\n\t\t\t\t\t\tborder ? borderWidth(corner, side) : 0 : \r\n\t\t\t\t\t\tuserOffset + (br > b ? br : 0);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// Adjust for tip dimensions\r\n\t\t\tposition[ corner[precedance] ] -= dimensions[ precedance === 'x' ? 'width' : 'height' ];\r\n\r\n\t\t\t// Set and return new position\r\n\t\t\ttip.css({ top: '', bottom: '', left: '', right: '', margin: '' }).css(position);\r\n\t\t\treturn position;\r\n\t\t},\r\n\t\t\r\n\t\tdestroy: function()\r\n\t\t{\r\n\t\t\t// Remov tip and bound events\r\n\t\t\tif(elems.tip) { elems.tip.remove(); }\r\n\t\t\ttooltip.unbind(namespace);\r\n\t\t}\r\n\t});\r\n\r\n\tself.init();\r\n}\r\n\r\nPLUGINS.tip = function(api)\r\n{\r\n\tvar self = api.plugins.tip;\r\n\t\r\n\treturn 'object' === typeof self ? self : (api.plugins.tip = new Tip(api));\r\n};\r\n\r\n// Initialize tip on render\r\nPLUGINS.tip.initialize = 'render';\r\n\r\n// Setup plugin sanitization options\r\nPLUGINS.tip.sanitize = function(options)\r\n{\r\n\tvar style = options.style, opts;\r\n\tif(style && 'tip' in style) {\r\n\t\topts = options.style.tip;\r\n\t\tif(typeof opts !== 'object'){ options.style.tip = { corner: opts }; }\r\n\t\tif(!(/string|boolean/i).test(typeof opts.corner)) { opts.corner = TRUE; }\r\n\t\tif(typeof opts.width !== 'number'){ delete opts.width; }\r\n\t\tif(typeof opts.height !== 'number'){ delete opts.height; }\r\n\t\tif(typeof opts.border !== 'number' && opts.border !== TRUE){ delete opts.border; }\r\n\t\tif(typeof opts.offset !== 'number'){ delete opts.offset; }\r\n\t}\r\n};\r\n\r\n// Extend original qTip defaults\r\n$.extend(TRUE, QTIP.defaults, {\r\n\tstyle: {\r\n\t\ttip: {\r\n\t\t\tcorner: TRUE,\r\n\t\t\tmimic: FALSE,\r\n\t\t\twidth: 6,\r\n\t\t\theight: 6,\r\n\t\t\tborder: TRUE,\r\n\t\t\toffset: 0\r\n\t\t}\r\n\t}\r\n});\r\n\r\n\r\n}));","/*!\nSlimbox v2.04 - The ultimate lightweight Lightbox clone for jQuery\n(c) 2007-2010 Christophe Beyls <http://www.digitalia.be>\nMIT-style license.\n*/\r\n\r\n/*! Innovasys Modifications\n*\n*  Changed default speed to 200 for most animations\n*  Added linkMapper property so that urls can be fixed up in Mshv outputs\n* \n*/\r\n(function ($) {\r\n\r\n    // Global variables, accessible to Slimbox only\r\n    var win = $(window), options, images, activeImage = -1, activeURL, prevImage, nextImage, compatibleOverlay, middle, centerWidth, centerHeight,\r\n        ie6 = !window.XMLHttpRequest, hiddenElements = [], documentElement = document.documentElement,\r\n\r\n    // Preload images\r\n    preload = {}, preloadPrev = new Image(), preloadNext = new Image(),\r\n\r\n    // DOM elements\r\n    overlay, center, image, sizer, prevLink, nextLink, bottomContainer, bottom, caption, number;\r\n\r\n    /*\n    Initialization\n    */\r\n\r\n    $(function () {\r\n        // Append the Slimbox HTML code at the bottom of the document\r\n        $(\"div.slimboxcontainer\").add(\"body\").first().append(\r\n            $([\r\n                overlay = $('<div id=\"lbOverlay\" />')[0],\r\n                center = $('<div id=\"lbCenter\" />')[0],\r\n                bottomContainer = $('<div id=\"lbBottomContainer\" />')[0]\r\n            ]).css(\"display\", \"none\")\r\n        );\r\n\r\n        image = $('<div id=\"lbImage\" />').appendTo(center).append(\r\n            sizer = $('<div style=\"position: relative;\" />').append([\r\n                prevLink = $('<a id=\"lbPrevLink\" href=\"#\" />').click(previous)[0],\r\n                nextLink = $('<a id=\"lbNextLink\" href=\"#\" />').click(next)[0]\r\n            ])[0]\r\n        )[0];\r\n\r\n        bottom = $('<div id=\"lbBottom\" />').appendTo(bottomContainer).append([\r\n            $('<a id=\"lbCloseLink\" href=\"#\" />').click(close)[0],\r\n            caption = $('<div id=\"lbCaption\" />')[0],\r\n            number = $('<div id=\"lbNumber\" />')[0],\r\n            $('<div style=\"clear: both;\" />')[0]\r\n        ])[0];\r\n    });\r\n\r\n\r\n    /*\n    API\n    */\r\n\r\n    // Open Slimbox with the specified parameters\r\n    $.slimbox = function (_images, startImage, _options) {\r\n        options = $.extend({\r\n            loop: false, \t\t\t// Allows to navigate between first and last images\r\n            overlayOpacity: 0.8, \t\t// 1 is opaque, 0 is completely transparent (change the color in the CSS file)\r\n            overlayFadeDuration: 200, \t// Duration of the overlay fade-in and fade-out animations (in milliseconds)\r\n            resizeDuration: 200, \t\t// Duration of each of the box resize animations (in milliseconds)\r\n            resizeEasing: \"swing\", \t\t// \"swing\" is jQuery's default easing\r\n            initialWidth: 250, \t\t// Initial width of the box (in pixels)\r\n            initialHeight: 250, \t\t// Initial height of the box (in pixels)\r\n            imageFadeDuration: 200, \t\t// Duration of the image fade-in animation (in milliseconds)\r\n            captionAnimationDuration: 200, \t// Duration of the caption animation (in milliseconds)\r\n            counterText: \"Image {x} of {y}\", // Translate or change as you wish, or set it to false to disable counter text for image groups\r\n            closeKeys: [27, 88, 67], \t// Array of keycodes to close Slimbox, default: Esc (27), 'x' (88), 'c' (67)\r\n            previousKeys: [37, 80], \t\t// Array of keycodes to navigate to the previous image, default: Left arrow (37), 'p' (80)\r\n            nextKeys: [39, 78]\t\t\t// Array of keycodes to navigate to the next image, default: Right arrow (39), 'n' (78)\r\n        }, _options);\r\n\r\n        // The function is called for a single image, with URL and Title as first two arguments\r\n        if (typeof _images == \"string\") {\r\n            _images = [[_images, startImage]];\r\n            startImage = 0;\r\n        }\r\n\r\n        middle = win.scrollTop() + (win.height() / 2);\r\n        centerWidth = options.initialWidth;\r\n        centerHeight = options.initialHeight;\r\n        $(center).css({ top: Math.max(0, middle - (centerHeight / 2)), width: centerWidth, height: centerHeight, marginLeft: -centerWidth / 2 }).show();\r\n        compatibleOverlay = ie6 || (overlay.currentStyle && (overlay.currentStyle.position != \"fixed\"));\r\n        if (compatibleOverlay) overlay.style.position = \"absolute\";\r\n        $(overlay).css(\"opacity\", options.overlayOpacity).fadeIn(options.overlayFadeDuration);\r\n        position();\r\n        setup(1);\r\n\r\n        images = _images;\r\n        options.loop = options.loop && (images.length > 1);\r\n        return changeImage(startImage);\r\n    };\r\n\r\n    $.slimbox.linkMapper = function (el) {\r\n        var href = $(el).data('href');\r\n        if (!href) {\r\n            href = el.href;\r\n        }\r\n        return [href, el.title];\r\n    };\r\n\r\n    /*\n    options:\tOptional options object, see jQuery.slimbox()\n    linkMapper:\tOptional function taking a link DOM element and an index as arguments and returning an array containing 2 elements:\n    the image URL and the image caption (may contain HTML)\n    linksFilter:\tOptional function taking a link DOM element and an index as arguments and returning true if the element is part of\n    the image collection that will be shown on click, false if not. \"this\" refers to the element that was clicked.\n    This function must always return true when the DOM element argument is \"this\".\n    */\r\n    $.fn.slimbox = function (_options, linkMapper, linksFilter) {\r\n        linkMapper = linkMapper || $.slimbox.linkMapper;\r\n\r\n        linksFilter = linksFilter || function () {\r\n            return true;\r\n        };\r\n\r\n        var links = this;\r\n\r\n        return links.unbind(\"click\").click(function () {\r\n            // Build the list of images that will be displayed\r\n            var link = this, startIndex = 0, filteredLinks, i = 0, length;\r\n            filteredLinks = $.grep(links, function (el, i) {\r\n                return linksFilter.call(link, el, i);\r\n            });\r\n\r\n            // We cannot use jQuery.map() because it flattens the returned array\r\n            for (length = filteredLinks.length; i < length; ++i) {\r\n                if (filteredLinks[i] == link) startIndex = i;\r\n                filteredLinks[i] = linkMapper(filteredLinks[i], i);\r\n            }\r\n\r\n            return $.slimbox(filteredLinks, startIndex, _options);\r\n        });\r\n    };\r\n\r\n\r\n    /*\n    Internal functions\n    */\r\n\r\n    function position() {\r\n        var l = win.scrollLeft(), w = win.width();\r\n        $([center, bottomContainer]).css(\"left\", l + (w / 2));\r\n        if (compatibleOverlay) $(overlay).css({ left: l, top: win.scrollTop(), width: w, height: win.height() });\r\n    }\r\n\r\n    function setup(open) {\r\n        if (open) {\r\n            $(\"object\").add(ie6 ? \"select\" : \"embed\").each(function (index, el) {\r\n                hiddenElements[index] = [el, el.style.visibility];\r\n                el.style.visibility = \"hidden\";\r\n            });\r\n        } else {\r\n            $.each(hiddenElements, function (index, el) {\r\n                el[0].style.visibility = el[1];\r\n            });\r\n            hiddenElements = [];\r\n        }\r\n        var fn = open ? \"bind\" : \"unbind\";\r\n        win[fn](\"scroll resize\", position);\r\n        $(document)[fn](\"keydown\", keyDown);\r\n    }\r\n\r\n    function keyDown(event) {\r\n        var code = event.keyCode, fn = $.inArray;\r\n        // Prevent default keyboard action (like navigating inside the page)\r\n        return (fn(code, options.closeKeys) >= 0) ? close()\r\n            : (fn(code, options.nextKeys) >= 0) ? next()\r\n            : (fn(code, options.previousKeys) >= 0) ? previous()\r\n            : false;\r\n    }\r\n\r\n    function previous() {\r\n        return changeImage(prevImage);\r\n    }\r\n\r\n    function next() {\r\n        return changeImage(nextImage);\r\n    }\r\n\r\n    function changeImage(imageIndex) {\r\n        if (imageIndex >= 0) {\r\n            activeImage = imageIndex;\r\n            activeURL = images[activeImage][0];\r\n            // HelpStudio extension for Microsoft Help Viewer compatibility\r\n            activeURL = Innovasys.Content.Features.HelpViewerCompatibilityDocumentFeature.fixUrl(activeURL);\r\n            prevImage = (activeImage || (options.loop ? images.length : 0)) - 1;\r\n            nextImage = ((activeImage + 1) % images.length) || (options.loop ? 0 : -1);\r\n\r\n            stop();\r\n            center.className = \"lbLoading\";\r\n\r\n            preload = new Image();\r\n            preload.onload = animateBox;\r\n            preload.src = activeURL;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function animateBox() {\r\n        center.className = \"\";\r\n\r\n        /* Modified code to constrain image overlay to window dimensions */\n\n        var useDefaultSizing = true;\n        try {\n            /* make sure the image won't be bigger than the window */\n            var windowWidth = $(window).width() - 20;\n            var windowHeight = $(window).height() - 40;\n\n            /* determine proper w and h for img, based on original image's dimensions and maximumSize */\n            var maximumWidth = preload.width;\n            var maximumHeight = preload.height;\r\n\r\n            if ((preload.width - windowWidth) > (preload.height - windowHeight)) {\r\n                // Less space horizontally, determine max size from width\r\n                maximumWidth = windowWidth - 100;\r\n                maximumHeight = preload.height * (maximumWidth / preload.width);\r\n            } else {\r\n                maximumHeight = windowHeight - 200;\r\n                maximumWidth = preload.width * (maximumHeight / preload.height);\r\n            }\n\n            if (preload.width > maximumWidth || preload.height > maximumHeight) {\n                /* constrain it */\n                $(image).css({ backgroundImage: \"url(\" + activeURL + \")\", backgroundSize: maximumWidth + \"px \" + maximumHeight + \"px\", visibility: \"hidden\", display: \"\" });\n                $(sizer).width(maximumWidth);\n                $([sizer, prevLink, nextLink]).height(maximumHeight);\r\n\r\n                useDefaultSizing = false;\r\n            }\r\n        }\n        catch (ex) {\n            /* Falls back to original sizing code */\r\n        }\n        if (useDefaultSizing) {\r\n            $(image).css({ backgroundImage: \"url(\" + activeURL + \")\", backgroundSize: \"\", visibility: \"hidden\", display: \"\" });\n            $(sizer).width(preload.width);\n            $([sizer, prevLink, nextLink]).height(preload.height);\r\n        }\n\n        /* End Modified code to constrain image to window dimensions */\r\n\r\n        $(caption).html(images[activeImage][1] || \"\");\r\n        $(number).html((((images.length > 1) && options.counterText) || \"\").replace(/{x}/, activeImage + 1).replace(/{y}/, images.length));\r\n\r\n        if (prevImage >= 0) preloadPrev.src = images[prevImage][0];\r\n        if (nextImage >= 0) preloadNext.src = images[nextImage][0];\r\n\r\n        centerWidth = image.offsetWidth;\r\n        centerHeight = image.offsetHeight;\r\n        var top = Math.max(0, middle - (centerHeight / 2));\r\n        if (center.offsetHeight != centerHeight) {\r\n            $(center).animate({ height: centerHeight, top: top }, options.resizeDuration, options.resizeEasing);\r\n        }\r\n        if (center.offsetWidth != centerWidth) {\r\n            $(center).animate({ width: centerWidth, marginLeft: -centerWidth / 2 }, options.resizeDuration, options.resizeEasing);\r\n        }\r\n        $(center).queue(function () {\r\n            $(bottomContainer).css({ width: centerWidth, top: top + centerHeight, marginLeft: -centerWidth / 2, visibility: \"hidden\", display: \"\" });\r\n            $(image).css({ display: \"none\", visibility: \"\", opacity: \"\" }).fadeIn(options.imageFadeDuration, animateCaption);\r\n        });\r\n    }\r\n\r\n    function animateCaption() {\r\n        if (prevImage >= 0) $(prevLink).show();\r\n        if (nextImage >= 0) $(nextLink).show();\r\n        $(bottom).css(\"marginTop\", -bottom.offsetHeight).animate({ marginTop: 0 }, options.captionAnimationDuration);\r\n        bottomContainer.style.visibility = \"\";\r\n    }\r\n\r\n    function stop() {\r\n        preload.onload = null;\r\n        preload.src = preloadPrev.src = preloadNext.src = activeURL;\r\n        $([center, image, bottom]).stop(true);\r\n        $([prevLink, nextLink, image, bottomContainer]).hide();\r\n    }\r\n\r\n    function close() {\r\n        if (activeImage >= 0) {\r\n            stop();\r\n            activeImage = prevImage = nextImage = -1;\r\n            $(center).hide();\r\n            $(overlay).stop().fadeOut(options.overlayFadeDuration, setup);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n})(jQuery);","/*jshint browser:true */\r\n/*!\r\n* FitVids 1.1\r\n*\r\n* Copyright 2013, Chris Coyier - http://css-tricks.com + Dave Rupert - http://daverupert.com\r\n* Credit to Thierry Koblentz - http://www.alistapart.com/articles/creating-intrinsic-ratios-for-video/\r\n* Released under the WTFPL license - http://sam.zoy.org/wtfpl/\r\n*\r\n*/\r\n\r\n; (function ($) {\r\n\r\n    'use strict';\r\n\r\n    $.fn.fitVids = function (options) {\r\n        var settings = {\r\n            customSelector: null,\r\n            ignore: null\r\n        };\r\n\r\n        if (!document.getElementById('fit-vids-style')) {\r\n            // appendStyles: https://github.com/toddmotto/fluidvids/blob/master/dist/fluidvids.js\r\n            var head = document.head || document.getElementsByTagName('head')[0];\r\n            var css = '.fluid-width-video-wrapper{width:100%;position:relative;padding:0;}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper object,.fluid-width-video-wrapper embed {position:absolute;top:0;left:0;width:100%;height:100%;}';\r\n            var div = document.createElement(\"div\");\r\n            div.innerHTML = '<p>x</p><style id=\"fit-vids-style\">' + css + '</style>';\r\n            head.appendChild(div.childNodes[1]);\r\n        }\r\n\r\n        if (options) {\r\n            $.extend(settings, options);\r\n        }\r\n\r\n        return this.each(function () {\r\n            var selectors = [\r\n              'iframe[src*=\"player.vimeo.com\"]',\r\n              'iframe[src*=\"youtube.com\"]',\r\n              'iframe[src*=\"youtube-nocookie.com\"]',\r\n              'iframe[src*=\"kickstarter.com\"][src*=\"video.html\"]',\r\n              'object',\r\n              'embed'\r\n            ];\r\n\r\n            if (settings.customSelector) {\r\n                selectors.push(settings.customSelector);\r\n            }\r\n\r\n            var ignoreList = '.fitvidsignore';\r\n\r\n            if (settings.ignore) {\r\n                ignoreList = ignoreList + ', ' + settings.ignore;\r\n            }\r\n\r\n            var $allVideos = $(this).find(selectors.join(','));\r\n            $allVideos = $allVideos.not('object object'); // SwfObj conflict patch\r\n            $allVideos = $allVideos.not(ignoreList); // Disable FitVids on this video.\r\n\r\n            $allVideos.each(function () {\r\n                var $this = $(this);\r\n                if ($this.parents(ignoreList).length > 0) {\r\n                    return; // Disable FitVids on this video.\r\n                }\r\n                if (this.tagName.toLowerCase() === 'embed' && $this.parent('object').length || $this.parent('.fluid-width-video-wrapper').length) { return; }\r\n                if ((!$this.css('height') && !$this.css('width')) && (isNaN($this.attr('height')) || isNaN($this.attr('width')))) {\r\n                    $this.attr('height', 9);\r\n                    $this.attr('width', 16);\r\n                }\r\n                var height = (this.tagName.toLowerCase() === 'object' || ($this.attr('height') && !isNaN(parseInt($this.attr('height'), 10)))) ? parseInt($this.attr('height'), 10) : $this.height(),\r\n                    width = !isNaN(parseInt($this.attr('width'), 10)) ? parseInt($this.attr('width'), 10) : $this.width(),\r\n                    aspectRatio = height / width;\r\n                if (!$this.attr('name')) {\r\n                    var videoName = 'fitvid' + $.fn.fitVids._count;\r\n                    $this.attr('name', videoName);\r\n                    $.fn.fitVids._count++;\r\n                }\r\n                $this.wrap('<div class=\"fluid-width-video-wrapper\"></div>').parent('.fluid-width-video-wrapper').css('padding-top', (aspectRatio * 100) + '%');\r\n                $this.removeAttr('height').removeAttr('width');\r\n            });\r\n        });\r\n    };\r\n\r\n    // Internal counter for unique video names.\r\n    $.fn.fitVids._count = 0;\r\n\r\n    // Works with either jQuery or Zepto\r\n})(window.jQuery || window.Zepto);","/*! modernizr 3.6.0 (Custom Build) | MIT *\r\n * https://modernizr.com/download/?-mq-prefixes-setclasses-shiv-teststyles !*/\r\n!function (e, t, n) { function a(e, t) { return typeof e === t } function r() { var e, t, n, r, o, i, s; for (var l in d) if (d.hasOwnProperty(l)) { if (e = [], t = d[l], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++)e.push(t.options.aliases[n].toLowerCase()); for (r = a(t.fn, \"function\") ? t.fn() : t.fn, o = 0; o < e.length; o++)i = e[o], s = i.split(\".\"), 1 === s.length ? Modernizr[s[0]] = r : (!Modernizr[s[0]] || Modernizr[s[0]] instanceof Boolean || (Modernizr[s[0]] = new Boolean(Modernizr[s[0]])), Modernizr[s[0]][s[1]] = r), c.push((r ? \"\" : \"no-\") + s.join(\"-\")) } } function o(e) { var t = m.className, n = Modernizr._config.classPrefix || \"\"; if (p && (t = t.baseVal), Modernizr._config.enableJSClass) { var a = new RegExp(\"(^|\\\\s)\" + n + \"no-js(\\\\s|$)\"); t = t.replace(a, \"$1\" + n + \"js$2\") } Modernizr._config.enableClasses && (t += \" \" + n + e.join(\" \" + n), p ? m.className.baseVal = t : m.className = t) } function i() { return \"function\" != typeof t.createElement ? t.createElement(arguments[0]) : p ? t.createElementNS.call(t, \"http://www.w3.org/2000/svg\", arguments[0]) : t.createElement.apply(t, arguments) } function s() { var e = t.body; return e || (e = i(p ? \"svg\" : \"body\"), e.fake = !0), e } function l(e, n, a, r) { var o, l, c, d, u = \"modernizr\", f = i(\"div\"), p = s(); if (parseInt(a, 10)) for (; a--;)c = i(\"div\"), c.id = r ? r[a] : u + (a + 1), f.appendChild(c); return o = i(\"style\"), o.type = \"text/css\", o.id = \"s\" + u, (p.fake ? p : f).appendChild(o), p.appendChild(f), o.styleSheet ? o.styleSheet.cssText = e : o.appendChild(t.createTextNode(e)), f.id = u, p.fake && (p.style.background = \"\", p.style.overflow = \"hidden\", d = m.style.overflow, m.style.overflow = \"hidden\", m.appendChild(p)), l = n(f, e), p.fake ? (p.parentNode.removeChild(p), m.style.overflow = d, m.offsetHeight) : f.parentNode.removeChild(f), !!l } var c = [], d = [], u = { _version: \"3.6.0\", _config: { classPrefix: \"\", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function (e, t) { var n = this; setTimeout(function () { t(n[e]) }, 0) }, addTest: function (e, t, n) { d.push({ name: e, fn: t, options: n }) }, addAsyncTest: function (e) { d.push({ name: null, fn: e }) } }, Modernizr = function () { }; Modernizr.prototype = u, Modernizr = new Modernizr; var f = u._config.usePrefixes ? \" -webkit- -moz- -o- -ms- \".split(\" \") : [\"\", \"\"]; u._prefixes = f; var m = t.documentElement, p = \"svg\" === m.nodeName.toLowerCase(); p || !function (e, t) { function n(e, t) { var n = e.createElement(\"p\"), a = e.getElementsByTagName(\"head\")[0] || e.documentElement; return n.innerHTML = \"x<style>\" + t + \"</style>\", a.insertBefore(n.lastChild, a.firstChild) } function a() { var e = E.elements; return \"string\" == typeof e ? e.split(\" \") : e } function r(e, t) { var n = E.elements; \"string\" != typeof n && (n = n.join(\" \")), \"string\" != typeof e && (e = e.join(\" \")), E.elements = n + \" \" + e, c(t) } function o(e) { var t = y[e[g]]; return t || (t = {}, v++, e[g] = v, y[v] = t), t } function i(e, n, a) { if (n || (n = t), u) return n.createElement(e); a || (a = o(n)); var r; return r = a.cache[e] ? a.cache[e].cloneNode() : h.test(e) ? (a.cache[e] = a.createElem(e)).cloneNode() : a.createElem(e), !r.canHaveChildren || p.test(e) || r.tagUrn ? r : a.frag.appendChild(r) } function s(e, n) { if (e || (e = t), u) return e.createDocumentFragment(); n = n || o(e); for (var r = n.frag.cloneNode(), i = 0, s = a(), l = s.length; l > i; i++)r.createElement(s[i]); return r } function l(e, t) { t.cache || (t.cache = {}, t.createElem = e.createElement, t.createFrag = e.createDocumentFragment, t.frag = t.createFrag()), e.createElement = function (n) { return E.shivMethods ? i(n, e, t) : t.createElem(n) }, e.createDocumentFragment = Function(\"h,f\", \"return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(\" + a().join().replace(/[\\w\\-:]+/g, function (e) { return t.createElem(e), t.frag.createElement(e), 'c(\"' + e + '\")' }) + \");return n}\")(E, t.frag) } function c(e) { e || (e = t); var a = o(e); return !E.shivCSS || d || a.hasCSS || (a.hasCSS = !!n(e, \"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}\")), u || l(e, a), e } var d, u, f = \"3.7.3\", m = e.html5 || {}, p = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i, h = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i, g = \"_html5shiv\", v = 0, y = {}; !function () { try { var e = t.createElement(\"a\"); e.innerHTML = \"<xyz></xyz>\", d = \"hidden\" in e, u = 1 == e.childNodes.length || function () { t.createElement(\"a\"); var e = t.createDocumentFragment(); return \"undefined\" == typeof e.cloneNode || \"undefined\" == typeof e.createDocumentFragment || \"undefined\" == typeof e.createElement }() } catch (n) { d = !0, u = !0 } }(); var E = { elements: m.elements || \"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output picture progress section summary template time video\", version: f, shivCSS: m.shivCSS !== !1, supportsUnknownElements: u, shivMethods: m.shivMethods !== !1, type: \"default\", shivDocument: c, createElement: i, createDocumentFragment: s, addElements: r }; e.html5 = E, c(t), \"object\" == typeof module && module.exports && (module.exports = E) }(\"undefined\" != typeof e ? e : this, t); var h = function () { var t = e.matchMedia || e.msMatchMedia; return t ? function (e) { var n = t(e); return n && n.matches || !1 } : function (t) { var n = !1; return l(\"@media \" + t + \" { #modernizr { position: absolute; } }\", function (t) { n = \"absolute\" == (e.getComputedStyle ? e.getComputedStyle(t, null) : t.currentStyle).position }), n } }(); u.mq = h; u.testStyles = l; r(), o(c), delete u.addTest, delete u.addAsyncTest; for (var g = 0; g < Modernizr._q.length; g++)Modernizr._q[g](); e.Modernizr = Modernizr }(window, document);","// yepnope.js\r\n// v2.0.0\r\n//\r\n// by\r\n// Alex Sexton - @slexaxton - alexsexton[at]gmail.com\r\n// Ralph Holzmann - @rlph - ralphholzmann[at]gmail.com\r\n//\r\n// http://yepnopejs.com/\r\n// https://github.com/SlexAxton/yepnope.js/\r\n//\r\n// New BSD\r\n//\r\n// Consider inlining this script after minifying\r\n\r\nwindow.yepnope = (function (window, document, undef) {\r\n    // Yepnope's style is intentionally very flat to aid in\r\n    // minification. The authors are usually against too much\r\n    // self-minification, but in the case of a script loader, we're\r\n    // especially file size sensitive.\r\n\r\n    // Some aliases\r\n    var sTimeout = window.setTimeout;\r\n    var firstScript;\r\n    var scriptsQueue = [];\r\n    var count = 0;\r\n    var toString = {}.toString;\r\n\r\n    function noop() { }\r\n\r\n    // Helper functions\r\n    function isObject(obj) {\r\n        return Object(obj) === obj;\r\n    }\r\n\r\n    function isString(s) {\r\n        return typeof s == 'string';\r\n    }\r\n\r\n    // Loader Utilities\r\n    function uniq() {\r\n        return 'yn_' + (count++);\r\n    }\r\n\r\n    function readFirstScript() {\r\n        if (!firstScript || !firstScript.parentNode) {\r\n            firstScript = document.getElementsByTagName('script')[0];\r\n        }\r\n    }\r\n\r\n    function isFileReady(readyState) {\r\n        // Check to see if any of the ways a file can be ready are available as properties on the file's element\r\n        return (!readyState || readyState == 'loaded' || readyState == 'complete' || readyState == 'uninitialized');\r\n    }\r\n\r\n    function runWhenReady(src, cb) {\r\n        cb.call(window);\r\n    }\r\n\r\n    // Inject a script into the page and know when it's done\r\n    function injectJs(options, cb) {\r\n        var src;\r\n        var attrs;\r\n        var timeout;\r\n\r\n        if (isString(options)) {\r\n            src = options;\r\n        }\r\n        else if (isObject(options)) {\r\n            // Allow rewritten url to take precedence\r\n            src = options._url || options.src;\r\n            attrs = options.attrs;\r\n            timeout = options.timeout;\r\n        }\r\n\r\n        cb = cb || noop;\r\n        attrs = attrs || {};\r\n\r\n        var script = document.createElement('script');\r\n        var done;\r\n        var i;\r\n\r\n        timeout = timeout || yepnope.errorTimeout;\r\n\r\n        script.src = src;\r\n\r\n        // Add our extra attributes to the script element\r\n        for (i in attrs) {\r\n            script.setAttribute(i, attrs[i]);\r\n        }\r\n\r\n        // Bind to load events\r\n        script.onreadystatechange = script.onload = function () {\r\n\r\n            if (!done && isFileReady(script.readyState)) {\r\n                // Set done to prevent this function from being called twice.\r\n                done = 1;\r\n\r\n                // Just run the callback\r\n                runWhenReady(src, cb);\r\n            }\r\n\r\n            // Handle memory leak in IE\r\n            script.onload = script.onreadystatechange = script.onerror = null;\r\n        };\r\n\r\n        // This won't work in every browser, but\r\n        // would be helpful in those that it does.\r\n        // http://stackoverflow.com/questions/2027849/how-to-trigger-script-onerror-in-internet-explorer/2032014#2032014\r\n        // For those that don't support it, the timeout will be the backup\r\n        script.onerror = function () {\r\n            // Don't call the callback again, so we mark it done\r\n            done = 1;\r\n            cb(new Error('Script Error: ' + src));\r\n            // We don't waste bytes on cleaning up memory in error cases\r\n            // because hopefully it doesn't happen often enough to matter.\r\n            // And you're probably already in an 'uh-oh' situation.\r\n        };\r\n\r\n        // 404 Fallback\r\n        sTimeout(function () {\r\n            // Don't do anything if the script has already finished\r\n            if (!done) {\r\n                // Mark it as done, which means the callback won't run again\r\n                done = 1;\r\n\r\n                // Might as well pass in an error-state if we fire the 404 fallback\r\n                cb(new Error('Timeout: ' + src));\r\n                // Maybe...\r\n                script.parentNode.removeChild(script);\r\n            }\r\n        }, timeout);\r\n\r\n        // Inject script into to document\r\n        readFirstScript();\r\n        firstScript.parentNode.insertBefore(script, firstScript);\r\n    }\r\n\r\n    function injectCss(options, cb) {\r\n        var attrs = {};\r\n        var href;\r\n        var i;\r\n        var media;\r\n\r\n        // optionally accept an object of settings\r\n        // or a string that's the url\r\n        if (isObject(options)) {\r\n            // allow the overriden _url property to take precendence\r\n            href = options._url || options.href;\r\n            attrs = options.attrs || {};\r\n        }\r\n        else if (isString(options)) {\r\n            href = options;\r\n        }\r\n\r\n        // Create stylesheet link\r\n        var link = document.createElement('link');\r\n\r\n        cb = cb || noop;\r\n\r\n        // Add attributes\r\n        link.href = href;\r\n        link.rel = 'stylesheet';\r\n        // Technique to force non-blocking loading from:\r\n        // https://github.com/filamentgroup/loadCSS/blob/master/loadCSS.js#L20\r\n        link.media = 'only x';\r\n        link.type = 'text/css';\r\n\r\n        // On next tick, just set the media to what it's supposed to be\r\n        sTimeout(function () {\r\n            link.media = attrs.media || 'all';\r\n        });\r\n\r\n        // Add our extra attributes to the link element\r\n        for (i in attrs) {\r\n            link.setAttribute(i, attrs[i]);\r\n        }\r\n\r\n        readFirstScript();\r\n        // We append link tags so the cascades work as expected.\r\n        // A little more dangerous, but if you're injecting CSS\r\n        // dynamically, you probably can handle it.\r\n        firstScript.parentNode.appendChild(link);\r\n\r\n        // Always just run the callback for CSS on next tick. We're not\r\n        // going to try to normalize this, so don't worry about runwhenready here.\r\n        sTimeout(function () {\r\n            cb.call(window);\r\n        });\r\n    }\r\n\r\n    function getExtension(url) {\r\n        //The extension is always the last characters before the ? and after a period.\r\n        //The previous method was not accounting for the possibility of a period in the query string.\r\n        var b = url.split('?')[0];\r\n        return b.substr(b.lastIndexOf('.') + 1);\r\n    }\r\n\r\n    function defaultUrlFormatter(base, tests) {\r\n        var url = base;\r\n        var passed = [];\r\n        var failed = [];\r\n\r\n        for (var i in tests) {\r\n            if (tests.hasOwnProperty(i)) {\r\n                if (tests[i]) {\r\n                    passed.push(encodeURIComponent(i));\r\n                }\r\n                else {\r\n                    failed.push(encodeURIComponent(i));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (passed.length || failed.length) {\r\n            url += '?';\r\n        }\r\n\r\n        if (passed.length) {\r\n            url += 'yep=' + passed.join(',');\r\n        }\r\n\r\n        if (failed.length) {\r\n            url += (passed.length ? '&' : '') + 'nope=' + failed.join(',');\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    // The leaked function. Mostly just takes a set\r\n    // of arguments, and then passes them to be run.\r\n    function yepnope(url, tests, cb) {\r\n        var options;\r\n\r\n        if (isObject(url)) {\r\n            // It was just kidding about being the url\r\n            options = url;\r\n            // Can't ever have both, so this is fine\r\n            url = options.src || options.href;\r\n        }\r\n\r\n        url = yepnope.urlFormatter(url, tests);\r\n\r\n        if (!options) {\r\n            options = { _url: url };\r\n        }\r\n        else {\r\n            options._url = url;\r\n        }\r\n\r\n        var type = getExtension(url);\r\n\r\n        if (type === 'js') {\r\n            injectJs(options, cb);\r\n        }\r\n        else if (type === 'css') {\r\n            injectCss(options, cb);\r\n        }\r\n        else {\r\n            throw new Error('Unable to determine filetype.');\r\n        }\r\n    }\r\n\r\n    // Add a default for the error timer\r\n    yepnope.errorTimeout = 10e3;\r\n    // Expose no BS script injection\r\n    yepnope.injectJs = injectJs;\r\n    // Expose super-lightweight css injector\r\n    yepnope.injectCss = injectCss;\r\n    // Allow someone to override the url writer\r\n    yepnope.urlFormatter = defaultUrlFormatter;\r\n\r\n    return yepnope;\r\n})(window, document);"]}